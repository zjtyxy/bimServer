/* 2018-12-18 14:07:17 | 版权所有 广西中遥 http://91daocao.com   */
!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.turf = {})
}(this, function (t) {
    "use strict";
    var f = 6371008.8, r = {
        meters: f,
        metres: f,
        millimeters: 1e3 * f,
        millimetres: 1e3 * f,
        centimeters: 100 * f,
        centimetres: 100 * f,
        kilometers: f / 1e3,
        kilometres: f / 1e3,
        miles: f / 1609.344,
        nauticalmiles: f / 1852,
        inches: 39.37 * f,
        yards: f / 1.0936,
        feet: 3.28084 * f,
        radians: 1,
        degrees: f / 111325
    }, e = {
        meters: 1,
        metres: 1,
        millimeters: 1e3,
        millimetres: 1e3,
        centimeters: 100,
        centimetres: 100,
        kilometers: .001,
        kilometres: .001,
        miles: 1 / 1609.344,
        nauticalmiles: 1 / 1852,
        inches: 39.37,
        yards: 1 / 1.0936,
        feet: 3.28084,
        radians: 1 / f,
        degrees: 1 / 111325
    }, o = {
        meters: 1,
        metres: 1,
        millimeters: 1e6,
        millimetres: 1e6,
        centimeters: 1e4,
        centimetres: 1e4,
        kilometers: 1e-6,
        kilometres: 1e-6,
        acres: 247105e-9,
        miles: 386e-9,
        yards: 1.195990046,
        feet: 10.763910417,
        inches: 1550.003100006
    };

    function j(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.bbox, i = n.id;
        if (void 0 === t) throw new Error("geometry is required");
        if (e && e.constructor !== Object) throw new Error("properties must be an Object");
        r && w(r), i && b(i);
        var o = {type: "Feature"};
        return i && (o.id = i), r && (o.bbox = r), o.properties = e || {}, o.geometry = t, o
    }

    function n(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r, i = n.bbox;
        if (!t) throw new Error("type is required");
        if (!e) throw new Error("coordinates is required");
        if (!Array.isArray(e)) throw new Error("coordinates must be an Array");
        switch (i && w(i), t) {
            case"Point":
                r = X(e).geometry;
                break;
            case"LineString":
                r = U(e).geometry;
                break;
            case"Polygon":
                r = B(e).geometry;
                break;
            case"MultiPoint":
                r = u(e).geometry;
                break;
            case"MultiLineString":
                r = v(e).geometry;
                break;
            case"MultiPolygon":
                r = x(e).geometry;
                break;
            default:
                throw new Error(t + " is invalid")
        }
        return i && (r.bbox = i), r
    }

    function X(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
        if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long");
        if (!V(t[0]) || !V(t[1])) throw new Error("coordinates must contain numbers");
        return j({type: "Point", coordinates: t}, e, n)
    }

    function i(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
        return Y(t.map(function (t) {
            return X(t, e)
        }), n)
    }

    function B(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            for (var o = 0; o < i[i.length - 1].length; o++) {
                if (0 === r && 0 === o && !V(i[0][0]) || !V(i[0][1])) throw new Error("coordinates must contain numbers");
                if (i[i.length - 1][o] !== i[0][o]) throw new Error("First and last Position are not equivalent.")
            }
        }
        return j({type: "Polygon", coordinates: t}, e, n)
    }

    function s(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
        return Y(t.map(function (t) {
            return B(t, e)
        }), n)
    }

    function U(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        if (t.length < 2) throw new Error("coordinates must be an array of two or more positions");
        if (!V(t[0][1]) || !V(t[0][1])) throw new Error("coordinates must contain numbers");
        return j({type: "LineString", coordinates: t}, e, n)
    }

    function a(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
        return Y(t.map(function (t) {
            return U(t, e)
        }), n)
    }

    function Y(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.bbox, r = e.id;
        if (!t) throw new Error("No features passed");
        if (!Array.isArray(t)) throw new Error("features must be an Array");
        n && w(n), r && b(r);
        var i = {type: "FeatureCollection"};
        return r && (i.id = r), n && (i.bbox = n), i.features = t, i
    }

    function v(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        return j({type: "MultiLineString", coordinates: t}, e, n)
    }

    function u(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        return j({type: "MultiPoint", coordinates: t}, e, n)
    }

    function x(t, e, n) {
        if (!t) throw new Error("coordinates is required");
        return j({type: "MultiPolygon", coordinates: t}, e, n)
    }

    function c(t, e, n) {
        if (!t) throw new Error("geometries is required");
        if (!Array.isArray(t)) throw new Error("geometries must be an Array");
        return j({type: "GeometryCollection", geometries: t}, e, n)
    }

    function h(t, e) {
        if (null == t || isNaN(t)) throw new Error("num is required");
        if (e && !(0 <= e)) throw new Error("precision must be a positive number");
        var n = Math.pow(10, e || 0);
        return Math.round(t * n) / n
    }

    function g(t, e) {
        if (null == t) throw new Error("radians is required");
        if (e && "string" != typeof e) throw new Error("units must be a string");
        var n = r[e || "kilometers"];
        if (!n) throw new Error(e + " units is invalid");
        return t * n
    }

    function d(t, e) {
        if (null == t) throw new Error("distance is required");
        if (e && "string" != typeof e) throw new Error("units must be a string");
        var n = r[e || "kilometers"];
        if (!n) throw new Error(e + " units is invalid");
        return t / n
    }

    function l(t, e) {
        return y(d(t, e))
    }

    function p(t) {
        if (null == t) throw new Error("bearing is required");
        var e = t % 360;
        return e < 0 && (e += 360), e
    }

    function y(t) {
        if (null == t) throw new Error("radians is required");
        return t % (2 * Math.PI) * 180 / Math.PI
    }

    function m(t) {
        if (null == t) throw new Error("degrees is required");
        return t % 360 * Math.PI / 180
    }

    function _(t, e, n) {
        if (null == t) throw new Error("length is required");
        if (!(0 <= t)) throw new Error("length must be a positive number");
        return g(d(t, e), n || "kilometers")
    }

    function E(t, e, n) {
        if (null == t) throw new Error("area is required");
        if (!(0 <= t)) throw new Error("area must be a positive number");
        var r = o[e || "meters"];
        if (!r) throw new Error("invalid original units");
        var i = o[n || "kilometers"];
        if (!i) throw new Error("invalid final units");
        return t / r * i
    }

    function V(t) {
        return !isNaN(t) && null !== t && !Array.isArray(t)
    }

    function H(t) {
        return !!t && t.constructor === Object
    }

    function w(t) {
        if (!t) throw new Error("bbox is required");
        if (!Array.isArray(t)) throw new Error("bbox must be an Array");
        if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers");
        t.forEach(function (t) {
            if (!V(t)) throw new Error("bbox must only contain numbers")
        })
    }

    function b(t) {
        if (!t) throw new Error("id is required");
        if (-1 === ["string", "number"].indexOf(typeof t)) throw new Error("id must be a number or a string")
    }

    var I = Object.freeze({
        earthRadius: f,
        factors: r,
        unitsFactors: e,
        areaFactors: o,
        feature: j,
        geometry: n,
        point: X,
        points: i,
        polygon: B,
        polygons: s,
        lineString: U,
        lineStrings: a,
        featureCollection: Y,
        multiLineString: v,
        multiPoint: u,
        multiPolygon: x,
        geometryCollection: c,
        round: h,
        radiansToLength: g,
        lengthToRadians: d,
        lengthToDegrees: l,
        bearingToAzimuth: p,
        radiansToDegrees: y,
        degreesToRadians: m,
        convertLength: _,
        convertArea: E,
        isNumber: V,
        isObject: H,
        validateBBox: w,
        validateId: b,
        radians2degrees: function () {
            throw new Error("method has been renamed to `radiansToDegrees`")
        },
        degrees2radians: function () {
            throw new Error("method has been renamed to `degreesToRadians`")
        },
        distanceToDegrees: function () {
            throw new Error("method has been renamed to `lengthToDegrees`")
        },
        distanceToRadians: function () {
            throw new Error("method has been renamed to `lengthToRadians`")
        },
        radiansToDistance: function () {
            throw new Error("method has been renamed to `radiansToLength`")
        },
        bearingToAngle: function () {
            throw new Error("method has been renamed to `bearingToAzimuth`")
        },
        convertDistance: function () {
            throw new Error("method has been renamed to `convertLength`")
        }
    });

    function N(t, e, n) {
        if (null !== t) for (var r, i, o, s, a, u, c, h, l = 0, p = 0, f = t.type, g = "FeatureCollection" === f, d = "Feature" === f, y = g ? t.features.length : 1, _ = 0; _ < y; _++) {
            a = (h = !!(c = g ? t.features[_].geometry : d ? t.geometry : t) && "GeometryCollection" === c.type) ? c.geometries.length : 1;
            for (var m = 0; m < a; m++) {
                var v = 0, x = 0;
                if (null !== (s = h ? c.geometries[m] : c)) {
                    u = s.coordinates;
                    var E = s.type;
                    switch (l = !n || "Polygon" !== E && "MultiPolygon" !== E ? 0 : 1, E) {
                        case null:
                            break;
                        case"Point":
                            e(u, p, _, v, x), p++, v++;
                            break;
                        case"LineString":
                        case"MultiPoint":
                            for (r = 0; r < u.length; r++) e(u[r], p, _, v, x), p++, "MultiPoint" === E && v++;
                            "LineString" === E && v++;
                            break;
                        case"Polygon":
                        case"MultiLineString":
                            for (r = 0; r < u.length; r++) {
                                for (i = 0; i < u[r].length - l; i++) e(u[r][i], p, _, v, x), p++;
                                "MultiLineString" === E && v++, "Polygon" === E && x++
                            }
                            "Polygon" === E && v++;
                            break;
                        case"MultiPolygon":
                            for (r = 0; r < u.length; r++) {
                                for ("MultiPolygon" === E && (x = 0), i = 0; i < u[r].length; i++) {
                                    for (o = 0; o < u[r][i].length - l; o++) e(u[r][i][o], p, _, v, x), p++;
                                    x++
                                }
                                v++
                            }
                            break;
                        case"GeometryCollection":
                            for (r = 0; r < s.geometries.length; r++) N(s.geometries[r], e, n);
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                    }
                }
            }
        }
    }

    function C(t, o, s, e) {
        var a = s;
        return N(t, function (t, e, n, r, i) {
            a = 0 === e && void 0 === s ? t : o(a, t, e, n, r, i)
        }, e), a
    }

    function S(t, e) {
        var n;
        switch (t.type) {
            case"FeatureCollection":
                for (n = 0; n < t.features.length; n++) e(t.features[n].properties, n);
                break;
            case"Feature":
                e(t.properties, 0)
        }
    }

    function M(t, n, r) {
        var i = r;
        return S(t, function (t, e) {
            i = 0 === e && void 0 === r ? t : n(i, t, e)
        }), i
    }

    function L(t, e) {
        if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length; n++) e(t.features[n], n)
    }

    function P(t, n, r) {
        var i = r;
        return L(t, function (t, e) {
            i = 0 === e && void 0 === r ? t : n(i, t, e)
        }), i
    }

    function O(t) {
        var e = [];
        return N(t, function (t) {
            e.push(t)
        }), e
    }

    function R(t, e) {
        var n, r, i, o, s, a, u, c, h, l, p = 0, f = "FeatureCollection" === t.type, g = "Feature" === t.type,
            d = f ? t.features.length : 1;
        for (n = 0; n < d; n++) {
            for (a = f ? t.features[n].geometry : g ? t.geometry : t, c = f ? t.features[n].properties : g ? t.properties : {}, h = f ? t.features[n].bbox : g ? t.bbox : void 0, l = f ? t.features[n].id : g ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++) if (null !== (o = u ? a.geometries[i] : a)) switch (o.type) {
                case"Point":
                case"LineString":
                case"MultiPoint":
                case"Polygon":
                case"MultiLineString":
                case"MultiPolygon":
                    e(o, p, c, h, l);
                    break;
                case"GeometryCollection":
                    for (r = 0; r < o.geometries.length; r++) e(o.geometries[r], p, c, h, l);
                    break;
                default:
                    throw new Error("Unknown Geometry Type")
            } else e(null, p, c, h, l);
            p++
        }
    }

    function T(t, o, s) {
        var a = s;
        return R(t, function (t, e, n, r, i) {
            a = 0 === e && void 0 === s ? t : o(a, t, e, n, r, i)
        }), a
    }

    function A(t, a) {
        R(t, function (t, n, r, e, i) {
            var o, s = null === t ? null : t.type;
            switch (s) {
                case null:
                case"Point":
                case"LineString":
                case"Polygon":
                    return void a(j(t, r, {bbox: e, id: i}), n, 0)
            }
            switch (s) {
                case"MultiPoint":
                    o = "Point";
                    break;
                case"MultiLineString":
                    o = "LineString";
                    break;
                case"MultiPolygon":
                    o = "Polygon"
            }
            t.coordinates.forEach(function (t, e) {
                a(j({type: o, coordinates: t}, r), n, e)
            })
        })
    }

    function D(t, r, i) {
        var o = i;
        return A(t, function (t, e, n) {
            o = 0 === e && 0 === n && void 0 === i ? t : r(o, t, e, n)
        }), o
    }

    function F(t, l) {
        A(t, function (a, u, c) {
            var h = 0;
            if (a.geometry) {
                var t = a.geometry.type;
                "Point" !== t && "MultiPoint" !== t && C(a, function (t, e, n, r, i, o) {
                    var s = U([t, e], a.properties);
                    return l(s, u, c, o, h), h++, e
                })
            }
        })
    }

    function q(t, o, s) {
        var a = s, u = !1;
        return F(t, function (t, e, n, r, i) {
            a = !1 === u && void 0 === s ? t : o(a, t, e, n, r, i), u = !0
        }), a
    }

    function G(t, s) {
        if (!t) throw new Error("geojson is required");
        A(t, function (t, e, n) {
            if (null !== t.geometry) {
                var r = t.geometry.type, i = t.geometry.coordinates;
                switch (r) {
                    case"LineString":
                        s(t, e, n, 0, 0);
                        break;
                    case"Polygon":
                        for (var o = 0; o < i.length; o++) s(U(i[o], t.properties), e, n, o)
                }
            }
        })
    }

    function k(t, i, o) {
        var s = o;
        return G(t, function (t, e, n, r) {
            s = 0 === e && void 0 === o ? t : i(s, t, e, n, r)
        }), s
    }

    var z = Object.freeze({
        coordEach: N,
        coordReduce: C,
        propEach: S,
        propReduce: M,
        featureEach: L,
        featureReduce: P,
        coordAll: O,
        geomEach: R,
        geomReduce: T,
        flattenEach: A,
        flattenReduce: D,
        segmentEach: F,
        segmentReduce: q,
        lineEach: G,
        lineReduce: k
    });

    function W(t) {
        var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return N(t, function (t) {
            e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1])
        }), e
    }

    function J(t) {
        if (!t) throw new Error("obj is required");
        var e = Z(t);
        if (1 < e.length && V(e[0]) && V(e[1])) return e;
        throw new Error("Coordinate is not a valid Point")
    }

    function Z(t) {
        if (!t) throw new Error("obj is required");
        var e;
        if (t.length ? e = t : t.coordinates ? e = t.coordinates : t.geometry && t.geometry.coordinates && (e = t.geometry.coordinates), e) return K(e), e;
        throw new Error("No valid coordinates")
    }

    function K(t) {
        if (1 < t.length && V(t[0]) && V(t[1])) return !0;
        if (Array.isArray(t[0]) && t[0].length) return K(t[0]);
        throw new Error("coordinates must only contain numbers")
    }

    function Q(t, e, n) {
        if (!e || !n) throw new Error("type and name required");
        if (!t || t.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
    }

    function $(t, e, n) {
        if (!t) throw new Error("No feature passed");
        if (!n) throw new Error(".featureOf() requires a name");
        if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
        if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
    }

    function tt(t, e, n) {
        if (!t) throw new Error("No featureCollection passed");
        if (!n) throw new Error(".collectionOf() requires a name");
        if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + n + ", FeatureCollection required");
        for (var r = 0; r < t.features.length; r++) {
            var i = t.features[r];
            if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
            if (!i.geometry || i.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + i.geometry.type)
        }
    }

    function et(t) {
        if (!t) throw new Error("geojson is required");
        if (void 0 !== t.geometry) return t.geometry;
        if (t.coordinates || t.geometries) return t;
        throw new Error("geojson must be a valid Feature or Geometry Object")
    }

    function nt() {
        throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType")
    }

    function rt(t, e) {
        if (!t) throw new Error((e || "geojson") + " is required");
        if (t.geometry && t.geometry.type) return t.geometry.type;
        if (t.type) return t.type;
        throw new Error((e || "geojson") + " is invalid")
    }

    var it = Object.freeze({
        getCoord: J,
        getCoords: Z,
        containsNumber: K,
        geojsonType: Q,
        featureOf: $,
        collectionOf: tt,
        getGeom: et,
        getGeomType: nt,
        getType: rt
    }), ot = {successCallback: null, verbose: !1}, st = {};

    function at(t, e, n) {
        n = n || {};
        for (var r = Object.keys(ot), i = 0; i < r.length; i++) {
            var o = r[i], s = n[o];
            s = null != s ? s : ot[o], st[o] = s
        }
        st.verbose && console.log("MarchingSquaresJS-isoContours: computing isocontour for " + e);
        var h, l, p, a = (h = function (t, e) {
            for (var n = t.length - 1, r = t[0].length - 1, i = {rows: n, cols: r, cells: []}, o = 0; o < n; ++o) {
                i.cells[o] = [];
                for (var s = 0; s < r; ++s) {
                    var a = 0, u = t[o + 1][s], c = t[o + 1][s + 1], h = t[o][s + 1], l = t[o][s];
                    if (!(isNaN(u) || isNaN(c) || isNaN(h) || isNaN(l))) {
                        a |= e <= u ? 8 : 0, a |= e <= c ? 4 : 0, a |= e <= h ? 2 : 0;
                        var p, f, g, d, y = !1;
                        if (5 == (a |= e <= l ? 1 : 0) || 10 === a) {
                            var _ = (u + c + h + l) / 4;
                            5 === a && _ < e ? (a = 10, y = !0) : 10 === a && _ < e && (a = 5, y = !0)
                        }
                        0 !== a && 15 !== a && (p = f = g = d = .5, 1 === a ? (g = 1 - ut(e, u, l), f = 1 - ut(e, h, l)) : 2 === a ? (f = ut(e, l, h), d = 1 - ut(e, c, h)) : 3 === a ? (g = 1 - ut(e, u, l), d = 1 - ut(e, c, h)) : 4 === a ? (p = ut(e, u, c), d = ut(e, h, c)) : 5 === a ? (p = ut(e, u, c), d = ut(e, h, c), f = 1 - ut(e, h, l), g = 1 - ut(e, u, l)) : 6 === a ? (f = ut(e, l, h), p = ut(e, u, c)) : 7 === a ? (g = 1 - ut(e, u, l), p = ut(e, u, c)) : 8 === a ? (g = ut(e, l, u), p = 1 - ut(e, c, u)) : 9 === a ? (f = 1 - ut(e, h, l), p = 1 - ut(e, c, u)) : 10 === a ? (p = 1 - ut(e, c, u), d = 1 - ut(e, c, h), f = ut(e, l, h), g = ut(e, l, u)) : 11 === a ? (p = 1 - ut(e, c, u), d = 1 - ut(e, c, h)) : 12 === a ? (g = ut(e, l, u), d = ut(e, h, c)) : 13 === a ? (f = 1 - ut(e, h, l), d = ut(e, h, c)) : 14 === a ? (g = ut(e, l, u), f = ut(e, l, h)) : console.log("MarchingSquaresJS-isoContours: Illegal cval detected: " + a), i.cells[o][s] = {
                            cval: a,
                            flipped: y,
                            top: p,
                            right: d,
                            bottom: f,
                            left: g
                        })
                    }
                }
            }
            return i
        }(t, e), l = [], p = 0, h.rows, h.cols, h.cells.forEach(function (t, c) {
            t.forEach(function (t, e) {
                if (void 0 !== t && 5 !== (u = t).cval && 10 !== u.cval && !ct(t)) {
                    var n = function (t, e, n) {
                        var r, i, o, s = t.length, a = [], u = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0],
                            c = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0],
                            h = ["none", "bottom", "right", "right", "top", "top", "top", "top", "left", "bottom", "right", "right", "left", "bottom", "left", "none"],
                            l = (t[e][n], t[e][n]), p = l.cval,
                            f = lt(l, o = ["none", "left", "bottom", "left", "right", "none", "bottom", "left", "top", "top", "none", "top", "right", "right", "bottom", "none"][p]);
                        a.push([n + f[0], e + f[1]]), f = lt(l, o = h[p]), a.push([n + f[0], e + f[1]]), ht(l);
                        for (var g = n + u[p], d = e + c[p], y = p; 0 <= g && 0 <= d && d < s && (g != n || d != e) && void 0 !== (l = t[d][g]);) {
                            if (0 === (p = l.cval) || 15 === p) return {path: a, info: "mergeable"};
                            o = h[p], r = u[p], i = c[p], 5 !== p && 10 !== p || (5 === p ? l.flipped ? (r = -1 === c[y] ? (o = "left", -1) : (o = "right", 1), i = 0) : -1 === u[y] && (o = "bottom", r = 0, i = -1) : 10 === p && (l.flipped ? i = -1 === u[y] ? (o = "top", r = 0, 1) : (o = "bottom", r = 0, -1) : 1 === c[y] && (o = "left", r = -1, i = 0))), f = lt(l, o), a.push([g + f[0], d + f[1]]), ht(l), g += r, d += i, y = p
                        }
                        return {path: a, info: "closed"}
                    }(h.cells, c, e), r = !1;
                    if ("mergeable" === n.info) for (var i = n.path[n.path.length - 1][0], o = n.path[n.path.length - 1][1], s = p - 1; 0 <= s; s--) if (Math.abs(l[s][0][0] - i) <= 1e-7 && Math.abs(l[s][0][1] - o) <= 1e-7) {
                        for (var a = n.path.length - 2; 0 <= a; --a) l[s].unshift(n.path[a]);
                        r = !0;
                        break
                    }
                    r || (l[p++] = n.path)
                }
                var u
            })
        }), l);
        return "function" == typeof st.successCallback && st.successCallback(a), a
    }

    function ut(t, e, n) {
        return (t - e) / (n - e)
    }

    function ct(t) {
        return 0 === t.cval || 15 === t.cval
    }

    function ht(t) {
        ct(t) || 5 === t.cval || 10 === t.cval || (t.cval = 15)
    }

    function lt(t, e) {
        return "top" === e ? [t.top, 1] : "bottom" === e ? [t.bottom, 0] : "right" === e ? [1, t.right] : "left" === e ? [0, t.left] : void 0
    }

    var pt = function t(e, n, r, i, o) {
        for (r = r || 0, i = i || e.length - 1, o = o || gt; r < i;) {
            if (600 < i - r) {
                var s = i - r + 1, a = n - r + 1, u = Math.log(s), c = .5 * Math.exp(2 * u / 3),
                    h = .5 * Math.sqrt(u * c * (s - c) / s) * (a - s / 2 < 0 ? -1 : 1);
                t(e, n, Math.max(r, Math.floor(n - a * c / s + h)), Math.min(i, Math.floor(n + (s - a) * c / s + h)), o)
            }
            var l = e[n], p = r, f = i;
            for (ft(e, r, n), 0 < o(e[i], l) && ft(e, r, i); p < f;) {
                for (ft(e, p, f), p++, f--; o(e[p], l) < 0;) p++;
                for (; 0 < o(e[f], l);) f--
            }
            0 === o(e[r], l) ? ft(e, r, f) : ft(e, ++f, i), f <= n && (r = f + 1), n <= f && (i = f - 1)
        }
    };

    function ft(t, e, n) {
        var r = t[e];
        t[e] = t[n], t[n] = r
    }

    function gt(t, e) {
        return t < e ? -1 : e < t ? 1 : 0
    }

    var dt = yt;

    function yt(t, e) {
        if (!(this instanceof yt)) return new yt(t, e);
        this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), e && this._initFormat(e), this.clear()
    }

    function _t(t, e, n) {
        if (!n) return e.indexOf(t);
        for (var r = 0; r < e.length; r++) if (n(t, e[r])) return r;
        return -1
    }

    function mt(t, e) {
        vt(t, 0, t.children.length, e, t)
    }

    function vt(t, e, n, r, i) {
        i || (i = St(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
        for (var o, s = e; s < n; s++) o = t.children[s], xt(i, t.leaf ? r(o) : o);
        return i
    }

    function xt(t, e) {
        return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
    }

    function Et(t, e) {
        return t.minX - e.minX
    }

    function wt(t, e) {
        return t.minY - e.minY
    }

    function bt(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY)
    }

    function It(t) {
        return t.maxX - t.minX + (t.maxY - t.minY)
    }

    function Nt(t, e) {
        return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
    }

    function Ct(t, e) {
        return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
    }

    function St(t) {
        return {children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0}
    }

    function Mt(t, e, n, r, i) {
        for (var o, s = [e, n]; s.length;) (n = s.pop()) - (e = s.pop()) <= r || (o = e + Math.ceil((n - e) / r / 2) * r, pt(t, o, e, n, i), s.push(e, o, o, n))
    }

    function Lt(t, e) {
        return t(e = {exports: {}}, e.exports), e.exports
    }

    yt.prototype = {
        all: function () {
            return this._all(this.data, [])
        }, search: function (t) {
            var e = this.data, n = [], r = this.toBBox;
            if (!Ct(t, e)) return n;
            for (var i, o, s, a, u = []; e;) {
                for (i = 0, o = e.children.length; i < o; i++) s = e.children[i], Ct(t, a = e.leaf ? r(s) : s) && (e.leaf ? n.push(s) : Nt(t, a) ? this._all(s, n) : u.push(s));
                e = u.pop()
            }
            return n
        }, collides: function (t) {
            var e = this.data, n = this.toBBox;
            if (!Ct(t, e)) return !1;
            for (var r, i, o, s, a = []; e;) {
                for (r = 0, i = e.children.length; r < i; r++) if (o = e.children[r], Ct(t, s = e.leaf ? n(o) : o)) {
                    if (e.leaf || Nt(t, s)) return !0;
                    a.push(o)
                }
                e = a.pop()
            }
            return !1
        }, load: function (t) {
            if (!t || !t.length) return this;
            if (t.length < this._minEntries) {
                for (var e = 0, n = t.length; e < n; e++) this.insert(t[e]);
                return this
            }
            var r = this._build(t.slice(), 0, t.length - 1, 0);
            if (this.data.children.length) if (this.data.height === r.height) this._splitRoot(this.data, r); else {
                if (this.data.height < r.height) {
                    var i = this.data;
                    this.data = r, r = i
                }
                this._insert(r, this.data.height - r.height - 1, !0)
            } else this.data = r;
            return this
        }, insert: function (t) {
            return t && this._insert(t, this.data.height - 1), this
        }, clear: function () {
            return this.data = St([]), this
        }, remove: function (t, e) {
            if (!t) return this;
            for (var n, r, i, o, s = this.data, a = this.toBBox(t), u = [], c = []; s || u.length;) {
                if (s || (s = u.pop(), r = u[u.length - 1], n = c.pop(), o = !0), s.leaf && -1 !== (i = _t(t, s.children, e))) return s.children.splice(i, 1), u.push(s), this._condense(u), this;
                o || s.leaf || !Nt(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), c.push(n), n = 0, s = (r = s).children[0])
            }
            return this
        }, toBBox: function (t) {
            return t
        }, compareMinX: Et, compareMinY: wt, toJSON: function () {
            return this.data
        }, fromJSON: function (t) {
            return this.data = t, this
        }, _all: function (t, e) {
            for (var n = []; t;) t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop();
            return e
        }, _build: function (t, e, n, r) {
            var i, o = n - e + 1, s = this._maxEntries;
            if (o <= s) return mt(i = St(t.slice(e, n + 1)), this.toBBox), i;
            r || (r = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, r - 1))), (i = St([])).leaf = !1, i.height = r;
            var a, u, c, h, l = Math.ceil(o / s), p = l * Math.ceil(Math.sqrt(s));
            for (Mt(t, e, n, p, this.compareMinX), a = e; a <= n; a += p) for (Mt(t, a, c = Math.min(a + p - 1, n), l, this.compareMinY), u = a; u <= c; u += l) h = Math.min(u + l - 1, c), i.children.push(this._build(t, u, h, r - 1));
            return mt(i, this.toBBox), i
        }, _chooseSubtree: function (t, e, n, r) {
            for (var i, o, s, a, u, c, h, l, p, f; r.push(e), !e.leaf && r.length - 1 !== n;) {
                for (h = l = 1 / 0, i = 0, o = e.children.length; i < o; i++) u = bt(s = e.children[i]), p = t, f = s, (c = (Math.max(f.maxX, p.maxX) - Math.min(f.minX, p.minX)) * (Math.max(f.maxY, p.maxY) - Math.min(f.minY, p.minY)) - u) < l ? (l = c, h = u < h ? u : h, a = s) : c === l && u < h && (h = u, a = s);
                e = a || e.children[0]
            }
            return e
        }, _insert: function (t, e, n) {
            var r = this.toBBox, i = n ? t : r(t), o = [], s = this._chooseSubtree(i, this.data, e, o);
            for (s.children.push(t), xt(s, i); 0 <= e && o[e].children.length > this._maxEntries;) this._split(o, e), e--;
            this._adjustParentBBoxes(i, o, e)
        }, _split: function (t, e) {
            var n = t[e], r = n.children.length, i = this._minEntries;
            this._chooseSplitAxis(n, i, r);
            var o = this._chooseSplitIndex(n, i, r), s = St(n.children.splice(o, n.children.length - o));
            s.height = n.height, s.leaf = n.leaf, mt(n, this.toBBox), mt(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(n, s)
        }, _splitRoot: function (t, e) {
            this.data = St([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, mt(this.data, this.toBBox)
        }, _chooseSplitIndex: function (t, e, n) {
            var r, i, o, s, a, u, c, h, l, p, f, g, d, y;
            for (u = c = 1 / 0, r = e; r <= n - e; r++) l = i = vt(t, 0, r, this.toBBox), p = o = vt(t, r, n, this.toBBox), f = Math.max(l.minX, p.minX), g = Math.max(l.minY, p.minY), d = Math.min(l.maxX, p.maxX), y = Math.min(l.maxY, p.maxY), s = Math.max(0, d - f) * Math.max(0, y - g), a = bt(i) + bt(o), s < u ? (u = s, h = r, c = a < c ? a : c) : s === u && a < c && (c = a, h = r);
            return h
        }, _chooseSplitAxis: function (t, e, n) {
            var r = t.leaf ? this.compareMinX : Et, i = t.leaf ? this.compareMinY : wt;
            this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r)
        }, _allDistMargin: function (t, e, n, r) {
            t.children.sort(r);
            var i, o, s = this.toBBox, a = vt(t, 0, e, s), u = vt(t, n - e, n, s), c = It(a) + It(u);
            for (i = e; i < n - e; i++) o = t.children[i], xt(a, t.leaf ? s(o) : o), c += It(a);
            for (i = n - e - 1; e <= i; i--) o = t.children[i], xt(u, t.leaf ? s(o) : o), c += It(u);
            return c
        }, _adjustParentBBoxes: function (t, e, n) {
            for (var r = n; 0 <= r; r--) xt(e[r], t)
        }, _condense: function (t) {
            for (var e, n = t.length - 1; 0 <= n; n--) 0 === t[n].children.length ? 0 < n ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : mt(t[n], this.toBBox)
        }, _initFormat: function (t) {
            var e = ["return a", " - b", ";"];
            this.compareMinX = new Function("a", "b", e.join(t[0])), this.compareMinY = new Function("a", "b", e.join(t[1])), this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};")
        }
    };
    var Pt = function (t, e, n) {
        var r = t * e, i = Ot * t, o = i - (i - t), s = t - o, a = Ot * e, u = a - (a - e), c = e - u,
            h = s * c - (r - o * u - s * u - o * c);
        return n ? (n[0] = h, n[1] = r, n) : [h, r]
    }, Ot = +(Math.pow(2, 27) + 1), Rt = function (t, e) {
        var n, r, i, o, s, a = 0 | t.length, u = 0 | e.length;
        if (1 === a && 1 === u) return n = t[0], r = e[0], (s = n - ((i = n + r) - (o = i - n)) + (r - o)) ? [s, i] : [i];
        var c, h, l = new Array(a + u), p = 0, f = 0, g = 0, d = Math.abs, y = t[f], _ = d(y), m = e[g], v = d(m);
        _ < v ? (h = y, (f += 1) < a && (_ = d(y = t[f]))) : (h = m, (g += 1) < u && (v = d(m = e[g]))), f < a && _ < v || u <= g ? (c = y, (f += 1) < a && (_ = d(y = t[f]))) : (c = m, (g += 1) < u && (v = d(m = e[g])));
        for (var x, E, w = c + h, b = w - c, I = h - b, N = I, C = w; f < a && g < u;) _ < v ? (c = y, (f += 1) < a && (_ = d(y = t[f]))) : (c = m, (g += 1) < u && (v = d(m = e[g]))), (I = (h = N) - (b = (w = c + h) - c)) && (l[p++] = I), N = C - ((x = C + w) - (E = x - C)) + (w - E), C = x;
        for (; f < a;) (I = (h = N) - (b = (w = (c = y) + h) - c)) && (l[p++] = I), N = C - ((x = C + w) - (E = x - C)) + (w - E), C = x, (f += 1) < a && (y = t[f]);
        for (; g < u;) (I = (h = N) - (b = (w = (c = m) + h) - c)) && (l[p++] = I), N = C - ((x = C + w) - (E = x - C)) + (w - E), C = x, (g += 1) < u && (m = e[g]);
        return N && (l[p++] = N), C && (l[p++] = C), p || (l[p++] = 0), l.length = p, l
    }, Tt = function (t, e) {
        var n = t.length;
        if (1 === n) {
            var r = Pt(t[0], e);
            return r[0] ? r : [r[1]]
        }
        var i, o, s, a, u, c, h, l = new Array(2 * n), p = [.1, .1], f = [.1, .1], g = 0;
        Pt(t[0], e, p), p[0] && (l[g++] = p[0]);
        for (var d = 1; d < n; ++d) {
            Pt(t[d], e, f);
            var y = p[1];
            void 0, c = (o = f[0]) - (u = (a = (i = y) + o) - i), h = i - (a - u), (s = p) && (s[0] = h + c, s[1] = a), p[0] && (l[g++] = p[0]);
            var _ = f[1], m = p[1], v = _ + m, x = m - (v - _);
            p[1] = v, x && (l[g++] = x)
        }
        return p[1] && (l[g++] = p[1]), 0 === g && (l[g++] = 0), l.length = g, l
    }, At = function (t, e) {
        var n, r, i, o, s, a = 0 | t.length, u = 0 | e.length;
        if (1 === a && 1 === u) return n = t[0], r = -e[0], (s = n - ((i = n + r) - (o = i - n)) + (r - o)) ? [s, i] : [i];
        var c, h, l = new Array(a + u), p = 0, f = 0, g = 0, d = Math.abs, y = t[f], _ = d(y), m = -e[g], v = d(m);
        _ < v ? (h = y, (f += 1) < a && (_ = d(y = t[f]))) : (h = m, (g += 1) < u && (v = d(m = -e[g]))), f < a && _ < v || u <= g ? (c = y, (f += 1) < a && (_ = d(y = t[f]))) : (c = m, (g += 1) < u && (v = d(m = -e[g])));
        for (var x, E, w = c + h, b = w - c, I = h - b, N = I, C = w; f < a && g < u;) _ < v ? (c = y, (f += 1) < a && (_ = d(y = t[f]))) : (c = m, (g += 1) < u && (v = d(m = -e[g]))), (I = (h = N) - (b = (w = c + h) - c)) && (l[p++] = I), N = C - ((x = C + w) - (E = x - C)) + (w - E), C = x;
        for (; f < a;) (I = (h = N) - (b = (w = (c = y) + h) - c)) && (l[p++] = I), N = C - ((x = C + w) - (E = x - C)) + (w - E), C = x, (f += 1) < a && (y = t[f]);
        for (; g < u;) (I = (h = N) - (b = (w = (c = m) + h) - c)) && (l[p++] = I), N = C - ((x = C + w) - (E = x - C)) + (w - E), C = x, (g += 1) < u && (m = -e[g]);
        return N && (l[p++] = N), C && (l[p++] = C), p || (l[p++] = 0), l.length = p, l
    }, Dt = Lt(function (o) {
        function h(t, e) {
            for (var n = new Array(t.length - 1), r = 1; r < t.length; ++r) for (var i = n[r - 1] = new Array(t.length - 1), o = 0, s = 0; o < t.length; ++o) o !== e && (i[s++] = t[r][o]);
            return n
        }

        function l(t) {
            if (1 === t.length) return t[0];
            if (2 === t.length) return ["sum(", t[0], ",", t[1], ")"].join("");
            var e = t.length >> 1;
            return ["sum(", l(t.slice(0, e)), ",", l(t.slice(e)), ")"].join("")
        }

        function p(t) {
            if (2 === t.length) return [["sum(prod(", t[0][0], ",", t[1][1], "),prod(-", t[0][1], ",", t[1][0], "))"].join("")];
            for (var e = [], n = 0; n < t.length; ++n) e.push(["scale(", l(p(h(t, n))), ",", (r = n, 1 & r ? "-" : ""), t[0][n], ")"].join(""));
            return e;
            var r
        }

        function s(t) {
            for (var e = [], n = [], r = function (t) {
                for (var e = new Array(t), n = 0; n < t; ++n) {
                    e[n] = new Array(t);
                    for (var r = 0; r < t; ++r) e[n][r] = ["m", r, "[", t - n - 1, "]"].join("")
                }
                return e
            }(t), i = [], o = 0; o < t; ++o) 0 == (1 & o) ? e.push.apply(e, p(h(r, o))) : n.push.apply(n, p(h(r, o))), i.push("m" + o);
            var s = l(e), a = l(n), u = "orientation" + t + "Exact",
                c = ["function ", u, "(", i.join(), "){var p=", s, ",n=", a, ",d=sub(p,n);return d[d.length-1];};return ", u].join("");
            return new Function("sum", "prod", "scale", "sub", c)(Rt, Pt, Tt, At)
        }

        var u = s(3), E = s(4), a = [function () {
            return 0
        }, function () {
            return 0
        }, function (t, e) {
            return e[0] - t[0]
        }, function (t, e, n) {
            var r, i = (t[1] - n[1]) * (e[0] - n[0]), o = (t[0] - n[0]) * (e[1] - n[1]), s = i - o;
            if (0 < i) {
                if (o <= 0) return s;
                r = i + o
            } else {
                if (!(i < 0)) return s;
                if (0 <= o) return s;
                r = -(i + o)
            }
            var a = 33306690738754716e-32 * r;
            return a <= s || s <= -a ? s : u(t, e, n)
        }, function (t, e, n, r) {
            var i = t[0] - r[0], o = e[0] - r[0], s = n[0] - r[0], a = t[1] - r[1], u = e[1] - r[1], c = n[1] - r[1],
                h = t[2] - r[2], l = e[2] - r[2], p = n[2] - r[2], f = o * c, g = s * u, d = s * a, y = i * c,
                _ = i * u, m = o * a, v = h * (f - g) + l * (d - y) + p * (_ - m),
                x = 7771561172376103e-31 * ((Math.abs(f) + Math.abs(g)) * Math.abs(h) + (Math.abs(d) + Math.abs(y)) * Math.abs(l) + (Math.abs(_) + Math.abs(m)) * Math.abs(p));
            return x < v || x < -v ? v : E(t, e, n, r)
        }];
        !function () {
            for (; a.length <= 5;) a.push(s(a.length));
            for (var t = [], e = ["slow"], n = 0; n <= 5; ++n) t.push("a" + n), e.push("o" + n);
            var r = ["function getOrientation(", t.join(), "){switch(arguments.length){case 0:case 1:return 0;"];
            for (n = 2; n <= 5; ++n) r.push("case ", n, ":return o", n, "(", t.slice(0, n).join(), ");");
            r.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation"), e.push(r.join(""));
            var i = Function.apply(void 0, e);
            for (o.exports = i.apply(void 0, [function (t) {
                var e = a[t.length];
                return e || (e = a[t.length] = s(t.length)), e.apply(void 0, t)
            }].concat(a)), n = 0; n <= 5; ++n) o.exports[n] = a[n]
        }()
    }), Ft = Dt[3], qt = Bt, Gt = Bt;

    function Bt(t, e) {
        if (!(this instanceof Bt)) return new Bt(t, e);
        if (this.data = t || [], this.length = this.data.length, this.compare = e || kt, 0 < this.length) for (var n = (this.length >> 1) - 1; 0 <= n; n--) this._down(n)
    }

    function kt(t, e) {
        return t < e ? -1 : e < t ? 1 : 0
    }

    Bt.prototype = {
        push: function (t) {
            this.data.push(t), this.length++, this._up(this.length - 1)
        }, pop: function () {
            if (0 !== this.length) {
                var t = this.data[0];
                return this.length--, 0 < this.length && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t
            }
        }, peek: function () {
            return this.data[0]
        }, _up: function (t) {
            for (var e = this.data, n = this.compare, r = e[t]; 0 < t;) {
                var i = t - 1 >> 1, o = e[i];
                if (0 <= n(r, o)) break;
                e[t] = o, t = i
            }
            e[t] = r
        }, _down: function (t) {
            for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) {
                var o = 1 + (t << 1), s = o + 1, a = e[o];
                if (s < this.length && n(e[s], a) < 0 && (a = e[o = s]), 0 <= n(a, i)) break;
                e[t] = a, t = o
            }
            e[t] = i
        }
    }, qt.default = Gt;
    var zt = function (t, e) {
        for (var n = t[0], r = t[1], i = !1, o = 0, s = e.length - 1; o < e.length; s = o++) {
            var a = e[o][0], u = e[o][1], c = e[s][0], h = e[s][1];
            r < u != r < h && n < (c - a) * (r - u) / (h - u) + a && (i = !i)
        }
        return i
    }, jt = Dt[3], Xt = Yt, Ut = Yt;

    function Yt(t, e, n) {
        e = Math.max(0, void 0 === e ? 2 : e), n = n || 0;
        for (var r, i = function (t) {
            for (var e = t[0], n = t[0], r = t[0], i = t[0], o = 0; o < t.length; o++) {
                var s = t[o];
                s[0] < e[0] && (e = s), s[0] > r[0] && (r = s), s[1] < n[1] && (n = s), s[1] > i[1] && (i = s)
            }
            var a = [e, n, r, i], u = a.slice();
            for (o = 0; o < t.length; o++) zt(t[o], a) || u.push(t[o]);
            var c = function (n) {
                var t = n.length;
                if (t < 3) {
                    for (var e = new Array(t), r = 0; r < t; ++r) e[r] = r;
                    return 2 === t && n[0][0] === n[1][0] && n[0][1] === n[1][1] ? [0] : e
                }
                var i = new Array(t);
                for (r = 0; r < t; ++r) i[r] = r;
                i.sort(function (t, e) {
                    return n[t][0] - n[e][0] || n[t][1] - n[e][1]
                });
                var o = [i[0], i[1]], s = [i[0], i[1]];
                for (r = 2; r < t; ++r) {
                    for (var a = i[r], u = n[a], c = o.length; 1 < c && Ft(n[o[c - 2]], n[o[c - 1]], u) <= 0;) c -= 1, o.pop();
                    for (o.push(a), c = s.length; 1 < c && 0 <= Ft(n[s[c - 2]], n[s[c - 1]], u);) c -= 1, s.pop();
                    s.push(a)
                }
                e = new Array(s.length + o.length - 2);
                for (var h = 0, l = (r = 0, o.length); r < l; ++r) e[h++] = o[r];
                for (var p = s.length - 2; 0 < p; --p) e[h++] = s[p];
                return e
            }(u), h = [];
            for (o = 0; o < c.length; o++) h.push(u[c[o]]);
            return h
        }(t), o = dt(16, ["[0]", "[1]", "[0]", "[1]"]).load(t), s = [], a = 0; a < i.length; a++) {
            var u = i[a];
            o.remove(u), r = Qt(u, r), s.push(r)
        }
        var c = dt(16);
        for (a = 0; a < s.length; a++) c.insert(Kt(s[a]));
        for (var h = e * e, l = n * n; s.length;) {
            var p = s.shift(), f = p.p, g = p.next.p, d = $t(f, g);
            if (!(d < l)) {
                var y = d / h;
                (u = Vt(o, p.prev.p, f, g, p.next.next.p, y, c)) && Math.min($t(u, f), $t(u, g)) <= y && (s.push(p), s.push(Qt(u, p)), o.remove(u), c.remove(p), c.insert(Kt(p)), c.insert(Kt(p.next)))
            }
        }
        p = r;
        for (var _ = []; _.push(p.p), (p = p.next) !== r;) ;
        return _.push(p.p), _
    }

    function Vt(t, e, n, r, i, o, s) {
        for (var a = new qt(null, Ht), u = t.data; u;) {
            for (var c = 0; c < u.children.length; c++) {
                var h = u.children[c], l = u.leaf ? te(h, n, r) : Wt(n, r, h);
                o < l || a.push({node: h, dist: l})
            }
            for (; a.length && !a.peek().node.children;) {
                var p = a.pop(), f = p.node, g = te(f, e, n), d = te(f, r, i);
                if (p.dist < g && p.dist < d && Zt(n, f, s) && Zt(r, f, s)) return f
            }
            (u = a.pop()) && (u = u.node)
        }
        return null
    }

    function Ht(t, e) {
        return t.dist - e.dist
    }

    function Wt(t, e, n) {
        if (Jt(t, n) || Jt(e, n)) return 0;
        var r = ee(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY);
        if (0 === r) return 0;
        var i = ee(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY);
        if (0 === i) return 0;
        var o = ee(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY);
        if (0 === o) return 0;
        var s = ee(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY);
        return 0 === s ? 0 : Math.min(r, i, o, s)
    }

    function Jt(t, e) {
        return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY
    }

    function Zt(t, e, n) {
        for (var r, i, o, s, a = Math.min(t[0], e[0]), u = Math.min(t[1], e[1]), c = Math.max(t[0], e[0]), h = Math.max(t[1], e[1]), l = n.search({
            minX: a,
            minY: u,
            maxX: c,
            maxY: h
        }), p = 0; p < l.length; p++) if (r = l[p].p, i = l[p].next.p, o = t, r !== (s = e) && i !== o && 0 < jt(r, i, o) != 0 < jt(r, i, s) && 0 < jt(o, s, r) != 0 < jt(o, s, i)) return !1;
        return !0
    }

    function Kt(t) {
        var e = t.p, n = t.next.p;
        return t.minX = Math.min(e[0], n[0]), t.minY = Math.min(e[1], n[1]), t.maxX = Math.max(e[0], n[0]), t.maxY = Math.max(e[1], n[1]), t
    }

    function Qt(t, e) {
        var n = {p: t, prev: null, next: null, minX: 0, minY: 0, maxX: 0, maxY: 0};
        return e ? (n.next = e.next, (n.prev = e).next.prev = n, e.next = n) : (n.prev = n).next = n, n
    }

    function $t(t, e) {
        var n = t[0] - e[0], r = t[1] - e[1];
        return n * n + r * r
    }

    function te(t, e, n) {
        var r = e[0], i = e[1], o = n[0] - r, s = n[1] - i;
        if (0 !== o || 0 !== s) {
            var a = ((t[0] - r) * o + (t[1] - i) * s) / (o * o + s * s);
            1 < a ? (r = n[0], i = n[1]) : 0 < a && (r += o * a, i += s * a)
        }
        return (o = t[0] - r) * o + (s = t[1] - i) * s
    }

    function ee(t, e, n, r, i, o, s, a) {
        var u, c, h, l, p = n - t, f = r - e, g = s - i, d = a - o, y = t - i, _ = e - o, m = p * p + f * f,
            v = p * g + f * d, x = g * g + d * d, E = p * y + f * _, w = g * y + d * _, b = m * x - v * v, I = b, N = b;
        0 === b ? (c = 0, I = 1, l = w, N = x) : (l = m * w - v * E, (c = v * w - x * E) < 0 ? (c = 0, l = w, N = x) : I < c && (c = I, l = w + v, N = x)), l < 0 ? -E < (l = 0) ? c = 0 : m < -E ? c = I : (c = -E, I = m) : N < l && (l = N, -E + v < 0 ? c = 0 : m < -E + v ? c = I : (c = -E + v, I = m));
        var C = (1 - (h = 0 === l ? 0 : l / N)) * i + h * s - ((1 - (u = 0 === c ? 0 : c / I)) * t + u * n),
            S = (1 - h) * o + h * a - ((1 - u) * e + u * r);
        return C * C + S * S
    }

    function ne(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.concavity || 1 / 0, r = [];
        if (N(t, function (t) {
            r.push([t[0], t[1]])
        }), !r.length) return null;
        var i = Xt(r, n);
        return 3 < i.length ? B([i]) : null
    }

    function re(t, e, n) {
        if ("object" != typeof(n = n || {})) throw new Error("options is invalid");
        var r = n.ignoreBoundary;
        if (!t) throw new Error("point is required");
        if (!e) throw new Error("polygon is required");
        var i, o, s = J(t), a = Z(e), u = e.geometry ? e.geometry.type : e.type, c = e.bbox;
        if (c && 0 == (i = s, (o = c)[0] <= i[0] && o[1] <= i[1] && o[2] >= i[0] && o[3] >= i[1])) return !1;
        "Polygon" === u && (a = [a]);
        for (var h = 0, l = !1; h < a.length && !l; h++) if (ie(s, a[h][0], r)) {
            for (var p = !1, f = 1; f < a[h].length && !p;) ie(s, a[h][f], !r) && (p = !0), f++;
            p || (l = !0)
        }
        return l
    }

    function ie(t, e, n) {
        var r = !1;
        e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));
        for (var i = 0, o = e.length - 1; i < e.length; o = i++) {
            var s = e[i][0], a = e[i][1], u = e[o][0], c = e[o][1];
            if (t[1] * (s - u) + a * (u - t[0]) + c * (t[0] - s) == 0 && (s - t[0]) * (u - t[0]) <= 0 && (a - t[1]) * (c - t[1]) <= 0) return !n;
            a > t[1] != c > t[1] && t[0] < (u - s) * (t[1] - a) / (c - a) + s && (r = !r)
        }
        return r
    }

    function oe(t, e) {
        var n = [];
        return R(e, function (e) {
            L(t, function (t) {
                re(t, e) && n.push(t)
            })
        }), Y(n)
    }

    function se(t, n) {
        if ("FeatureCollection" !== t.type) throw new Error("points must be a FeatureCollection");
        var o = !1;
        return Y(function (t) {
            if (t.length < 3) return [];
            t.sort(ue);
            for (var e, n, r, i, o, s, a = t.length - 1, u = t[a].x, c = t[0].x, h = t[a].y, l = h; a--;) t[a].y < h && (h = t[a].y), t[a].y > l && (l = t[a].y);
            var p, f = c - u, g = l - h, d = g < f ? f : g, y = .5 * (c + u), _ = .5 * (l + h),
                m = [new ae({x: y - 20 * d, y: _ - d, __sentinel: !0}, {
                    x: y,
                    y: _ + 20 * d,
                    __sentinel: !0
                }, {x: y + 20 * d, y: _ - d, __sentinel: !0})], v = [], x = [];
            for (a = t.length; a--;) {
                for (x.length = 0, p = m.length; p--;) 0 < (f = t[a].x - m[p].x) && f * f > m[p].r ? (v.push(m[p]), m.splice(p, 1)) : f * f + (g = t[a].y - m[p].y) * g > m[p].r || (x.push(m[p].a, m[p].b, m[p].b, m[p].c, m[p].c, m[p].a), m.splice(p, 1));
                for (ce(x), p = x.length; p;) n = x[--p], e = x[--p], r = t[a], i = n.x - e.x, o = n.y - e.y, s = 2 * (i * (r.y - n.y) - o * (r.x - n.x)), 1e-12 < Math.abs(s) && m.push(new ae(e, n, r))
            }
            for (Array.prototype.push.apply(v, m), a = v.length; a--;) (v[a].a.__sentinel || v[a].b.__sentinel || v[a].c.__sentinel) && v.splice(a, 1);
            return v
        }(t.features.map(function (t) {
            var e = {x: t.geometry.coordinates[0], y: t.geometry.coordinates[1]};
            return n ? e.z = t.properties[n] : 3 === t.geometry.coordinates.length && (o = !0, e.z = t.geometry.coordinates[2]), e
        })).map(function (t) {
            var e = [t.a.x, t.a.y], n = [t.b.x, t.b.y], r = [t.c.x, t.c.y], i = {};
            return o ? (e.push(t.a.z), n.push(t.b.z), r.push(t.c.z)) : i = {
                a: t.a.z,
                b: t.b.z,
                c: t.c.z
            }, B([[e, n, r, e]], i)
        }))
    }

    function ae(t, e, n) {
        this.a = t, this.b = e, this.c = n;
        var r, i, o = e.x - t.x, s = e.y - t.y, a = n.x - t.x, u = n.y - t.y, c = o * (t.x + e.x) + s * (t.y + e.y),
            h = a * (t.x + n.x) + u * (t.y + n.y), l = 2 * (o * (n.y - e.y) - s * (n.x - e.x));
        this.x = (u * c - s * h) / l, this.y = (o * h - a * c) / l, r = this.x - t.x, i = this.y - t.y, this.r = r * r + i * i
    }

    function ue(t, e) {
        return e.x - t.x
    }

    function ce(t) {
        var e, n, r, i, o, s = t.length;
        t:for (; s;) for (n = t[--s], e = t[--s], r = s; r;) if (o = t[--r], e === (i = t[--r]) && n === o || e === o && n === i) {
            t.splice(s, 2), t.splice(r, 2), s -= 2;
            continue t
        }
    }

    function he(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.units, i = J(t), o = J(e), s = m(o[1] - i[1]), a = m(o[0] - i[0]), u = m(i[1]), c = m(o[1]),
            h = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(a / 2), 2) * Math.cos(u) * Math.cos(c);
        return g(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), r)
    }

    function le(t) {
        if (!t) throw new Error("geojson is required");
        switch (t.type) {
            case"Feature":
                return pe(t);
            case"FeatureCollection":
                return e = t, n = {type: "FeatureCollection"}, Object.keys(e).forEach(function (t) {
                    switch (t) {
                        case"type":
                        case"features":
                            return;
                        default:
                            n[t] = e[t]
                    }
                }), n.features = e.features.map(function (t) {
                    return pe(t)
                }), n;
            case"Point":
            case"LineString":
            case"Polygon":
            case"MultiPoint":
            case"MultiLineString":
            case"MultiPolygon":
            case"GeometryCollection":
                return fe(t);
            default:
                throw new Error("unknown GeoJSON type")
        }
        var e, n
    }

    function pe(e) {
        var n = {type: "Feature"};
        return Object.keys(e).forEach(function (t) {
            switch (t) {
                case"type":
                case"properties":
                case"geometry":
                    return;
                default:
                    n[t] = e[t]
            }
        }), n.properties = function n(r) {
            var i = {};
            return r && Object.keys(r).forEach(function (t) {
                var e = r[t];
                "object" == typeof e ? null === e ? i[t] = null : e.length ? i[t] = e.map(function (t) {
                    return t
                }) : i[t] = n(e) : i[t] = e
            }), i
        }(e.properties), n.geometry = fe(e.geometry), n
    }

    function fe(t) {
        var e = {type: t.type};
        return t.bbox && (e.bbox = t.bbox), "GeometryCollection" === t.type ? e.geometries = t.geometries.map(function (t) {
            return fe(t)
        }) : e.coordinates = function e(t) {
            return "object" != typeof t[0] ? t.slice() : t.map(function (t) {
                return e(t)
            })
        }(t.coordinates), e
    }

    Xt.default = Ut;
    var ge = function (t) {
        return t
    }, de = function (t) {
        if (null == t) return ge;
        var o, s, a = t.scale[0], u = t.scale[1], c = t.translate[0], h = t.translate[1];
        return function (t, e) {
            e || (o = s = 0);
            var n = 2, r = t.length, i = new Array(r);
            for (i[0] = (o += t[0]) * a + c, i[1] = (s += t[1]) * u + h; n < r;) i[n] = t[n], ++n;
            return i
        }
    }, ye = function (t, e) {
        for (var n, r = t.length, i = r - e; i < --r;) n = t[i], t[i++] = t[r], t[r] = n
    };

    function _e(t, e) {
        var o = de(t.transform), s = t.arcs;

        function i(t, e) {
            e.length && e.pop();
            for (var n = s[t < 0 ? ~t : t], r = 0, i = n.length; r < i; ++r) e.push(o(n[r], r));
            t < 0 && ye(e, i)
        }

        function a(t) {
            return o(t)
        }

        function u(t) {
            for (var e = [], n = 0, r = t.length; n < r; ++n) i(t[n], e);
            return e.length < 2 && e.push(e[0]), e
        }

        function n(t) {
            for (var e = u(t); e.length < 4;) e.push(e[0]);
            return e
        }

        function c(t) {
            return t.map(n)
        }

        return function t(e) {
            var n, r = e.type;
            switch (r) {
                case"GeometryCollection":
                    return {type: r, geometries: e.geometries.map(t)};
                case"Point":
                    n = a(e.coordinates);
                    break;
                case"MultiPoint":
                    n = e.coordinates.map(a);
                    break;
                case"LineString":
                    n = u(e.arcs);
                    break;
                case"MultiLineString":
                    n = e.arcs.map(u);
                    break;
                case"Polygon":
                    n = c(e.arcs);
                    break;
                case"MultiPolygon":
                    n = e.arcs.map(c);
                    break;
                default:
                    return null
            }
            return {type: r, coordinates: n}
        }(e)
    }

    var me = function (o, s, a, t, u, e) {
        3 === arguments.length && (t = e = Array, u = null);
        for (var c = new t(o = 1 << Math.max(4, Math.ceil(Math.log(o) / Math.LN2))), h = new e(o), l = o - 1, n = 0; n < o; ++n) c[n] = u;
        return {
            set: function (t, e) {
                for (var n = s(t) & l, r = c[n], i = 0; r != u;) {
                    if (a(r, t)) return h[n] = e;
                    if (++i >= o) throw new Error("full hashmap");
                    r = c[n = n + 1 & l]
                }
                return c[n] = t, h[n] = e
            }, maybeSet: function (t, e) {
                for (var n = s(t) & l, r = c[n], i = 0; r != u;) {
                    if (a(r, t)) return h[n];
                    if (++i >= o) throw new Error("full hashmap");
                    r = c[n = n + 1 & l]
                }
                return c[n] = t, h[n] = e
            }, get: function (t, e) {
                for (var n = s(t) & l, r = c[n], i = 0; r != u;) {
                    if (a(r, t)) return h[n];
                    if (++i >= o) break;
                    r = c[n = n + 1 & l]
                }
                return e
            }, keys: function () {
                for (var t = [], e = 0, n = c.length; e < n; ++e) {
                    var r = c[e];
                    r != u && t.push(r)
                }
                return t
            }
        }
    }, ve = function (t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }, xe = new ArrayBuffer(16), Ee = new Float64Array(xe), we = new Uint32Array(xe), be = function (t) {
        Ee[0] = t[0], Ee[1] = t[1];
        var e = we[0] ^ we[1];
        return 2147483647 & (e << 5 ^ e >> 7 ^ we[2] ^ we[3])
    };

    function Ie(t, e, n) {
        for (var r, i = e + (n-- - e >> 1); e < i; ++e, --n) r = t[e], t[e] = t[n], t[n] = r
    }

    function Ne(t) {
        var e, n = Ce(t.geometry);
        for (e in null != t.id && (n.id = t.id), null != t.bbox && (n.bbox = t.bbox), t.properties) {
            n.properties = t.properties;
            break
        }
        return n
    }

    function Ce(t) {
        if (null == t) return {type: null};
        var e = "GeometryCollection" === t.type ? {
            type: "GeometryCollection",
            geometries: t.geometries.map(Ce)
        } : "Point" === t.type || "MultiPoint" === t.type ? {type: t.type, coordinates: t.coordinates} : {
            type: t.type,
            arcs: t.coordinates
        };
        return null != t.bbox && (e.bbox = t.bbox), e
    }

    var Se = function (t, e) {
        var n = function (t) {
            var r = 1 / 0, i = 1 / 0, o = -1 / 0, s = -1 / 0;

            function e(t) {
                null != t && n.hasOwnProperty(t.type) && n[t.type](t)
            }

            var n = {
                GeometryCollection: function (t) {
                    t.geometries.forEach(e)
                }, Point: function (t) {
                    a(t.coordinates)
                }, MultiPoint: function (t) {
                    t.coordinates.forEach(a)
                }, LineString: function (t) {
                    u(t.arcs)
                }, MultiLineString: function (t) {
                    t.arcs.forEach(u)
                }, Polygon: function (t) {
                    t.arcs.forEach(u)
                }, MultiPolygon: function (t) {
                    t.arcs.forEach(c)
                }
            };

            function a(t) {
                var e = t[0], n = t[1];
                e < r && (r = e), o < e && (o = e), n < i && (i = n), s < n && (s = n)
            }

            function u(t) {
                t.forEach(a)
            }

            function c(t) {
                t.forEach(u)
            }

            for (var h in t) e(t[h]);
            return r <= o && i <= s ? [r, i, o, s] : void 0
        }(t = function (t) {
            var e, n, r = {};
            for (e in t) r[e] = null == (n = t[e]) ? {type: null} : ("FeatureCollection" === n.type ? function (t) {
                var e = {type: "GeometryCollection", geometries: t.features.map(Ne)};
                return null != t.bbox && (e.bbox = t.bbox), e
            } : "Feature" === n.type ? Ne : Ce)(n);
            return r
        }(t)), r = 0 < e && n && function (t, e, n) {
            var l = e[0], p = e[1], r = e[2], i = e[3], f = r - l ? (n - 1) / (r - l) : 1,
                g = i - p ? (n - 1) / (i - p) : 1;

            function o(t) {
                return [Math.round((t[0] - l) * f), Math.round((t[1] - p) * g)]
            }

            function s(t, e) {
                for (var n, r, i, o, s, a = -1, u = 0, c = t.length, h = new Array(c); ++a < c;) n = t[a], o = Math.round((n[0] - l) * f), s = Math.round((n[1] - p) * g), o === r && s === i || (h[u++] = [r = o, i = s]);
                for (h.length = u; u < e;) u = h.push([h[0][0], h[0][1]]);
                return h
            }

            function a(t) {
                return s(t, 2)
            }

            function u(t) {
                return s(t, 4)
            }

            function c(t) {
                return t.map(u)
            }

            function h(t) {
                null != t && d.hasOwnProperty(t.type) && d[t.type](t)
            }

            var d = {
                GeometryCollection: function (t) {
                    t.geometries.forEach(h)
                }, Point: function (t) {
                    t.coordinates = o(t.coordinates)
                }, MultiPoint: function (t) {
                    t.coordinates = t.coordinates.map(o)
                }, LineString: function (t) {
                    t.arcs = a(t.arcs)
                }, MultiLineString: function (t) {
                    t.arcs = t.arcs.map(a)
                }, Polygon: function (t) {
                    t.arcs = c(t.arcs)
                }, MultiPolygon: function (t) {
                    t.arcs = t.arcs.map(c)
                }
            };
            for (var y in t) h(t[y]);
            return {scale: [1 / f, 1 / g], translate: [l, p]}
        }(t, n, e), i = function (t) {
            var e, n, r, i, h = t.coordinates, o = t.lines, s = t.rings, a = o.length + s.length;
            for (delete t.lines, delete t.rings, r = 0, i = o.length; r < i; ++r) for (e = o[r]; e = e.next;) ++a;
            for (r = 0, i = s.length; r < i; ++r) for (n = s[r]; n = n.next;) ++a;
            var c = me(2 * a * 1.4, be, ve), l = t.arcs = [];
            for (r = 0, i = o.length; r < i; ++r) for (e = o[r]; u(e), e = e.next;) ;
            for (r = 0, i = s.length; r < i; ++r) if ((n = s[r]).next) for (; u(n), n = n.next;) ; else p(n);

            function u(t) {
                var e, n, r, i, o, s, a, u;
                if (r = c.get(e = h[t[0]])) for (a = 0, u = r.length; a < u; ++a) if (f(i = r[a], t)) return t[0] = i[0], void(t[1] = i[1]);
                if (o = c.get(n = h[t[1]])) for (a = 0, u = o.length; a < u; ++a) if (g(s = o[a], t)) return t[1] = s[0], void(t[0] = s[1]);
                r ? r.push(t) : c.set(e, [t]), o ? o.push(t) : c.set(n, [t]), l.push(t)
            }

            function p(t) {
                var e, n, r, i, o;
                if (n = c.get(h[t[0]])) for (i = 0, o = n.length; i < o; ++i) {
                    if (d(r = n[i], t)) return t[0] = r[0], void(t[1] = r[1]);
                    if (y(r, t)) return t[0] = r[1], void(t[1] = r[0])
                }
                if (n = c.get(e = h[t[0] + _(t)])) for (i = 0, o = n.length; i < o; ++i) {
                    if (d(r = n[i], t)) return t[0] = r[0], void(t[1] = r[1]);
                    if (y(r, t)) return t[0] = r[1], void(t[1] = r[0])
                }
                n ? n.push(t) : c.set(e, [t]), l.push(t)
            }

            function f(t, e) {
                var n = t[0], r = e[0], i = t[1];
                if (n - i != r - e[1]) return !1;
                for (; n <= i; ++n, ++r) if (!ve(h[n], h[r])) return !1;
                return !0
            }

            function g(t, e) {
                var n = t[0], r = e[0], i = t[1], o = e[1];
                if (n - i != r - o) return !1;
                for (; n <= i; ++n, --o) if (!ve(h[n], h[o])) return !1;
                return !0
            }

            function d(t, e) {
                var n = t[0], r = e[0], i = t[1] - n;
                if (i !== e[1] - r) return !1;
                for (var o = _(t), s = _(e), a = 0; a < i; ++a) if (!ve(h[n + (a + o) % i], h[r + (a + s) % i])) return !1;
                return !0
            }

            function y(t, e) {
                var n = t[0], r = e[0], i = t[1], o = e[1], s = i - n;
                if (s !== o - r) return !1;
                for (var a = _(t), u = s - _(e), c = 0; c < s; ++c) if (!ve(h[n + (c + a) % s], h[o - (c + u) % s])) return !1;
                return !0
            }

            function _(t) {
                for (var e = t[0], n = t[1], r = e, i = r, o = h[r]; ++r < n;) {
                    var s = h[r];
                    (s[0] < o[0] || s[0] === o[0] && s[1] < o[1]) && (i = r, o = s)
                }
                return i - e
            }

            return t
        }(function (t) {
            var e, n, r, i, o, s, a, u = function (t) {
                var e, n, r, i, o = t.coordinates, s = t.lines, a = t.rings, u = function () {
                        for (var t = me(1.4 * o.length, E, w, Int32Array, -1, Int32Array), e = new Int32Array(o.length), n = 0, r = o.length; n < r; ++n) e[n] = t.maybeSet(n, n);
                        return e
                    }(), c = new Int32Array(o.length), h = new Int32Array(o.length), l = new Int32Array(o.length),
                    p = new Int8Array(o.length), f = 0;
                for (e = 0, n = o.length; e < n; ++e) c[e] = h[e] = l[e] = -1;
                for (e = 0, n = s.length; e < n; ++e) {
                    var g = s[e], d = g[0], y = g[1];
                    for (r = u[d], i = u[++d], ++f, p[r] = 1; ++d <= y;) x(e, r, r = i, i = u[d]);
                    ++f, p[i] = 1
                }
                for (e = 0, n = o.length; e < n; ++e) c[e] = -1;
                for (e = 0, n = a.length; e < n; ++e) {
                    var _ = a[e], m = _[0] + 1, v = _[1];
                    for (x(e, u[v - 1], r = u[m - 1], i = u[m]); ++m <= v;) x(e, r, r = i, i = u[m])
                }

                function x(t, e, n, r) {
                    if (c[n] !== t) {
                        c[n] = t;
                        var i = h[n];
                        if (0 <= i) {
                            var o = l[n];
                            i === e && o === r || i === r && o === e || (++f, p[n] = 1)
                        } else h[n] = e, l[n] = r
                    }
                }

                function E(t) {
                    return be(o[t])
                }

                function w(t, e) {
                    return ve(o[t], o[e])
                }

                c = h = l = null;
                var b, I = function (i, o, s, t, a) {
                    3 === arguments.length && (t = Array, a = null);
                    for (var u = new t(i = 1 << Math.max(4, Math.ceil(Math.log(i) / Math.LN2))), c = i - 1, e = 0; e < i; ++e) u[e] = a;
                    return {
                        add: function (t) {
                            for (var e = o(t) & c, n = u[e], r = 0; n != a;) {
                                if (s(n, t)) return !0;
                                if (++r >= i) throw new Error("full hashset");
                                n = u[e = e + 1 & c]
                            }
                            return u[e] = t, !0
                        }, has: function (t) {
                            for (var e = o(t) & c, n = u[e], r = 0; n != a;) {
                                if (s(n, t)) return !0;
                                if (++r >= i) break;
                                n = u[e = e + 1 & c]
                            }
                            return !1
                        }, values: function () {
                            for (var t = [], e = 0, n = u.length; e < n; ++e) {
                                var r = u[e];
                                r != a && t.push(r)
                            }
                            return t
                        }
                    }
                }(1.4 * f, be, ve);
                for (e = 0, n = o.length; e < n; ++e) p[b = u[e]] && I.add(o[b]);
                return I
            }(t), c = t.coordinates, h = t.lines, l = t.rings;
            for (n = 0, r = h.length; n < r; ++n) for (var p = h[n], f = p[0], g = p[1]; ++f < g;) u.has(c[f]) && (e = {
                0: f,
                1: p[1]
            }, p[1] = f, p = p.next = e);
            for (n = 0, r = l.length; n < r; ++n) for (var d = l[n], y = d[0], _ = y, m = d[1], v = u.has(c[y]); ++_ < m;) u.has(c[_]) && (v ? (e = {
                0: _,
                1: d[1]
            }, d[1] = _, d = d.next = e) : (a = (s = m) - _, Ie(i = c, o = y, s), Ie(i, o, o + a), Ie(i, o + a, s), c[m] = c[y], v = !0, _ = y));
            return t
        }(function (t) {
            var i = -1, o = [], s = [], a = [];

            function e(t) {
                t && n.hasOwnProperty(t.type) && n[t.type](t)
            }

            var n = {
                GeometryCollection: function (t) {
                    t.geometries.forEach(e)
                }, LineString: function (t) {
                    t.arcs = r(t.arcs)
                }, MultiLineString: function (t) {
                    t.arcs = t.arcs.map(r)
                }, Polygon: function (t) {
                    t.arcs = t.arcs.map(u)
                }, MultiPolygon: function (t) {
                    t.arcs = t.arcs.map(c)
                }
            };

            function r(t) {
                for (var e = 0, n = t.length; e < n; ++e) a[++i] = t[e];
                var r = {0: i - n + 1, 1: i};
                return o.push(r), r
            }

            function u(t) {
                for (var e = 0, n = t.length; e < n; ++e) a[++i] = t[e];
                var r = {0: i - n + 1, 1: i};
                return s.push(r), r
            }

            function c(t) {
                return t.map(u)
            }

            for (var h in t) e(t[h]);
            return {type: "Topology", coordinates: a, lines: o, rings: s, objects: t}
        }(t))), o = i.coordinates, s = me(1.4 * i.arcs.length, Me, Le);

        function a(t) {
            t && u.hasOwnProperty(t.type) && u[t.type](t)
        }

        t = i.objects, i.bbox = n, i.arcs = i.arcs.map(function (t, e) {
            return s.set(t, e), o.slice(t[0], t[1] + 1)
        }), delete i.coordinates, o = null;
        var u = {
            GeometryCollection: function (t) {
                t.geometries.forEach(a)
            }, LineString: function (t) {
                t.arcs = c(t.arcs)
            }, MultiLineString: function (t) {
                t.arcs = t.arcs.map(c)
            }, Polygon: function (t) {
                t.arcs = t.arcs.map(c)
            }, MultiPolygon: function (t) {
                t.arcs = t.arcs.map(h)
            }
        };

        function c(t) {
            var e = [];
            do {
                var n = s.get(t);
                e.push(t[0] < t[1] ? n : ~n)
            } while (t = t.next);
            return e
        }

        function h(t) {
            return t.map(c)
        }

        for (var l in t) a(t[l]);
        return r && (i.transform = r, i.arcs = function (t) {
            for (var e = -1, n = t.length; ++e < n;) {
                for (var r, i, o = t[e], s = 0, a = 1, u = o.length, c = o[0], h = c[0], l = c[1]; ++s < u;) r = (c = o[s])[0], i = c[1], r === h && i === l || (o[a++] = [r - h, i - l], h = r, l = i);
                1 === a && (o[a++] = [0, 0]), o.length = a
            }
            return t
        }(i.arcs)), i
    };

    function Me(t) {
        var e, n = t[0], r = t[1];
        return r < n && (e = n, n = r, r = e), n + 31 * r
    }

    function Le(t, e) {
        var n, r = t[0], i = t[1], o = e[0], s = e[1];
        return i < r && (n = r, r = i, i = n), s < o && (n = o, o = s, s = n), r === o && i === s
    }

    function Pe(t) {
        return t[0].toString() + "," + t[1].toString()
    }

    function Oe(r, t) {
        if (!H(t = t || {})) throw new Error("options is invalid");
        var e = t.mutate;
        if ("FeatureCollection" !== rt(r)) throw new Error("geojson must be a FeatureCollection");
        if (!r.features.length) throw new Error("geojson is empty");
        !1 !== e && void 0 !== e || (r = le(r));
        var n = function (t) {
            var e = {};
            A(r, function (t) {
                e[t.geometry.type] = !0
            });
            var n = Object.keys(e);
            return 1 === n.length ? n[0] : null
        }();
        if (!n) throw new Error("geojson must be homogenous");
        switch (n) {
            case"LineString":
                return function (t, e) {
                    if (!H(e = e || {})) throw new Error("options is invalid");
                    var n = e.mutate;
                    if ("FeatureCollection" !== rt(t)) throw new Error("geojson must be a FeatureCollection");
                    if (!t.features.length) throw new Error("geojson is empty");
                    !1 !== n && void 0 !== n || (t = le(t));
                    var r = [], i = k(t, function (c, t) {
                        return function (t, e) {
                            var n, r = c.geometry.coordinates, i = e.geometry.coordinates, o = Pe(r[0]),
                                s = Pe(r[r.length - 1]), a = Pe(i[0]), u = Pe(i[i.length - 1]);
                            if (o === u) n = i.concat(r.slice(1)); else if (a === s) n = r.concat(i.slice(1)); else if (o === a) n = r.slice(1).reverse().concat(i); else {
                                if (s !== u) return null;
                                n = r.concat(i.reverse().slice(1))
                            }
                            return U(n)
                        }(0, t) || (r.push(c), t)
                    });
                    return i && r.push(i), r.length ? 1 === r.length ? r[0] : v(r.map(function (t) {
                        return t.coordinates
                    })) : null
                }(r, t);
            case"Polygon":
                return function (t, e) {
                    if (!H(e = e || {})) throw new Error("options is invalid");
                    var n = e.mutate;
                    if ("FeatureCollection" !== rt(t)) throw new Error("geojson must be a FeatureCollection");
                    if (!t.features.length) throw new Error("geojson is empty");
                    !1 !== n && void 0 !== n || (t = le(t));
                    var r = [];
                    A(t, function (t) {
                        r.push(t.geometry)
                    });
                    var i = Se({geoms: c(r).geometry});
                    return function (t) {
                        return _e(t, function (a, t) {
                            var u = {}, n = [], r = [];

                            function i(e) {
                                e.forEach(function (t) {
                                    t.forEach(function (t) {
                                        (u[t = t < 0 ? ~t : t] || (u[t] = [])).push(e)
                                    })
                                }), n.push(e)
                            }

                            function c(t) {
                                return function (t) {
                                    for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r;) e = i, i = t[n], o += e[0] * i[1] - e[1] * i[0];
                                    return Math.abs(o)
                                }(_e(a, {type: "Polygon", arcs: [t]}).coordinates[0])
                            }

                            return t.forEach(function t(e) {
                                switch (e.type) {
                                    case"GeometryCollection":
                                        e.geometries.forEach(t);
                                        break;
                                    case"Polygon":
                                        i(e.arcs);
                                        break;
                                    case"MultiPolygon":
                                        e.arcs.forEach(i)
                                }
                            }), n.forEach(function (t) {
                                if (!t._) {
                                    var e = [], n = [t];
                                    for (t._ = 1, r.push(e); t = n.pop();) e.push(t), t.forEach(function (t) {
                                        t.forEach(function (t) {
                                            u[t < 0 ? ~t : t].forEach(function (t) {
                                                t._ || (t._ = 1, n.push(t))
                                            })
                                        })
                                    })
                                }
                            }), n.forEach(function (t) {
                                delete t._
                            }), {
                                type: "MultiPolygon", arcs: r.map(function (t) {
                                    var e, n = [];
                                    if (t.forEach(function (t) {
                                        t.forEach(function (t) {
                                            t.forEach(function (t) {
                                                u[t < 0 ? ~t : t].length < 2 && n.push(t)
                                            })
                                        })
                                    }), 1 < (e = (n = function (p, i) {
                                        var o = {}, f = {}, g = {}, s = [], a = -1;

                                        function t(t, e) {
                                            for (var n in t) {
                                                var r = t[n];
                                                delete e[r.start], delete r.start, delete r.end, r.forEach(function (t) {
                                                    o[t < 0 ? ~t : t] = 1
                                                }), s.push(r)
                                            }
                                        }

                                        return i.forEach(function (t, e) {
                                            var n, r = p.arcs[t < 0 ? ~t : t];
                                            r.length < 3 && !r[1][0] && !r[1][1] && (n = i[++a], i[a] = t, i[e] = n)
                                        }), i.forEach(function (t) {
                                            var e, n, r, i, o, s,
                                                a = (r = t, o = p.arcs[r < 0 ? ~r : r], s = o[0], p.transform ? (i = [0, 0], o.forEach(function (t) {
                                                    i[0] += t[0], i[1] += t[1]
                                                })) : i = o[o.length - 1], r < 0 ? [i, s] : [s, i]), u = a[0], c = a[1];
                                            if (e = g[u]) if (delete g[e.end], e.push(t), e.end = c, n = f[c]) {
                                                delete f[n.start];
                                                var h = n === e ? e : e.concat(n);
                                                f[h.start = e.start] = g[h.end = n.end] = h
                                            } else f[e.start] = g[e.end] = e; else if (e = f[c]) if (delete f[e.start], e.unshift(t), e.start = u, n = g[u]) {
                                                delete g[n.end];
                                                var l = n === e ? e : n.concat(e);
                                                f[l.start = n.start] = g[l.end = e.end] = l
                                            } else f[e.start] = g[e.end] = e; else f[(e = [t]).start = u] = g[e.end = c] = e
                                        }), t(g, f), t(f, g), i.forEach(function (t) {
                                            o[t < 0 ? ~t : t] || s.push([t])
                                        }), s
                                    }(a, n)).length)) for (var r, i, o = 1, s = c(n[0]); o < e; ++o) (r = c(n[o])) > s && (i = n[0], n[0] = n[o], n[o] = i, s = r);
                                    return n
                                })
                            }
                        }.apply(this, arguments))
                    }(i, i.objects.geoms.geometries)
                }(r, t);
            default:
                throw new Error(n + " is not supported")
        }
    }

    function Re(t, e) {
        var n = "object" == typeof e ? e.mutate : e;
        if (!t) throw new Error("geojson is required");
        var r = rt(t), i = [];
        switch (r) {
            case"LineString":
                i = Te(t);
                break;
            case"MultiLineString":
            case"Polygon":
                Z(t).forEach(function (t) {
                    i.push(Te(t))
                });
                break;
            case"MultiPolygon":
                Z(t).forEach(function (t) {
                    var e = [];
                    t.forEach(function (t) {
                        e.push(Te(t))
                    }), i.push(e)
                });
                break;
            case"Point":
                return t;
            case"MultiPoint":
                var o = {};
                Z(t).forEach(function (t) {
                    var e = t.join("-");
                    o.hasOwnProperty(e) || (i.push(t), o[e] = !0)
                });
                break;
            default:
                throw new Error(r + " geometry not supported")
        }
        return t.coordinates ? !0 === n ? (t.coordinates = i, t) : {
            type: r,
            coordinates: i
        } : !0 === n ? (t.geometry.coordinates = i, t) : j({type: r, coordinates: i}, t.properties, t.bbox, t.id)
    }

    function Te(t) {
        var e, n, r, i, o, s = Z(t);
        if (2 === s.length && (e = s[0], n = s[1], e[0] !== n[0] || e[1] !== n[1])) return s;
        var a, u, c, h, l, p, f, g, d, y, _, m = [], v = s.length - 1;
        m.push(s[0]);
        for (var x = 1; x < v; x++) r = s[x - 1], i = s[x], a = r, u = o = s[x + 1], void 0, h = (c = i)[0], l = c[1], p = a[0], f = a[1], g = u[0], d = u[1], 0 == (h - p) * (_ = d - f) - (l - f) * (y = g - p) && (Math.abs(y) >= Math.abs(_) ? 0 < y ? p <= h && h <= g : g <= h && h <= p : 0 < _ ? f <= l && l <= d : d <= l && l <= f) || m.push(i);
        return m.push(o), m
    }

    function Ae(t, e, n) {
        var r = e.x, i = e.y, o = n.x - r, s = n.y - i;
        if (0 !== o || 0 !== s) {
            var a = ((t.x - r) * o + (t.y - i) * s) / (o * o + s * s);
            1 < a ? (r = n.x, i = n.y) : 0 < a && (r += o * a, i += s * a)
        }
        return (o = t.x - r) * o + (s = t.y - i) * s
    }

    function De(t, e, n) {
        if (t.length <= 2) return t;
        var r, i, o, s, a = void 0 !== e ? e * e : 1;
        return r = t = n ? t : function (t, e) {
            for (var n, r, i, o, s, a = t[0], u = [a], c = 1, h = t.length; c < h; c++) i = a, e < (o = (r = n = t[c]).x - i.x) * o + (s = r.y - i.y) * s && (u.push(n), a = n);
            return a !== n && u.push(n), u
        }(t, a), i = a, o = r.length - 1, s = [r[0]], function t(e, n, r, i, o) {
            for (var s, a = i, u = n + 1; u < r; u++) {
                var c = Ae(e[u], e[n], e[r]);
                a < c && (s = u, a = c)
            }
            i < a && (1 < s - n && t(e, n, s, i, o), o.push(e[s]), 1 < r - s && t(e, s, r, i, o))
        }(r, 0, o, i, s), s.push(r[o]), s
    }

    function Fe(t, e, n) {
        return De(t.map(function (t) {
            return {x: t[0], y: t[1], z: t[2]}
        }), e, n).map(function (t) {
            return t.z ? [t.x, t.y, t.z] : [t.x, t.y]
        })
    }

    function qe(t, i, o) {
        return t.map(function (t) {
            var e, n = t.map(function (t) {
                return {x: t[0], y: t[1]}
            });
            if (n.length < 4) throw new Error("invalid polygon");
            for (var r = De(n, i, o).map(function (t) {
                return [t.x, t.y]
            }); (e = r).length < 3 || 3 === e.length && e[2][0] === e[0][0] && e[2][1] === e[0][1];) r = De(n, i -= .01 * i, o).map(function (t) {
                return [t.x, t.y]
            });
            return r[r.length - 1][0] === r[0][0] && r[r.length - 1][1] === r[0][1] || r.push(r[0]), r
        })
    }

    var Ge = function (t) {
        this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || .85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length;
        for (var e = this.delay = 0; e < this.length; e++) this.points[e].z = this.points[e].z || 0;
        for (e = 0; e < this.length - 1; e++) {
            var n = this.points[e], r = this.points[e + 1];
            this.centers.push({x: (n.x + r.x) / 2, y: (n.y + r.y) / 2, z: (n.z + r.z) / 2})
        }
        for (this.controls.push([this.points[0], this.points[0]]), e = 0; e < this.centers.length - 1; e++) {
            n = this.centers[e], r = this.centers[e + 1];
            var i = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2,
                o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2,
                s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;
            this.controls.push([{
                x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + i),
                y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o),
                z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s)
            }, {
                x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + i),
                y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o),
                z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s)
            }])
        }
        return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this
    };

    function Be(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.resolution || 1e4, r = e.sharpness || .85;
        if (!t) throw new Error("line is required");
        if (!V(n)) throw new Error("resolution must be an number");
        if (!V(r)) throw new Error("sharpness must be an number");
        for (var i = [], o = new Ge({
            points: et(t).coordinates.map(function (t) {
                return {x: t[0], y: t[1], z: t[2] || 0}
            }), duration: n, sharpness: r
        }), s = 0; s < o.duration; s += 10) {
            var a = o.pos(s);
            Math.floor(s / 100) % 2 == 0 && i.push([a.x, a.y, a.z])
        }
        return U(i, t.properties)
    }

    function ke(t) {
        w(t);
        var e = Number(t[0]), n = Number(t[1]), r = Number(t[2]), i = Number(t[3]);
        if (6 === t.length) throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
        var o = [e, n];
        return B([[o, [r, n], [r, i], [e, i], o]])
    }

    function ze(t) {
        return ke(W(t))
    }

    function je(t) {
        var e = t[0], n = t[1], r = t[2], i = t[3], o = he(t.slice(0, 2), [r, n]);
        if (he(t.slice(0, 2), [e, i]) <= o) {
            var s = (n + i) / 2;
            return [e, s - (r - e) / 2, r, s + (r - e) / 2]
        }
        var a = (e + r) / 2;
        return [a - (i - n) / 2, n, a + (i - n) / 2, i]
    }

    function Xe(t, e, n, r) {
        if (!H(r = r || {})) throw new Error("options is invalid");
        var i = r.units, o = r.properties, s = J(t), a = m(s[0]), u = m(s[1]), c = m(n), h = d(e, i),
            l = Math.asin(Math.sin(u) * Math.cos(h) + Math.cos(u) * Math.sin(h) * Math.cos(c));
        return X([y(a + Math.atan2(Math.sin(c) * Math.sin(h) * Math.cos(u), Math.cos(h) - Math.sin(u) * Math.sin(l))), y(l)], o)
    }

    function Ue(t, e, n) {
        var r = (n = n || {}).steps || 64, i = n.properties;
        if (!t) throw new Error("center is required");
        if (!e) throw new Error("radius is required");
        if ("object" != typeof n) throw new Error("options must be an object");
        if ("number" != typeof r) throw new Error("steps must be a number");
        r = r || 64, i = i || t.properties || {};
        for (var o = [], s = 0; s < r; s++) o.push(Xe(t, e, -360 * s / r, n).geometry.coordinates);
        return o.push(o[0]), B([o], i)
    }

    function Ye(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        if (!0 === n.final) return (Ye(e, t) + 180) % 360;
        var r = J(t), i = J(e), o = m(r[0]), s = m(i[0]), a = m(r[1]), u = m(i[1]), c = Math.sin(s - o) * Math.cos(u),
            h = Math.cos(a) * Math.sin(u) - Math.sin(a) * Math.cos(u) * Math.cos(s - o);
        return y(Math.atan2(c, h))
    }

    function Ve(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.properties;
        if (!t) throw new Error("geojson is required");
        var r = W(t);
        return X([(r[0] + r[2]) / 2, (r[1] + r[3]) / 2], n)
    }

    function He(t, e) {
        var n = 0, r = 0, i = 0;
        return N(t, function (t) {
            n += t[0], r += t[1], i++
        }, !0), X([n / i, r / i], e)
    }

    function We(e) {
        var n = [];
        return "FeatureCollection" === e.type ? L(e, function (e) {
            N(e, function (t) {
                n.push(X(t, e.properties))
            })
        }) : N(e, function (t) {
            n.push(X(t, e.properties))
        }), Y(n)
    }

    Ge.prototype.cacheSteps = function (t) {
        var e = [], n = this.pos(0);
        e.push(0);
        for (var r = 0; r < this.duration; r += 10) {
            var i = this.pos(r);
            t < Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) && (e.push(r), n = i)
        }
        return e
    }, Ge.prototype.vector = function (t) {
        var e = this.pos(t + 10), n = this.pos(t - 10);
        return {
            angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14,
            speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z))
        }
    }, Ge.prototype.pos = function (t) {
        var e = t - this.delay;
        e < 0 && (e = 0), e > this.duration && (e = this.duration - 1);
        var n = e / this.duration;
        if (1 <= n) return this.points[this.length - 1];
        var r, i, o, s, a, u, c, h, l = Math.floor((this.points.length - 1) * n);
        return r = (this.length - 1) * n - l, i = this.points[l], o = this.controls[l][1], s = this.controls[l + 1][0], h = [(c = (u = r) * u) * u, 3 * c * (1 - u), 3 * u * (1 - u) * (1 - u), (1 - u) * (1 - u) * (1 - u)], {
            x: (a = this.points[l + 1]).x * h[0] + s.x * h[1] + o.x * h[2] + i.x * h[3],
            y: a.y * h[0] + s.y * h[1] + o.y * h[2] + i.y * h[3],
            z: a.z * h[0] + s.z * h[1] + o.z * h[2] + i.z * h[3]
        }
    };
    var Je = Ke, Ze = Ke;

    function Ke(t, e, n) {
        n = n || 2;
        var r, i, o, s, a, u, c, h = e && e.length, l = h ? e[0] * n : t.length, p = Qe(t, 0, l, n, !0), f = [];
        if (!p) return f;
        if (h && (p = function (t, e, n, r) {
            var i, o, s, a = [];
            for (i = 0, o = e.length; i < o; i++) (s = Qe(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === s.next && (s.steiner = !0), a.push(cn(s));
            for (a.sort(sn), i = 0; i < a.length; i++) an(a[i], n), n = $e(n, n.next);
            return n
        }(t, e, p, n)), t.length > 80 * n) {
            r = o = t[0], i = s = t[1];
            for (var g = n; g < l; g += n) (a = t[g]) < r && (r = a), (u = t[g + 1]) < i && (i = u), o < a && (o = a), s < u && (s = u);
            c = 0 !== (c = Math.max(o - r, s - i)) ? 1 / c : 0
        }
        return tn(p, f, n, r, i, c), f
    }

    function Qe(t, e, n, r, i) {
        var o, s;
        if (i === 0 < vn(t, e, n, r)) for (o = e; o < n; o += r) s = yn(o, t[o], t[o + 1], s); else for (o = n - r; e <= o; o -= r) s = yn(o, t[o], t[o + 1], s);
        return s && pn(s, s.next) && (_n(s), s = s.next), s
    }

    function $e(t, e) {
        if (!t) return t;
        e || (e = t);
        var n, r = t;
        do {
            if (n = !1, r.steiner || !pn(r, r.next) && 0 !== ln(r.prev, r, r.next)) r = r.next; else {
                if (_n(r), (r = e = r.prev) === r.next) break;
                n = !0
            }
        } while (n || r !== e);
        return e
    }

    function tn(t, e, n, r, i, o, s) {
        if (t) {
            !s && o && function (t, e, n, r) {
                for (var i = t; null === i.z && (i.z = un(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, (i = i.next) !== t;) ;
                i.prevZ.nextZ = null, i.prevZ = null, function (t) {
                    var e, n, r, i, o, s, a, u, c = 1;
                    do {
                        for (n = t, o = t = null, s = 0; n;) {
                            for (s++, r = n, e = a = 0; e < c && (a++, r = r.nextZ); e++) ;
                            for (u = c; 0 < a || 0 < u && r;) 0 !== a && (0 === u || !r || n.z <= r.z) ? (n = (i = n).nextZ, a--) : (r = (i = r).nextZ, u--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                            n = r
                        }
                        o.nextZ = null, c *= 2
                    } while (1 < s)
                }(i)
            }(t, r, i, o);
            for (var a, u, c = t; t.prev !== t.next;) if (a = t.prev, u = t.next, o ? nn(t, r, i, o) : en(t)) e.push(a.i / n), e.push(t.i / n), e.push(u.i / n), _n(t), t = u.next, c = u.next; else if ((t = u) === c) {
                s ? 1 === s ? tn(t = rn(t, e, n), e, n, r, i, o, 2) : 2 === s && on(t, e, n, r, i, o) : tn($e(t), e, n, r, i, o, 1);
                break
            }
        }
    }

    function en(t) {
        var e = t.prev, n = t, r = t.next;
        if (0 <= ln(e, n, r)) return !1;
        for (var i = t.next.next; i !== t.prev;) {
            if (hn(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= ln(i.prev, i, i.next)) return !1;
            i = i.next
        }
        return !0
    }

    function nn(t, e, n, r) {
        var i = t.prev, o = t, s = t.next;
        if (0 <= ln(i, o, s)) return !1;
        for (var a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x, u = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y, c = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x, h = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y, l = un(a, u, e, n, r), p = un(c, h, e, n, r), f = t.nextZ; f && f.z <= p;) {
            if (f !== t.prev && f !== t.next && hn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && 0 <= ln(f.prev, f, f.next)) return !1;
            f = f.nextZ
        }
        for (f = t.prevZ; f && f.z >= l;) {
            if (f !== t.prev && f !== t.next && hn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && 0 <= ln(f.prev, f, f.next)) return !1;
            f = f.prevZ
        }
        return !0
    }

    function rn(t, e, n) {
        var r = t;
        do {
            var i = r.prev, o = r.next.next;
            !pn(i, o) && fn(i, r, r.next, o) && gn(i, o) && gn(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), _n(r), _n(r.next), r = t = o), r = r.next
        } while (r !== t);
        return r
    }

    function on(t, e, n, r, i, o) {
        var s, a, u = t;
        do {
            for (var c = u.next.next; c !== u.prev;) {
                if (u.i !== c.i && (a = c, (s = u).next.i !== a.i && s.prev.i !== a.i && !function (t, e) {
                    var n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && fn(n, n.next, t, e)) return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(s, a) && gn(s, a) && gn(a, s) && function (t, e) {
                    for (var n = t, r = !1, i = (t.x + e.x) / 2, o = (t.y + e.y) / 2; n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), (n = n.next) !== t;) ;
                    return r
                }(s, a))) {
                    var h = dn(u, c);
                    return u = $e(u, u.next), h = $e(h, h.next), tn(u, e, n, r, i, o), void tn(h, e, n, r, i, o)
                }
                c = c.next
            }
            u = u.next
        } while (u !== t)
    }

    function sn(t, e) {
        return t.x - e.x
    }

    function an(t, e) {
        if (e = function (t, e) {
            var n, r = e, i = t.x, o = t.y, s = -1 / 0;
            do {
                if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                    var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                    if (a <= i && s < a) {
                        if ((s = a) === i) {
                            if (o === r.y) return r;
                            if (o === r.next.y) return r.next
                        }
                        n = r.x < r.next.x ? r : r.next
                    }
                }
                r = r.next
            } while (r !== e);
            if (!n) return null;
            if (i === s) return n.prev;
            var u, c = n, h = n.x, l = n.y, p = 1 / 0;
            for (r = n.next; r !== c;) i >= r.x && r.x >= h && i !== r.x && hn(o < l ? i : s, o, h, l, o < l ? s : i, o, r.x, r.y) && ((u = Math.abs(o - r.y) / (i - r.x)) < p || u === p && r.x > n.x) && gn(r, t) && (n = r, p = u), r = r.next;
            return n
        }(t, e)) {
            var n = dn(e, t);
            $e(n, n.next)
        }
    }

    function un(t, e, n, r, i) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }

    function cn(t) {
        for (var e = t, n = t; e.x < n.x && (n = e), (e = e.next) !== t;) ;
        return n
    }

    function hn(t, e, n, r, i, o, s, a) {
        return 0 <= (i - s) * (e - a) - (t - s) * (o - a) && 0 <= (t - s) * (r - a) - (n - s) * (e - a) && 0 <= (n - s) * (o - a) - (i - s) * (r - a)
    }

    function ln(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }

    function pn(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function fn(t, e, n, r) {
        return !!(pn(t, e) && pn(n, r) || pn(t, r) && pn(n, e)) || 0 < ln(t, e, n) != 0 < ln(t, e, r) && 0 < ln(n, r, t) != 0 < ln(n, r, e)
    }

    function gn(t, e) {
        return ln(t.prev, t, t.next) < 0 ? 0 <= ln(t, e, t.next) && 0 <= ln(t, t.prev, e) : ln(t, e, t.prev) < 0 || ln(t, t.next, e) < 0
    }

    function dn(t, e) {
        var n = new mn(t.i, t.x, t.y), r = new mn(e.i, e.x, e.y), i = t.next, o = e.prev;
        return (t.next = e).prev = t, (n.next = i).prev = n, (r.next = n).prev = r, (o.next = r).prev = o, r
    }

    function yn(t, e, n, r) {
        var i = new mn(t, e, n);
        return r ? (i.next = r.next, (i.prev = r).next.prev = i, r.next = i) : (i.prev = i).next = i, i
    }

    function _n(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function mn(t, e, n) {
        this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }

    function vn(t, e, n, r) {
        for (var i = 0, o = e, s = n - r; o < n; o += r) i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
        return i
    }

    function xn(t) {
        var r = function (t) {
            for (var e = t[0][0].length, n = {
                vertices: [],
                holes: [],
                dimensions: e
            }, r = 0, i = 0; i < t.length; i++) {
                for (var o = 0; o < t[i].length; o++) for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);
                0 < i && (r += t[i - 1].length, n.holes.push(r))
            }
            return n
        }(t), i = Je(r.vertices, r.holes, 2), e = [], o = [];
        i.forEach(function (t, e) {
            var n = i[e];
            o.push([r.vertices[2 * n], r.vertices[2 * n + 1]])
        });
        for (var n = 0; n < o.length; n += 3) {
            var s = o.slice(n, n + 3);
            s.push(o[n]), e.push(B([s]))
        }
        return e
    }

    function En(r, t) {
        if (!r) throw new Error("targetPoint is required");
        if (!t) throw new Error("points is required");
        var i, o = 1 / 0;
        return L(t, function (t, e) {
            var n = he(r, t);
            n < o && ((i = le(t)).properties.featureIndex = e, i.properties.distanceToPoint = n, o = n)
        }), i
    }

    function wn(t, e, n) {
        var r = t[e];
        t[e] = t[n], t[n] = r
    }

    function bn(t, e) {
        return t < e ? -1 : e < t ? 1 : 0
    }

    function In(t, e) {
        if (!(this instanceof In)) return new In(t, e);
        this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), e && this._initFormat(e), this.clear()
    }

    function Nn(t, e, n) {
        if (!n) return e.indexOf(t);
        for (var r = 0; r < e.length; r++) if (n(t, e[r])) return r;
        return -1
    }

    function Cn(t, e) {
        Sn(t, 0, t.children.length, e, t)
    }

    function Sn(t, e, n, r, i) {
        i || (i = Dn(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
        for (var o, s = e; s < n; s++) o = t.children[s], Mn(i, t.leaf ? r(o) : o);
        return i
    }

    function Mn(t, e) {
        return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
    }

    function Ln(t, e) {
        return t.minX - e.minX
    }

    function Pn(t, e) {
        return t.minY - e.minY
    }

    function On(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY)
    }

    function Rn(t) {
        return t.maxX - t.minX + (t.maxY - t.minY)
    }

    function Tn(t, e) {
        return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
    }

    function An(t, e) {
        return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
    }

    function Dn(t) {
        return {children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0}
    }

    function Fn(t, e, n, r, i) {
        for (var o, s = [e, n]; s.length;) (n = s.pop()) - (e = s.pop()) <= r || (a = t, u = o = e + Math.ceil((n - e) / r / 2) * r, c = i, function t(e, n, r, i, o) {
            for (; r < i;) {
                if (600 < i - r) {
                    var s = i - r + 1, a = n - r + 1, u = Math.log(s), c = .5 * Math.exp(2 * u / 3),
                        h = .5 * Math.sqrt(u * c * (s - c) / s) * (a - s / 2 < 0 ? -1 : 1);
                    t(e, n, Math.max(r, Math.floor(n - a * c / s + h)), Math.min(i, Math.floor(n + (s - a) * c / s + h)), o)
                }
                var l = e[n], p = r, f = i;
                for (wn(e, r, n), 0 < o(e[i], l) && wn(e, r, i); p < f;) {
                    for (wn(e, p, f), p++, f--; o(e[p], l) < 0;) p++;
                    for (; 0 < o(e[f], l);) f--
                }
                0 === o(e[r], l) ? wn(e, r, f) : wn(e, ++f, i), f <= n && (r = f + 1), n <= f && (i = f - 1)
            }
        }(a, u, e || 0, n || a.length - 1, c || bn), s.push(e, o, o, n));
        var a, u, c
    }

    function qn(t) {
        var e = In(t);
        return e.insert = function (t) {
            if (Array.isArray(t)) {
                var e = t;
                (t = Gn(e)).bbox = e
            } else t.bbox = t.bbox ? t.bbox : Bn(t);
            return In.prototype.insert.call(this, t)
        }, e.load = function (t) {
            var n = [];
            return Array.isArray(t) ? t.forEach(function (t) {
                var e = Gn(t);
                e.bbox = t, n.push(e)
            }) : L(t, function (t) {
                t.bbox = t.bbox ? t.bbox : Bn(t), n.push(t)
            }), In.prototype.load.call(this, n)
        }, e.remove = function (t) {
            if (Array.isArray(t)) {
                var e = t;
                (t = Gn(e)).bbox = e
            }
            return In.prototype.remove.call(this, t)
        }, e.clear = function () {
            return In.prototype.clear.call(this)
        }, e.search = function (t) {
            return {type: "FeatureCollection", features: In.prototype.search.call(this, this.toBBox(t))}
        }, e.collides = function (t) {
            return In.prototype.collides.call(this, this.toBBox(t))
        }, e.all = function () {
            return {type: "FeatureCollection", features: In.prototype.all.call(this)}
        }, e.toJSON = function () {
            return In.prototype.toJSON.call(this)
        }, e.fromJSON = function (t) {
            return In.prototype.fromJSON.call(this, t)
        }, e.toBBox = function (t) {
            var e;
            return {
                minX: (e = t.bbox ? t.bbox : Array.isArray(t) && 4 === t.length ? t : Bn(t))[0],
                minY: e[1],
                maxX: e[2],
                maxY: e[3]
            }
        }, e
    }

    function Gn(t) {
        var e = [t[0], t[1]], n = [t[0], t[3]], r = [t[2], t[3]];
        return {
            type: "Feature",
            bbox: t,
            properties: {},
            geometry: {type: "Polygon", coordinates: [[e, [t[2], t[1]], r, n, e]]}
        }
    }

    function Bn(t) {
        var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return N(t, function (t) {
            e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1])
        }), e
    }

    function kn(t) {
        if (!t) throw new Error("geojson is required");
        var e = [];
        return A(t, function (t) {
            !function (n, r) {
                var t = [], e = n.geometry;
                switch (e.type) {
                    case"Polygon":
                        t = Z(e);
                        break;
                    case"LineString":
                        t = [Z(e)]
                }
                t.forEach(function (t) {
                    var e, c, h;
                    (e = t, c = n.properties, h = [], e.reduce(function (t, e) {
                        var n, r, i, o, s, a, u = U([t, e], c);
                        return u.bbox = (r = e, i = (n = t)[0], o = n[1], [i < (s = r[0]) ? i : s, o < (a = r[1]) ? o : a, s < i ? i : s, a < o ? o : a]), h.push(u), e
                    }), h).forEach(function (t) {
                        t.id = r.length, r.push(t)
                    })
                })
            }(t, e)
        }), Y(e)
    }

    function zn(t, e) {
        var i = {}, o = [];
        if ("LineString" === t.type && (t = j(t)), "LineString" === e.type && (e = j(e)), "Feature" === t.type && "Feature" === e.type && "LineString" === t.geometry.type && "LineString" === e.geometry.type && 2 === t.geometry.coordinates.length && 2 === e.geometry.coordinates.length) {
            var n = jn(t, e);
            return n && o.push(n), Y(o)
        }
        var s = qn();
        return s.load(kn(e)), L(kn(t), function (r) {
            L(s.search(r), function (t) {
                var e = jn(r, t);
                if (e) {
                    var n = Z(e).join(",");
                    i[n] || (i[n] = !0, o.push(e))
                }
            })
        }), Y(o)
    }

    function jn(t, e) {
        var n = Z(t), r = Z(e);
        if (2 !== n.length) throw new Error("<intersects> line1 must only contain 2 coordinates");
        if (2 !== r.length) throw new Error("<intersects> line2 must only contain 2 coordinates");
        var i = n[0][0], o = n[0][1], s = n[1][0], a = n[1][1], u = r[0][0], c = r[0][1], h = r[1][0], l = r[1][1],
            p = (l - c) * (s - i) - (h - u) * (a - o);
        if (0 === p) return null;
        var f = ((h - u) * (o - c) - (l - c) * (i - u)) / p, g = ((s - i) * (o - c) - (a - o) * (i - u)) / p;
        return 0 <= f && f <= 1 && 0 <= g && g <= 1 ? X([i + f * (s - i), o + f * (a - o)]) : null
    }

    function Xn(t, p, f) {
        if (!H(f = f || {})) throw new Error("options is invalid");
        var e = t.geometry ? t.geometry.type : t.type;
        if ("LineString" !== e && "MultiLineString" !== e) throw new Error("lines must be LineString or MultiLineString");
        var g = X([1 / 0, 1 / 0], {dist: 1 / 0}), d = 0;
        return A(t, function (t) {
            for (var e = Z(t), n = 0; n < e.length - 1; n++) {
                var r = X(e[n]);
                r.properties.dist = he(p, r, f);
                var i = X(e[n + 1]);
                i.properties.dist = he(p, i, f);
                var o = he(r, i, f), s = Math.max(r.properties.dist, i.properties.dist), a = Ye(r, i),
                    u = Xe(p, s, a + 90, f), c = Xe(p, s, a - 90, f),
                    h = zn(U([u.geometry.coordinates, c.geometry.coordinates]), U([r.geometry.coordinates, i.geometry.coordinates])),
                    l = null;
                0 < h.features.length && ((l = h.features[0]).properties.dist = he(p, l, f), l.properties.location = d + he(r, l, f)), r.properties.dist < g.properties.dist && ((g = r).properties.index = n, g.properties.location = d), i.properties.dist < g.properties.dist && ((g = i).properties.index = n + 1, g.properties.location = d + o), l && l.properties.dist < g.properties.dist && ((g = l).properties.index = n), d += o
            }
        }), g
    }

    function Un(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r, i = n.final;
        if (!t) throw new Error("start point is required");
        if (!e) throw new Error("end point is required");
        return 180 < (r = i ? Yn(J(e), J(t)) : Yn(J(t), J(e))) ? -(360 - r) : r
    }

    function Yn(t, e) {
        var n = m(t[1]), r = m(e[1]), i = m(e[0] - t[0]);
        i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI);
        var o = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4));
        return (y(Math.atan2(i, o)) + 360) % 360
    }

    function Vn(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.units;
        if (!t) throw new Error("from point is required");
        if (!e) throw new Error("to point is required");
        var i = J(t), o = J(e);
        return o[0] += 180 < o[0] - i[0] ? -360 : 180 < i[0] - o[0] ? 360 : 0, _(function (t, e, n) {
            var r = n = void 0 === n ? f : Number(n), i = t[1] * Math.PI / 180, o = e[1] * Math.PI / 180, s = o - i,
                a = Math.abs(e[0] - t[0]) * Math.PI / 180;
            a > Math.PI && (a -= 2 * Math.PI);
            var u = Math.log(Math.tan(o / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)),
                c = 1e-11 < Math.abs(u) ? s / u : Math.cos(i);
            return Math.sqrt(s * s + c * c * a * a) * r
        }(i, o), "meters", r)
    }

    function Hn(t, e) {
        return Jn(t, "mercator", e)
    }

    function Wn(t, e) {
        return Jn(t, "wgs84", e)
    }

    function Jn(t, n, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var r = e.mutate;
        if (!t) throw new Error("geojson is required");
        return Array.isArray(t) && V(t[0]) ? t = "mercator" === n ? Zn(t) : Kn(t) : (!0 !== r && (t = le(t)), N(t, function (t) {
            var e = "mercator" === n ? Zn(t) : Kn(t);
            t[0] = e[0], t[1] = e[1]
        })), t
    }

    function Zn(t) {
        var e, n = Math.PI / 180, r = 20037508.342789244,
            i = [6378137 * (Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * ((e = t[0]) < 0 ? -1 : 0 < e ? 1 : 0)) * n, 6378137 * Math.log(Math.tan(.25 * Math.PI + .5 * t[1] * n))];
        return i[0] > r && (i[0] = r), i[0] < -r && (i[0] = -r), i[1] > r && (i[1] = r), i[1] < -r && (i[1] = -r), i
    }

    function Kn(t) {
        var e = 180 / Math.PI;
        return [t[0] * e / 6378137, (.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / 6378137))) * e]
    }

    Ke.deviation = function (t, e, n, r) {
        var i = e && e.length, o = i ? e[0] * n : t.length, s = Math.abs(vn(t, 0, o, n));
        if (i) for (var a = 0, u = e.length; a < u; a++) {
            var c = e[a] * n, h = a < u - 1 ? e[a + 1] * n : t.length;
            s -= Math.abs(vn(t, c, h, n))
        }
        var l = 0;
        for (a = 0; a < r.length; a += 3) {
            var p = r[a] * n, f = r[a + 1] * n, g = r[a + 2] * n;
            l += Math.abs((t[p] - t[g]) * (t[f + 1] - t[p + 1]) - (t[p] - t[f]) * (t[g + 1] - t[p + 1]))
        }
        return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s)
    }, Ke.flatten = function (t) {
        for (var e = t[0][0].length, n = {vertices: [], holes: [], dimensions: e}, r = 0, i = 0; i < t.length; i++) {
            for (var o = 0; o < t[i].length; o++) for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);
            0 < i && (r += t[i - 1].length, n.holes.push(r))
        }
        return n
    }, Je.default = Ze, In.prototype = {
        all: function () {
            return this._all(this.data, [])
        }, search: function (t) {
            var e = this.data, n = [], r = this.toBBox;
            if (!An(t, e)) return n;
            for (var i, o, s, a, u = []; e;) {
                for (i = 0, o = e.children.length; i < o; i++) s = e.children[i], An(t, a = e.leaf ? r(s) : s) && (e.leaf ? n.push(s) : Tn(t, a) ? this._all(s, n) : u.push(s));
                e = u.pop()
            }
            return n
        }, collides: function (t) {
            var e = this.data, n = this.toBBox;
            if (!An(t, e)) return !1;
            for (var r, i, o, s, a = []; e;) {
                for (r = 0, i = e.children.length; r < i; r++) if (o = e.children[r], An(t, s = e.leaf ? n(o) : o)) {
                    if (e.leaf || Tn(t, s)) return !0;
                    a.push(o)
                }
                e = a.pop()
            }
            return !1
        }, load: function (t) {
            if (!t || !t.length) return this;
            if (t.length < this._minEntries) {
                for (var e = 0, n = t.length; e < n; e++) this.insert(t[e]);
                return this
            }
            var r = this._build(t.slice(), 0, t.length - 1, 0);
            if (this.data.children.length) if (this.data.height === r.height) this._splitRoot(this.data, r); else {
                if (this.data.height < r.height) {
                    var i = this.data;
                    this.data = r, r = i
                }
                this._insert(r, this.data.height - r.height - 1, !0)
            } else this.data = r;
            return this
        }, insert: function (t) {
            return t && this._insert(t, this.data.height - 1), this
        }, clear: function () {
            return this.data = Dn([]), this
        }, remove: function (t, e) {
            if (!t) return this;
            for (var n, r, i, o, s = this.data, a = this.toBBox(t), u = [], c = []; s || u.length;) {
                if (s || (s = u.pop(), r = u[u.length - 1], n = c.pop(), o = !0), s.leaf && -1 !== (i = Nn(t, s.children, e))) return s.children.splice(i, 1), u.push(s), this._condense(u), this;
                o || s.leaf || !Tn(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), c.push(n), n = 0, s = (r = s).children[0])
            }
            return this
        }, toBBox: function (t) {
            return t
        }, compareMinX: Ln, compareMinY: Pn, toJSON: function () {
            return this.data
        }, fromJSON: function (t) {
            return this.data = t, this
        }, _all: function (t, e) {
            for (var n = []; t;) t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop();
            return e
        }, _build: function (t, e, n, r) {
            var i, o = n - e + 1, s = this._maxEntries;
            if (o <= s) return Cn(i = Dn(t.slice(e, n + 1)), this.toBBox), i;
            r || (r = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, r - 1))), (i = Dn([])).leaf = !1, i.height = r;
            var a, u, c, h, l = Math.ceil(o / s), p = l * Math.ceil(Math.sqrt(s));
            for (Fn(t, e, n, p, this.compareMinX), a = e; a <= n; a += p) for (Fn(t, a, c = Math.min(a + p - 1, n), l, this.compareMinY), u = a; u <= c; u += l) h = Math.min(u + l - 1, c), i.children.push(this._build(t, u, h, r - 1));
            return Cn(i, this.toBBox), i
        }, _chooseSubtree: function (t, e, n, r) {
            for (var i, o, s, a, u, c, h, l, p, f; r.push(e), !e.leaf && r.length - 1 !== n;) {
                for (h = l = 1 / 0, i = 0, o = e.children.length; i < o; i++) u = On(s = e.children[i]), p = t, f = s, (c = (Math.max(f.maxX, p.maxX) - Math.min(f.minX, p.minX)) * (Math.max(f.maxY, p.maxY) - Math.min(f.minY, p.minY)) - u) < l ? (l = c, h = u < h ? u : h, a = s) : c === l && u < h && (h = u, a = s);
                e = a || e.children[0]
            }
            return e
        }, _insert: function (t, e, n) {
            var r = this.toBBox, i = n ? t : r(t), o = [], s = this._chooseSubtree(i, this.data, e, o);
            for (s.children.push(t), Mn(s, i); 0 <= e && o[e].children.length > this._maxEntries;) this._split(o, e), e--;
            this._adjustParentBBoxes(i, o, e)
        }, _split: function (t, e) {
            var n = t[e], r = n.children.length, i = this._minEntries;
            this._chooseSplitAxis(n, i, r);
            var o = this._chooseSplitIndex(n, i, r), s = Dn(n.children.splice(o, n.children.length - o));
            s.height = n.height, s.leaf = n.leaf, Cn(n, this.toBBox), Cn(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(n, s)
        }, _splitRoot: function (t, e) {
            this.data = Dn([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Cn(this.data, this.toBBox)
        }, _chooseSplitIndex: function (t, e, n) {
            var r, i, o, s, a, u, c, h, l, p, f, g, d, y;
            for (u = c = 1 / 0, r = e; r <= n - e; r++) l = i = Sn(t, 0, r, this.toBBox), p = o = Sn(t, r, n, this.toBBox), f = Math.max(l.minX, p.minX), g = Math.max(l.minY, p.minY), d = Math.min(l.maxX, p.maxX), y = Math.min(l.maxY, p.maxY), s = Math.max(0, d - f) * Math.max(0, y - g), a = On(i) + On(o), s < u ? (u = s, h = r, c = a < c ? a : c) : s === u && a < c && (c = a, h = r);
            return h
        }, _chooseSplitAxis: function (t, e, n) {
            var r = t.leaf ? this.compareMinX : Ln, i = t.leaf ? this.compareMinY : Pn;
            this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r)
        }, _allDistMargin: function (t, e, n, r) {
            t.children.sort(r);
            var i, o, s = this.toBBox, a = Sn(t, 0, e, s), u = Sn(t, n - e, n, s), c = Rn(a) + Rn(u);
            for (i = e; i < n - e; i++) o = t.children[i], Mn(a, t.leaf ? s(o) : o), c += Rn(a);
            for (i = n - e - 1; e <= i; i--) o = t.children[i], Mn(u, t.leaf ? s(o) : o), c += Rn(u);
            return c
        }, _adjustParentBBoxes: function (t, e, n) {
            for (var r = n; 0 <= r; r--) Mn(e[r], t)
        }, _condense: function (t) {
            for (var e, n = t.length - 1; 0 <= n; n--) 0 === t[n].children.length ? 0 < n ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : Cn(t[n], this.toBBox)
        }, _initFormat: function (t) {
            var e = ["return a", " - b", ";"];
            this.compareMinX = new Function("a", "b", e.join(t[0])), this.compareMinY = new Function("a", "b", e.join(t[1])), this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};")
        }
    };
    var Qn = Object.freeze({toMercator: Hn, toWgs84: Wn});

    function $n(t, e, i) {
        if (!H(i = i || {})) throw new Error("options is invalid");
        if (!t) throw new Error("pt is required");
        if (Array.isArray(t) ? t = X(t) : "Point" === t.type ? t = j(t) : $(t, "Point", "point"), !e) throw new Error("line is required");
        Array.isArray(e) ? e = U(e) : "LineString" === e.type ? e = j(e) : $(e, "LineString", "line");
        var o = 1 / 0, s = t.geometry.coordinates;
        return F(e, function (t) {
            var e = t.geometry.coordinates[0], n = t.geometry.coordinates[1], r = function (t, e, n, r) {
                var i = r.mercator, o = !0 !== i ? he(e, t, r) : tr(e, t, r), s = p(!0 !== i ? Ye(e, t) : Un(e, t)),
                    a = p(!0 !== i ? Ye(e, n) : Un(e, n)), u = Math.abs(s - a);
                if (90 < u) return o;
                var c = (a + 180) % 360, h = p(!0 !== i ? Ye(n, t) : Un(n, t)), l = Math.abs(h - c);
                return 180 < l && (l = Math.abs(l - 360)), 90 < l ? !0 !== i ? he(t, n, r) : tr(t, n, r) : !0 !== i ? o * Math.sin(m(u)) : function (t, e, n, r) {
                    var i = 0;
                    (180 <= Math.abs(t[0]) || 180 <= Math.abs(e[0]) || 180 <= Math.abs(n[0])) && (i = 0 < t[0] || 0 < e[0] || 0 < n[0] ? -180 : 180);
                    var o, s, a, u, c, h, l, p, f, g, d = X(n), y = Hn([t[0] + i, t[1]]),
                        _ = Wn((s = Hn([e[0] + i, e[1]]), a = Hn([n[0] + i, n[1]]), u = (o = y)[0], c = o[1], h = s[0], l = s[1], [u + (g = ((a[0] - u) * (p = h - u) + (a[1] - c) * (f = l - c)) / (p * p + f * f)) * p, c + g * f]));
                    return 0 !== i && (_[0] -= i), Vn(d, _, r)
                }(e, n, t, r)
            }(s, e, n, i);
            r < o && (o = r)
        }), o
    }

    function tr(t, e, n) {
        var r = n.units, i = 0;
        180 <= Math.abs(t[0]) && (i = 0 < t[0] ? -180 : 180), 180 <= Math.abs(e[0]) && (i = 0 < e[0] ? -180 : 180);
        var o = Hn([t[0] + i, t[1]]), s = Hn([e[0] + i, e[1]]), a = function (t) {
            return t * t
        }, u = a(o[0] - s[0]) + a(o[1] - s[1]);
        return _(Math.sqrt(u), "meters", r)
    }

    function er(t) {
        for (var e, n = "FeatureCollection" === (e = t).type ? e : "Feature" === e.type ? Y([e]) : Y([j(e)]), r = Ve(n), i = !1, o = 0; !i && o < n.features.length;) {
            var s, a = n.features[o].geometry, u = !1;
            if ("Point" === a.type) r.geometry.coordinates[0] === a.coordinates[0] && r.geometry.coordinates[1] === a.coordinates[1] && (i = !0); else if ("MultiPoint" === a.type) {
                var c = !1;
                for (s = 0; !c && s < a.coordinates.length;) r.geometry.coordinates[0] === a.coordinates[s][0] && r.geometry.coordinates[1] === a.coordinates[s][1] && (c = i = !0), s++
            } else if ("LineString" === a.type) for (s = 0; !u && s < a.coordinates.length - 1;) nr(r.geometry.coordinates[0], r.geometry.coordinates[1], a.coordinates[s][0], a.coordinates[s][1], a.coordinates[s + 1][0], a.coordinates[s + 1][1]) && (i = u = !0), s++; else if ("MultiLineString" === a.type) for (var h = 0; h < a.coordinates.length;) {
                u = !1, s = 0;
                for (var l = a.coordinates[h]; !u && s < l.length - 1;) nr(r.geometry.coordinates[0], r.geometry.coordinates[1], l[s][0], l[s][1], l[s + 1][0], l[s + 1][1]) && (i = u = !0), s++;
                h++
            } else "Polygon" !== a.type && "MultiPolygon" !== a.type || re(r, a) && (i = !0);
            o++
        }
        if (i) return r;
        var p = Y([]);
        for (o = 0; o < n.features.length; o++) p.features = p.features.concat(We(n.features[o]).features);
        return X(En(r, p).geometry.coordinates)
    }

    function nr(t, e, n, r, i, o) {
        return Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) === Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e))
    }

    function rr(t) {
        return T(t, function (t, e) {
            return t + function t(e) {
                var n, r = 0;
                switch (e.type) {
                    case"Polygon":
                        return or(e.coordinates);
                    case"MultiPolygon":
                        for (n = 0; n < e.coordinates.length; n++) r += or(e.coordinates[n]);
                        return r;
                    case"Point":
                    case"MultiPoint":
                    case"LineString":
                    case"MultiLineString":
                        return 0;
                    case"GeometryCollection":
                        for (n = 0; n < e.geometries.length; n++) r += t(e.geometries[n]);
                        return r
                }
            }(e)
        }, 0)
    }

    var ir = 6378137;

    function or(t) {
        var e = 0;
        if (t && 0 < t.length) {
            e += Math.abs(sr(t[0]));
            for (var n = 1; n < t.length; n++) e -= Math.abs(sr(t[n]))
        }
        return e
    }

    function sr(t) {
        var e, n, r, i, o, s, a = 0, u = t.length;
        if (2 < u) {
            for (s = 0; s < u; s++) o = s === u - 2 ? (r = u - 2, i = u - 1, 0) : s === u - 1 ? (r = u - 1, i = 0, 1) : (i = (r = s) + 1, s + 2), e = t[r], n = t[i], a += (ar(t[o][0]) - ar(e[0])) * Math.sin(ar(n[1]));
            a = a * ir * ir / 2
        }
        return a
    }

    function ar(t) {
        return t * Math.PI / 180
    }

    function ur(t, r) {
        if (!H(r = r || {})) throw new Error("options is invalid");
        if (!t) throw new Error("geojson is required");
        return q(t, function (t, e) {
            var n = e.geometry.coordinates;
            return t + he(n[0], n[1], r)
        }, 0)
    }

    function cr(t, e, n, r) {
        if (!H(r = r || {})) throw new Error("options is invalid");
        var i, o = [];
        if ("Feature" === t.type) i = t.geometry.coordinates; else {
            if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
            i = t.coordinates
        }
        for (var s, a, u, c = 0, h = 0; h < i.length && !(c <= e && h === i.length - 1); h++) {
            if (e < c && 0 === o.length) {
                if (!(s = e - c)) return o.push(i[h]), U(o);
                a = Ye(i[h], i[h - 1]) - 180, u = Xe(i[h], s, a, r), o.push(u.geometry.coordinates)
            }
            if (n <= c) return (s = n - c) ? (a = Ye(i[h], i[h - 1]) - 180, u = Xe(i[h], s, a, r), o.push(u.geometry.coordinates)) : o.push(i[h]), U(o);
            if (e <= c && o.push(i[h]), h === i.length - 1) return U(o);
            c += he(i[h], i[h + 1], r)
        }
        return U(i[i.length - 1])
    }

    function hr(t, e, n) {
        var r, i, o, s, a, u, c, h, l, p, f, g, d = (n = n || {}).ignoreEndVertices;
        if (!H(n)) throw new Error("invalid options");
        if (!t) throw new Error("pt is required");
        if (!e) throw new Error("line is required");
        for (var y = J(t), _ = Z(e), m = 0; m < _.length - 1; m++) {
            var v = !1;
            if (d && (0 === m && (v = "start"), m === _.length - 2 && (v = "end"), 0 === m && m + 1 === _.length - 1 && (v = "both")), r = _[m], i = _[m + 1], s = v, void 0, a = (o = y)[0], u = o[1], c = r[0], h = r[1], l = i[0], p = i[1], f = l - c, g = p - h, 0 == (o[0] - c) * g - (o[1] - h) * f && (s ? "start" === s ? Math.abs(f) >= Math.abs(g) ? 0 < f ? c < a && a <= l : l <= a && a < c : 0 < g ? h < u && u <= p : p <= u && u < h : "end" === s ? Math.abs(f) >= Math.abs(g) ? 0 < f ? c <= a && a < l : l < a && a <= c : 0 < g ? h <= u && u < p : p < u && u <= h : "both" === s ? Math.abs(f) >= Math.abs(g) ? 0 < f ? c < a && a < l : l < a && a < c : 0 < g ? h < u && u < p : p < u && u < h : void 0 : Math.abs(f) >= Math.abs(g) ? 0 < f ? c <= a && a <= l : l <= a && a <= c : 0 < g ? h <= u && u <= p : p <= u && u <= h)) return !0
        }
        return !1
    }

    function lr(t, e) {
        var n = rt(t), r = rt(e), i = et(t), o = et(e);
        switch (n) {
            case"Point":
                switch (r) {
                    case"MultiPoint":
                        return function (t, e) {
                            var n, r = !1;
                            for (n = 0; n < e.coordinates.length; n++) if (fr(e.coordinates[n], t.coordinates)) {
                                r = !0;
                                break
                            }
                            return r
                        }(i, o);
                    case"LineString":
                        return hr(i, o, {ignoreEndVertices: !0});
                    case"Polygon":
                        return re(i, o, {ignoreBoundary: !0});
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"MultiPoint":
                switch (r) {
                    case"MultiPoint":
                        return function (t, e) {
                            for (var n = 0; n < t.coordinates.length; n++) {
                                for (var r = !1, i = 0; i < e.coordinates.length; i++) fr(t.coordinates[n], e.coordinates[i]) && (r = !0);
                                if (!r) return !1
                            }
                            return !0
                        }(i, o);
                    case"LineString":
                        return function (t, e) {
                            for (var n = !1, r = 0; r < t.coordinates.length; r++) {
                                if (!hr(t.coordinates[r], e)) return !1;
                                n || (n = hr(t.coordinates[r], e, {ignoreEndVertices: !0}))
                            }
                            return n
                        }(i, o);
                    case"Polygon":
                        return function (t, e) {
                            for (var n = !0, r = 0; r < t.coordinates.length; r++) {
                                var i = re(t.coordinates[1], e);
                                if (!i) {
                                    n = !1;
                                    break
                                }
                                i = re(t.coordinates[1], e, {ignoreBoundary: !0})
                            }
                            return n && i
                        }(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"LineString":
                switch (r) {
                    case"LineString":
                        return function (t, e) {
                            for (var n = 0; n < t.coordinates.length; n++) if (!hr(t.coordinates[n], e)) return !1;
                            return !0
                        }(i, o);
                    case"Polygon":
                        return function (t, e) {
                            var n, r;
                            if (!pr(W(e), W(t))) return !1;
                            for (var i = !1, o = 0; o < t.coordinates.length - 1; o++) {
                                if (!re(t.coordinates[o], e)) return !1;
                                if (i || (i = re(t.coordinates[o], e, {ignoreBoundary: !0})), !i) i = re((n = t.coordinates[o], r = t.coordinates[o + 1], [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2]), e, {ignoreBoundary: !0})
                            }
                            return i
                        }(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"Polygon":
                switch (r) {
                    case"Polygon":
                        return function (t, e) {
                            var n = W(t);
                            if (!pr(W(e), n)) return !1;
                            for (var r = 0; r < t.coordinates[0].length; r++) if (!re(t.coordinates[0][r], e)) return !1;
                            return !0
                        }(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + n + " geometry not supported")
        }
    }

    function pr(t, e) {
        return !(t[0] > e[0] || t[2] < e[2] || t[1] > e[1] || t[3] < e[3])
    }

    function fr(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function gr(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.mask, i = n.properties, o = [];
        if (null == e) throw new Error("cellSide is required");
        if (!V(e)) throw new Error("cellSide is invalid");
        if (!t) throw new Error("bbox is required");
        if (!Array.isArray(t)) throw new Error("bbox must be array");
        if (4 !== t.length) throw new Error("bbox must contain 4 numbers");
        if (r && -1 === ["Polygon", "MultiPolygon"].indexOf(rt(r))) throw new Error("options.mask must be a (Multi)Polygon");
        for (var s = t[0], a = t[1], u = t[2], c = t[3], h = e / he([s, a], [u, a], n) * (u - s), l = e / he([s, a], [s, c], n) * (c - a), p = u - s, f = c - a, g = Math.floor(p / h), d = (f - Math.floor(f / l) * l) / 2, y = s + (p - g * h) / 2; y <= u;) {
            for (var _ = a + d; _ <= c;) {
                var m = X([y, _], i);
                r ? lr(m, r) && o.push(m) : o.push(m), _ += l
            }
            y += h
        }
        return Y(o)
    }

    function dr(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.precision, r = e.coordinates, i = e.mutate;
        if (n = null == n || isNaN(n) ? 6 : n, r = null == r || isNaN(r) ? 3 : r, !t) throw new Error("<geojson> is required");
        if ("number" != typeof n) throw new Error("<precision> must be a number");
        if ("number" != typeof r) throw new Error("<coordinates> must be a number");
        !1 !== i && void 0 !== i || (t = JSON.parse(JSON.stringify(t)));
        var o = Math.pow(10, n);
        return N(t, function (t) {
            !function (t, e, n) {
                t.length > n && t.splice(n, t.length);
                for (var r = 0; r < t.length; r++) t[r] = Math.round(t[r] * e) / e
            }(t, o, r)
        }), t
    }

    function yr(t, e) {
        if (!t || !e) return !1;
        if (t.length !== e.length) return !1;
        for (var n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) {
            if (!yr(t[n], e[n])) return !1
        } else if (t[n] !== e[n]) return !1;
        return !0
    }

    var _r = function (t, e, n, r, i) {
        this.coord = t, this.param = e, this.ringAndEdgeIn = n, this.ringAndEdgeOut = r, this.nxtIsectAlongEdgeIn = i
    }, mr = function (t, e, n, r, i, o, s) {
        this.coord = t, this.ringAndEdge1 = e, this.ringAndEdge2 = n, this.nxtIsectAlongRingAndEdge1 = r, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = o, this.ringAndEdge2Walkable = s
    };

    function vr(t, e) {
        if (void 0 === e && (e = !0), 3 != t.length) throw new Error("This function requires an array of three points [x,y]");
        return 0 <= (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) == e
    }

    function xr(t) {
        for (var e = 0, n = 0; n < t.length - 1; n++) t[n][0] < t[e][0] && (e = n);
        if (vr([t[(e - 1).modulo(t.length - 1)], t[e], t[(e + 1).modulo(t.length - 1)]], !0)) var r = 1; else r = -1;
        return r
    }

    function Er(t, e) {
        if (!t || !e) return !1;
        if (t.length != e.length) return !1;
        for (var n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) {
            if (!Er(t[n], e[n])) return !1
        } else if (t[n] != e[n]) return !1;
        return !0
    }

    Number.prototype.modulo = function (t) {
        return (this % t + t) % t
    };
    var wr = Math.PI / 180, br = 180 / Math.PI, Ir = function (t, e) {
        this.lon = t, this.lat = e, this.x = wr * t, this.y = wr * e
    };
    Ir.prototype.view = function () {
        return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4)
    }, Ir.prototype.antipode = function () {
        var t = -1 * this.lat, e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon);
        return new Ir(e, t)
    };
    var Nr = function () {
        this.coords = [], this.length = 0
    };
    Nr.prototype.move_to = function (t) {
        this.length++, this.coords.push(t)
    };
    var Cr = function (t) {
        this.properties = t || {}, this.geometries = []
    };
    Cr.prototype.json = function () {
        if (this.geometries.length <= 0) return {
            geometry: {type: "LineString", coordinates: null},
            type: "Feature",
            properties: this.properties
        };
        if (1 === this.geometries.length) return {
            geometry: {
                type: "LineString",
                coordinates: this.geometries[0].coords
            }, type: "Feature", properties: this.properties
        };
        for (var t = [], e = 0; e < this.geometries.length; e++) t.push(this.geometries[e].coords);
        return {geometry: {type: "MultiLineString", coordinates: t}, type: "Feature", properties: this.properties}
    }, Cr.prototype.wkt = function () {
        for (var t = "", e = "LINESTRING(", n = function (t) {
            e += t[0] + " " + t[1] + ","
        }, r = 0; r < this.geometries.length; r++) {
            if (0 === this.geometries[r].coords.length) return "LINESTRING(empty)";
            this.geometries[r].coords.forEach(n), t += e.substring(0, e.length - 1) + ")"
        }
        return t
    };
    var Sr = function (t, e, n) {
        if (!t || void 0 === t.x || void 0 === t.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
        if (!e || void 0 === e.x || void 0 === e.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
        this.start = new Ir(t.x, t.y), this.end = new Ir(e.x, e.y), this.properties = n || {};
        var r = this.start.x - this.end.x, i = this.start.y - this.end.y,
            o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2);
        if (this.g = 2 * Math.asin(Math.sqrt(o)), this.g === Math.PI) throw new Error("it appears " + t.view() + " and " + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
        if (isNaN(this.g)) throw new Error("could not calculate great circle between " + t + " and " + e)
    };

    function Mr(r, t) {
        var i = [], o = qn();
        return A(t, function (t) {
            if (i.forEach(function (t, e) {
                t.id = e
            }), i.length) {
                var e = o.search(t);
                if (e.features.length) {
                    var n = Pr(t, e);
                    i = i.filter(function (t) {
                        return t.id !== n.id
                    }), o.remove(n), L(Lr(n, t), function (t) {
                        i.push(t), o.insert(t)
                    })
                }
            } else (i = Lr(r, t).features).forEach(function (t) {
                t.bbox || (t.bbox = je(W(t)))
            }), o.load(Y(i))
        }), Y(i)
    }

    function Lr(t, o) {
        var s = [], e = Z(t)[0], n = Z(t)[t.geometry.coordinates.length - 1];
        if (Or(e, J(o)) || Or(n, J(o))) return Y([t]);
        var r = qn(), i = kn(t);
        r.load(i);
        var a = r.search(o);
        if (!a.features.length) return Y([t]);
        var u = Pr(o, a), c = P(i, function (t, e, n) {
            var r = Z(e)[1], i = J(o);
            return n === u.id ? (t.push(i), s.push(U(t)), Or(i, r) ? [i] : [i, r]) : (t.push(r), t)
        }, [e]);
        return 1 < c.length && s.push(U(c)), Y(s)
    }

    function Pr(n, t) {
        if (!t.features.length) throw new Error("lines must contain features");
        if (1 === t.features.length) return t.features[0];
        var r, i = 1 / 0;
        return L(t, function (t) {
            var e = Xn(t, n).properties.dist;
            e < i && (r = t, i = e)
        }), r
    }

    function Or(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function Rr(t, e, n, r, i) {
        if (!H(i = i || {})) throw new Error("options is invalid");
        var o = i.steps, s = i.units;
        if (!t) throw new Error("center is required");
        if (!e) throw new Error("radius is required");
        if (null == n) throw new Error("bearing1 is required");
        if (null == r) throw new Error("bearing2 is required");
        if ("object" != typeof i) throw new Error("options must be an object");
        o = o || 64;
        var a = Tr(n), u = Tr(r), c = t.properties;
        if (a === u) return U(Ue(t, e, i).geometry.coordinates[0], c);
        for (var h = a, l = a < u ? u : u + 360, p = h, f = [], g = 0; p < l;) f.push(Xe(t, e, p, s).geometry.coordinates), p = h + 360 * ++g / o;
        return l < p && f.push(Xe(t, e, l, s).geometry.coordinates), U(f, c)
    }

    function Tr(t) {
        var e = t % 360;
        return e < 0 && (e += 360), e
    }

    function Ar(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.properties, r = rt(t), i = Z(t);
        if (n = n || t.properties || {}, !i.length) throw new Error("polygon must contain coordinates");
        switch (r) {
            case"Polygon":
                return Dr(i, n);
            case"MultiPolygon":
                var o = [];
                return i.forEach(function (t) {
                    o.push(Dr(t, n))
                }), Y(o);
            default:
                throw new Error("geom " + r + " not supported")
        }
    }

    function Dr(t, e) {
        return 1 < t.length ? v(t, e) : U(t[0], e)
    }

    function Fr(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.properties, r = e.autoComplete, i = e.orderCoords;
        if (!t) throw new Error("lines is required");
        switch (r = void 0 === r || r, i = void 0 === i || i, rt(t)) {
            case"FeatureCollection":
            case"GeometryCollection":
                var o = [];
                return (t.features ? t.features : t.geometries).forEach(function (t) {
                    o.push(Z(qr(t, {}, r, i)))
                }), x(o, n)
        }
        return qr(t, n, r, i)
    }

    function qr(t, e, a, u) {
        e = e || t.properties || {};
        var n = Z(t), r = rt(t);
        if (!n.length) throw new Error("line must contain coordinates");
        switch (r) {
            case"LineString":
                return a && (n = Gr(n)), B([n], e);
            case"MultiLineString":
                var c = [], h = 0;
                return n.forEach(function (t) {
                    if (a && (t = Gr(t)), u) {
                        var e = (r = (n = W(U(t)))[0], i = n[1], o = n[2], s = n[3], Math.abs(r - o) * Math.abs(i - s));
                        h < e ? (c.unshift(t), h = e) : c.push(t)
                    } else c.push(t);
                    var n, r, i, o, s
                }), B(c, e);
            default:
                throw new Error("geometry type " + r + " is not supported")
        }
    }

    function Gr(t) {
        var e = t[0], n = e[0], r = e[1], i = t[t.length - 1], o = i[0], s = i[1];
        return n === o && r === s || t.push(e), t
    }

    Sr.prototype.interpolate = function (t) {
        var e = Math.sin((1 - t) * this.g) / Math.sin(this.g), n = Math.sin(t * this.g) / Math.sin(this.g),
            r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x),
            i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x),
            o = e * Math.sin(this.start.y) + n * Math.sin(this.end.y),
            s = br * Math.atan2(o, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2)));
        return [br * Math.atan2(i, r), s]
    }, Sr.prototype.Arc = function (t, e) {
        var n = [];
        if (!t || t <= 2) n.push([this.start.lon, this.start.lat]), n.push([this.end.lon, this.end.lat]); else for (var r = 1 / (t - 1), i = 0; i < t; ++i) {
            var o = r * i, s = this.interpolate(o);
            n.push(s)
        }
        for (var a = !1, u = 0, c = e && e.offset ? e.offset : 10, h = 180 - c, l = -180 + c, p = 360 - c, f = 1; f < n.length; ++f) {
            var g = n[f - 1][0], d = n[f][0], y = Math.abs(d - g);
            p < y && (h < d && g < l || h < g && d < l) ? a = !0 : u < y && (u = y)
        }
        var _ = [];
        if (a && u < c) {
            var m = [];
            _.push(m);
            for (var v = 0; v < n.length; ++v) {
                var x = parseFloat(n[v][0]);
                if (0 < v && Math.abs(x - n[v - 1][0]) > p) {
                    var E = parseFloat(n[v - 1][0]), w = parseFloat(n[v - 1][1]), b = parseFloat(n[v][0]),
                        I = parseFloat(n[v][1]);
                    if (-180 < E && E < l && 180 === b && v + 1 < n.length && -180 < n[v - 1][0] && n[v - 1][0] < l) {
                        m.push([-180, n[v][1]]), v++, m.push([n[v][0], n[v][1]]);
                        continue
                    }
                    if (h < E && E < 180 && -180 === b && v + 1 < n.length && n[v - 1][0] > h && n[v - 1][0] < 180) {
                        m.push([180, n[v][1]]), v++, m.push([n[v][0], n[v][1]]);
                        continue
                    }
                    if (E < l && h < b) {
                        var N = E;
                        E = b, b = N;
                        var C = w;
                        w = I, I = C
                    }
                    if (h < E && b < l && (b += 360), E <= 180 && 180 <= b && E < b) {
                        var S = (180 - E) / (b - E), M = S * I + (1 - S) * w;
                        m.push([n[v - 1][0] > h ? 180 : -180, M]), (m = []).push([n[v - 1][0] > h ? -180 : 180, M]), _.push(m)
                    } else m = [], _.push(m);
                    m.push([x, n[v][1]])
                } else m.push([n[v][0], n[v][1]])
            }
        } else {
            var L = [];
            _.push(L);
            for (var P = 0; P < n.length; ++P) L.push([n[P][0], n[P][1]])
        }
        for (var O = new Cr(this.properties), R = 0; R < _.length; ++R) {
            var T = new Nr;
            O.geometries.push(T);
            for (var A = _[R], D = 0; D < A.length; ++D) T.move_to(A[D])
        }
        return O
    };
    var Br = kr;

    function kr(t, e, n) {
        var r, i, o, s, a, u = t.length, c = jr(t[0], e), h = [];
        for (n || (n = []), r = 1; r < u; r++) {
            for (i = t[r - 1], s = a = jr(o = t[r], e); ;) {
                if (!(c | s)) {
                    h.push(i), s !== a ? (h.push(o), r < u - 1 && (n.push(h), h = [])) : r === u - 1 && h.push(o);
                    break
                }
                if (c & s) break;
                c ? c = jr(i = zr(i, o, c, e), e) : s = jr(o = zr(i, o, s, e), e)
            }
            c = a
        }
        return h.length && n.push(h), n
    }

    function zr(t, e, n, r) {
        return 8 & n ? [t[0] + (e[0] - t[0]) * (r[3] - t[1]) / (e[1] - t[1]), r[3]] : 4 & n ? [t[0] + (e[0] - t[0]) * (r[1] - t[1]) / (e[1] - t[1]), r[1]] : 2 & n ? [r[2], t[1] + (e[1] - t[1]) * (r[2] - t[0]) / (e[0] - t[0])] : 1 & n ? [r[0], t[1] + (e[1] - t[1]) * (r[0] - t[0]) / (e[0] - t[0])] : null
    }

    function jr(t, e) {
        var n = 0;
        return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n
    }

    function Xr(t, e) {
        for (var n = [], r = 0; r < t.length; r++) {
            var i = Br.polygon(t[r], e);
            0 < i.length && (i[0][0] === i[i.length - 1][0] && i[0][1] === i[i.length - 1][1] || i.push(i[0]), 4 <= i.length && n.push(i))
        }
        return n
    }

    (kr.polyline = kr).polygon = function (t, e) {
        var n, r, i, o, s, a, u;
        for (r = 1; r <= 8; r *= 2) {
            for (n = [], o = !(jr(i = t[t.length - 1], e) & r), s = 0; s < t.length; s++) (u = !(jr(a = t[s], e) & r)) !== o && n.push(zr(i, a, r, e)), u && n.push(a), i = a, o = u;
            if (!(t = n).length) break
        }
        return n
    };
    var Ur = Array.prototype.slice;

    function Yr(t) {
        return "[object Arguments]" === Object.prototype.toString.call(t)
    }

    function Vr(t, e, n) {
        return n || (n = {}), t === e || (t instanceof Date && e instanceof Date ? t.getTime() === e.getTime() : !t || !e || "object" != typeof t && "object" != typeof e ? (n.strict, t === e) : function (t, e, n) {
            var r, i;
            if (Hr(t) || Hr(e)) return !1;
            if (t.prototype !== e.prototype) return !1;
            if (Yr(t)) return !!Yr(e) && Vr(t = Ur.call(t), e = Ur.call(e), n);
            if (Wr(t)) {
                if (!Wr(e)) return !1;
                if (t.length !== e.length) return !1;
                for (r = 0; r < t.length; r++) if (t[r] !== e[r]) return !1;
                return !0
            }
            try {
                var o = Object.keys(t), s = Object.keys(e)
            } catch (t) {
                return !1
            }
            if (o.length !== s.length) return !1;
            for (o.sort(), s.sort(), r = o.length - 1; 0 <= r; r--) if (o[r] !== s[r]) return !1;
            for (r = o.length - 1; 0 <= r; r--) if (!Vr(t[i = o[r]], e[i], n)) return !1;
            return typeof t == typeof e
        }(t, e, n))
    }

    function Hr(t) {
        return null == t
    }

    function Wr(t) {
        return !(!t || "object" != typeof t || "number" != typeof t.length || "function" != typeof t.copy || "function" != typeof t.slice || 0 < t.length && "number" != typeof t[0])
    }

    function Jr(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var o, s = n.tolerance || 0, a = [], u = qn();
        return u.load(kn(t)), F(e, function (r) {
            var i = !1;
            L(u.search(r), function (t) {
                if (!1 === i) {
                    var e = Z(r).sort(), n = Z(t).sort();
                    Vr(e, n) ? (i = !0, o = o ? Zr(o, r) : r) : (0 === s ? hr(e[0], t) && hr(e[1], t) : Xn(t, e[0]).properties.dist <= s && Xn(t, e[1]).properties.dist <= s) ? (i = !0, o = o ? Zr(o, r) : r) : (0 === s ? hr(n[0], r) && hr(n[1], r) : Xn(r, n[0]).properties.dist <= s && Xn(r, n[1]).properties.dist <= s) && (o = o ? Zr(o, t) : t)
                }
            }), !1 === i && o && (a.push(o), o = void 0)
        }), o && a.push(o), Y(a)
    }

    function Zr(t, e) {
        var n = Z(e), r = Z(t), i = r[0], o = r[r.length - 1], s = t.geometry.coordinates;
        return Vr(n[0], i) ? s.unshift(n[1]) : Vr(n[0], o) ? s.push(n[1]) : Vr(n[1], i) ? s.unshift(n[0]) : Vr(n[1], o) && s.push(n[0]), t
    }

    function Kr(t) {
        var e = t % 360;
        return e < 0 && (e += 360), e
    }

    function Qr(t, e, n, r) {
        if (!H(r = r || {})) throw new Error("options is invalid");
        var i = r.units, o = r.properties;
        if (!t) throw new Error("origin is required");
        if (null == e) throw new Error("distance is required");
        if (null == n) throw new Error("bearing is required");
        if (!(0 <= e)) throw new Error("distance must be greater than 0");
        var p = _(e, i, "meters"), s = J(t), a = function (t, e, n, r) {
            var i = p / (r = void 0 === r ? f : Number(r)), o = t[0] * Math.PI / 180, s = m(t[1]), a = m(n),
                u = i * Math.cos(a), c = s + u;
            Math.abs(c) > Math.PI / 2 && (c = 0 < c ? Math.PI - c : -Math.PI - c);
            var h = Math.log(Math.tan(c / 2 + Math.PI / 4) / Math.tan(s / 2 + Math.PI / 4)),
                l = 1e-11 < Math.abs(h) ? u / h : Math.cos(s);
            return [(180 * (o + i * Math.sin(a) / l) / Math.PI + 540) % 360 - 180, 180 * c / Math.PI]
        }(s, 0, n);
        return a[0] += 180 < a[0] - s[0] ? -360 : 180 < s[0] - a[0] ? 360 : 0, X(a, o)
    }

    function $r(t, e, n, r, i, o) {
        for (var s = 0; s < t.length; s++) {
            var a = t[s], u = t[s + 1];
            s === t.length - 1 && (u = t[0]), r = ti(a, u, e), n <= 0 && 0 < r ? ti(e, a, i) < 0 || (i = a) : 0 < n && r <= 0 && (0 < ti(e, a, o) || (o = a)), n = r
        }
        return [i, o]
    }

    function ti(t, e, n) {
        return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1])
    }

    function ei(t) {
        if (!t) throw new Error("line is required");
        var e = t.geometry ? t.geometry.type : t.type;
        if (!Array.isArray(t) && "LineString" !== e) throw new Error("geometry must be a LineString");
        for (var n, r, i = Z(t), o = 0, s = 1; s < i.length;) n = r || i[0], o += ((r = i[s])[0] - n[0]) * (r[1] + n[1]), s++;
        return 0 < o
    }

    function ni(t, e) {
        switch ("Feature" === t.type ? t.geometry.type : t.type) {
            case"GeometryCollection":
                return R(t, function (t) {
                    ni(t, e)
                }), t;
            case"LineString":
                return ri(Z(t), e), t;
            case"Polygon":
                return ii(Z(t), e), t;
            case"MultiLineString":
                return Z(t).forEach(function (t) {
                    ri(t, e)
                }), t;
            case"MultiPolygon":
                return Z(t).forEach(function (t) {
                    ii(t, e)
                }), t;
            case"Point":
            case"MultiPoint":
                return t
        }
    }

    function ri(t, e) {
        ei(t) === e && t.reverse()
    }

    function ii(t, e) {
        ei(t[0]) !== e && t[0].reverse();
        for (var n = 1; n < t.length; n++) ei(t[n]) === e && t[n].reverse()
    }

    var oi = {successCallback: null, verbose: !1, polygons: !1}, si = {};

    function ai(t, e, n, r) {
        r = r || {};
        for (var i = Object.keys(oi), o = 0; o < i.length; o++) {
            var s = i[o], a = r[s];
            a = null != a ? a : oi[s], si[s] = a
        }
        si.verbose && console.log("MarchingSquaresJS-isoBands: computing isobands for [" + e + ":" + (e + n) + "]");
        var u, c, h, l = function (t, e, n) {
            for (var r = t.length - 1, i = t[0].length - 1, o = {
                rows: r,
                cols: i,
                cells: []
            }, s = e + Math.abs(n), a = 0; a < r; ++a) {
                o.cells[a] = [];
                for (var u = 0; u < i; ++u) {
                    var c = 0, h = t[a + 1][u], l = t[a + 1][u + 1], p = t[a][u + 1], f = t[a][u];
                    if (!(isNaN(h) || isNaN(l) || isNaN(p) || isNaN(f))) {
                        c |= h < e ? 0 : s < h ? 128 : 64, c |= l < e ? 0 : s < l ? 32 : 16, c |= p < e ? 0 : s < p ? 8 : 4;
                        var g = +(c |= f < e ? 0 : s < f ? 2 : 1), d = 0;
                        if (17 === c || 18 === c || 33 === c || 34 === c || 38 === c || 68 === c || 72 === c || 98 === c || 102 === c || 132 === c || 136 === c || 137 === c || 152 === c || 153 === c) {
                            var y = (h + l + p + f) / 4;
                            d = s < y ? 2 : y < e ? 0 : 1, 34 === c ? 1 === d ? c = 35 : 0 === d && (c = 136) : 136 === c ? 1 === d ? (c = 35, d = 4) : 0 === d && (c = 34) : 17 === c ? 1 === d ? (c = 155, d = 4) : 0 === d && (c = 153) : 68 === c ? 1 === d ? (c = 103, d = 4) : 0 === d && (c = 102) : 153 === c ? 1 === d && (c = 155) : 102 === c ? 1 === d && (c = 103) : 152 === c ? d < 2 && (c = 156, d = 1) : 137 === c ? d < 2 && (c = 139, d = 1) : 98 === c ? d < 2 && (c = 99, d = 1) : 38 === c ? d < 2 && (c = 39, d = 1) : 18 === c ? 0 < d ? (c = 156, d = 4) : c = 152 : 33 === c ? 0 < d ? (c = 139, d = 4) : c = 137 : 72 === c ? 0 < d ? (c = 99, d = 4) : c = 98 : 132 === c && (0 < d ? (c = 39, d = 4) : c = 38)
                        }
                        if (0 != c && 170 != c) {
                            var _, m, v, x, E, w, b, I;
                            _ = m = v = x = E = w = b = I = .5;
                            var N = [];
                            1 === c ? (v = 1 - $i(e, p, f), I = 1 - $i(e, h, f), N.push(Hi[c])) : 169 === c ? (v = $i(s, f, p), I = $i(s, f, h), N.push(Hi[c])) : 4 === c ? (w = 1 - $i(e, l, p), x = $i(e, f, p), N.push(Yi[c])) : 166 === c ? (w = $i(s, p, l), x = 1 - $i(s, p, f), N.push(Yi[c])) : 16 === c ? (E = $i(e, p, l), m = $i(e, h, l), N.push(Ui[c])) : 154 === c ? (E = 1 - $i(s, l, p), m = 1 - $i(s, l, h), N.push(Ui[c])) : 64 === c ? (b = $i(e, f, h), _ = 1 - $i(e, l, h), N.push(Ji[c])) : 106 === c ? (b = 1 - $i(s, h, f), _ = $i(s, h, l), N.push(Ji[c])) : 168 === c ? (x = $i(s, f, p), v = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), N.push(Vi[c]), N.push(Hi[c])) : 2 === c ? (x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), N.push(Vi[c]), N.push(Hi[c])) : 162 === c ? (E = $i(s, p, l), w = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), N.push(Vi[c]), N.push(Hi[c])) : 8 === c ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), N.push(Ui[c]), N.push(Yi[c])) : 138 === c ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), _ = 1 - $i(s, l, h), m = 1 - $i(e, l, h), N.push(Ui[c]), N.push(Yi[c])) : 32 === c ? (E = $i(s, p, l), w = $i(e, p, l), _ = $i(e, h, l), m = $i(s, h, l), N.push(Ui[c]), N.push(Yi[c])) : 42 === c ? (I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), _ = $i(e, h, l), m = $i(s, h, l), N.push(Wi[c]), N.push(Ji[c])) : 128 === c && (I = $i(e, f, h), b = $i(s, f, h), _ = 1 - $i(s, l, h), m = 1 - $i(e, l, h), N.push(Wi[c]), N.push(Ji[c])), 5 === c ? (w = 1 - $i(e, l, p), I = 1 - $i(e, h, f), N.push(Yi[c])) : 165 === c ? (w = $i(s, p, l), I = $i(s, f, h), N.push(Yi[c])) : 20 === c ? (x = $i(e, f, p), m = $i(e, h, l), N.push(Vi[c])) : 150 === c ? (x = 1 - $i(s, p, f), m = 1 - $i(s, l, h), N.push(Vi[c])) : 80 === c ? (E = $i(e, p, l), b = $i(e, f, h), N.push(Ui[c])) : 90 === c ? (E = 1 - $i(s, l, p), b = 1 - $i(s, h, f), N.push(Ui[c])) : 65 === c ? (v = 1 - $i(e, p, f), _ = 1 - $i(e, l, h), N.push(Hi[c])) : 105 === c ? (v = $i(s, f, p), _ = $i(s, h, l), N.push(Hi[c])) : 160 === c ? (E = $i(s, p, l), w = $i(e, p, l), I = $i(e, f, h), b = $i(s, f, h), N.push(Ui[c]), N.push(Yi[c])) : 10 === c ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), N.push(Ui[c]), N.push(Yi[c])) : 130 === c ? (x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), _ = 1 - $i(s, l, h), m = 1 - $i(e, l, h), N.push(Vi[c]), N.push(Hi[c])) : 40 === c ? (x = $i(s, f, p), v = $i(e, f, p), _ = $i(e, h, l), m = $i(s, h, l), N.push(Vi[c]), N.push(Hi[c])) : 101 === c ? (w = $i(s, p, l), _ = $i(s, h, l), N.push(Yi[c])) : 69 === c ? (w = 1 - $i(e, l, p), _ = 1 - $i(e, l, h), N.push(Yi[c])) : 149 === c ? (I = $i(s, f, h), m = 1 - $i(s, l, h), N.push(Wi[c])) : 21 === c ? (I = 1 - $i(e, h, f), m = $i(e, h, l), N.push(Wi[c])) : 86 === c ? (x = 1 - $i(s, p, f), b = 1 - $i(s, h, f), N.push(Vi[c])) : 84 === c ? (x = $i(e, f, p), b = $i(e, f, h), N.push(Vi[c])) : 89 === c ? (E = 1 - $i(s, l, p), v = $i(s, f, p), N.push(Hi[c])) : 81 === c ? (E = $i(e, p, l), v = 1 - $i(e, p, f), N.push(Hi[c])) : 96 === c ? (E = $i(s, p, l), w = $i(e, p, l), b = $i(e, f, h), _ = $i(s, h, l), N.push(Ui[c]), N.push(Yi[c])) : 74 === c ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), b = 1 - $i(s, h, f), _ = 1 - $i(e, l, h), N.push(Ui[c]), N.push(Yi[c])) : 24 === c ? (E = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), m = $i(e, h, l), N.push(Ui[c]), N.push(Hi[c])) : 146 === c ? (E = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), m = 1 - $i(s, l, h), N.push(Ui[c]), N.push(Hi[c])) : 6 === c ? (w = 1 - $i(e, l, p), x = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), N.push(Yi[c]), N.push(Vi[c])) : 164 === c ? (w = $i(s, p, l), x = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), N.push(Yi[c]), N.push(Vi[c])) : 129 === c ? (v = 1 - $i(e, p, f), I = $i(s, f, h), _ = 1 - $i(s, l, h), m = 1 - $i(e, l, h), N.push(Hi[c]), N.push(Wi[c])) : 41 === c ? (v = $i(s, f, p), I = 1 - $i(e, h, f), _ = $i(e, h, l), m = $i(s, h, l), N.push(Hi[c]), N.push(Wi[c])) : 66 === c ? (x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), b = 1 - $i(s, h, f), _ = 1 - $i(e, l, h), N.push(Vi[c]), N.push(Hi[c])) : 104 === c ? (x = $i(s, f, p), v = $i(e, f, p), b = $i(e, f, h), _ = $i(s, h, l), N.push(Hi[c]), N.push(Zi[c])) : 144 === c ? (E = $i(e, p, l), I = $i(e, f, h), b = $i(s, f, h), m = 1 - $i(s, l, h), N.push(Ui[c]), N.push(Ji[c])) : 26 === c ? (E = 1 - $i(s, l, p), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), m = $i(e, h, l), N.push(Ui[c]), N.push(Ji[c])) : 36 === c ? (w = $i(s, p, l), x = $i(e, f, p), _ = $i(e, h, l), m = $i(s, h, l), N.push(Yi[c]), N.push(Vi[c])) : 134 === c ? (w = 1 - $i(e, l, p), x = 1 - $i(s, p, f), _ = 1 - $i(s, l, h), m = 1 - $i(e, l, h), N.push(Yi[c]), N.push(Vi[c])) : 9 === c ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), v = $i(s, f, p), I = 1 - $i(e, h, f), N.push(Ui[c]), N.push(Yi[c])) : 161 === c ? (E = $i(s, p, l), w = $i(e, p, l), v = 1 - $i(e, p, f), I = $i(s, f, h), N.push(Ui[c]), N.push(Yi[c])) : 37 === c ? (w = $i(s, p, l), I = 1 - $i(e, h, f), _ = $i(e, h, l), m = $i(s, h, l), N.push(Yi[c]), N.push(Wi[c])) : 133 === c ? (w = 1 - $i(e, l, p), I = $i(s, f, h), _ = 1 - $i(s, l, h), m = 1 - $i(e, l, h), N.push(Yi[c]), N.push(Wi[c])) : 148 === c ? (x = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), m = 1 - $i(s, l, h), N.push(Vi[c]), N.push(Ji[c])) : 22 === c ? (x = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), m = $i(e, h, l), N.push(Vi[c]), N.push(Ji[c])) : 82 === c ? (E = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), b = 1 - $i(s, h, f), N.push(Ui[c]), N.push(Hi[c])) : 88 === c ? (E = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), b = $i(e, f, h), N.push(Ui[c]), N.push(Hi[c])) : 73 === c ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), v = $i(s, f, p), _ = 1 - $i(e, l, h), N.push(Ui[c]), N.push(Yi[c])) : 97 === c ? (E = $i(s, p, l), w = $i(e, p, l), v = 1 - $i(e, p, f), _ = $i(s, h, l), N.push(Ui[c]), N.push(Yi[c])) : 145 === c ? (E = $i(e, p, l), v = 1 - $i(e, p, f), I = $i(s, f, h), m = 1 - $i(s, l, h), N.push(Ui[c]), N.push(Wi[c])) : 25 === c ? (E = 1 - $i(s, l, p), v = $i(s, f, p), I = 1 - $i(e, h, f), m = $i(e, h, l), N.push(Ui[c]), N.push(Wi[c])) : 70 === c ? (w = 1 - $i(e, l, p), x = 1 - $i(s, p, f), b = 1 - $i(s, h, f), _ = 1 - $i(e, l, h), N.push(Yi[c]), N.push(Vi[c])) : 100 === c ? (w = $i(s, p, l), x = $i(e, f, p), b = $i(e, f, h), _ = $i(s, h, l), N.push(Yi[c]), N.push(Vi[c])) : 34 === c ? (m = 0 === d ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), _ = 1 - $i(s, l, h), 1 - $i(e, l, h)) : (E = $i(s, p, l), w = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), _ = $i(e, h, l), $i(s, h, l)), N.push(Ui[c]), N.push(Yi[c]), N.push(Wi[c]), N.push(Ji[c])) : 35 === c ? (m = 4 === d ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), _ = 1 - $i(s, l, h), 1 - $i(e, l, h)) : (E = $i(s, p, l), w = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), _ = $i(e, h, l), $i(s, h, l)), N.push(Ui[c]), N.push(Yi[c]), N.push(Hi[c]), N.push(Ji[c])) : 136 === c ? (m = 0 === d ? (E = $i(s, p, l), w = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), _ = $i(e, h, l), $i(s, h, l)) : (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), _ = 1 - $i(s, l, h), 1 - $i(e, l, h)), N.push(Ui[c]), N.push(Yi[c]), N.push(Wi[c]), N.push(Ji[c])) : 153 === c ? (m = 0 === d ? (E = $i(e, p, l), v = 1 - $i(e, p, f), I = 1 - $i(e, h, f), $i(e, h, l)) : (E = 1 - $i(s, l, p), v = $i(s, f, p), I = $i(s, f, h), 1 - $i(s, l, h)), N.push(Ui[c]), N.push(Hi[c])) : 102 === c ? (_ = 0 === d ? (w = 1 - $i(e, l, p), x = $i(e, f, p), b = $i(e, f, h), 1 - $i(e, l, h)) : (w = $i(s, p, l), x = 1 - $i(s, p, f), b = 1 - $i(s, h, f), $i(s, h, l)), N.push(Yi[c]), N.push(Ji[c])) : 155 === c ? (m = 4 === d ? (E = $i(e, p, l), v = 1 - $i(e, p, f), I = 1 - $i(e, h, f), $i(e, h, l)) : (E = 1 - $i(s, l, p), v = $i(s, f, p), I = $i(s, f, h), 1 - $i(s, l, h)), N.push(Ui[c]), N.push(Wi[c])) : 103 === c ? (_ = 4 === d ? (w = 1 - $i(e, l, p), x = $i(e, f, p), b = $i(e, f, h), 1 - $i(e, l, h)) : (w = $i(s, p, l), x = 1 - $i(s, p, f), b = 1 - $i(s, h, f), $i(s, h, l)), N.push(Yi[c]), N.push(Vi[c])) : 152 === c ? (m = 0 === d ? (E = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), $i(e, h, l)) : (E = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), 1 - $i(s, l, h)), N.push(Ui[c]), N.push(Vi[c]), N.push(Hi[c])) : 156 === c ? (m = 4 === d ? (E = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), $i(e, h, l)) : (E = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), 1 - $i(s, l, h)), N.push(Ui[c]), N.push(Hi[c]), N.push(Ji[c])) : 137 === c ? (m = 0 === d ? (E = $i(s, p, l), w = $i(e, p, l), v = 1 - $i(e, p, f), I = 1 - $i(e, h, f), _ = $i(e, h, l), $i(s, h, l)) : (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), v = $i(s, f, p), I = $i(s, f, h), _ = 1 - $i(s, l, h), 1 - $i(e, l, h)), N.push(Ui[c]), N.push(Yi[c]), N.push(Hi[c])) : 139 === c ? (m = 4 === d ? (E = $i(s, p, l), w = $i(e, p, l), v = 1 - $i(e, p, f), I = 1 - $i(e, h, f), _ = $i(e, h, l), $i(s, h, l)) : (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), v = $i(s, f, p), I = $i(s, f, h), _ = 1 - $i(s, l, h), 1 - $i(e, l, h)), N.push(Ui[c]), N.push(Yi[c]), N.push(Wi[c])) : 98 === c ? (_ = 0 === d ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), b = $i(e, f, h), 1 - $i(e, l, h)) : (E = $i(s, p, l), w = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), b = 1 - $i(s, h, f), $i(s, h, l)), N.push(Ui[c]), N.push(Yi[c]), N.push(Ji[c])) : 99 === c ? (_ = 4 === d ? (E = 1 - $i(e, l, p), w = 1 - $i(s, l, p), x = $i(s, f, p), v = $i(e, f, p), b = $i(e, f, h), 1 - $i(e, l, h)) : (E = $i(s, p, l), w = $i(e, p, l), x = 1 - $i(e, p, f), v = 1 - $i(s, p, f), b = 1 - $i(s, h, f), $i(s, h, l)), N.push(Ui[c]), N.push(Yi[c]), N.push(Hi[c])) : 38 === c ? (m = 0 === d ? (w = 1 - $i(e, l, p), x = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), _ = 1 - $i(s, l, h), 1 - $i(e, l, h)) : (w = $i(s, p, l), x = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), _ = $i(e, h, l), $i(s, h, l)), N.push(Yi[c]), N.push(Wi[c]), N.push(Ji[c])) : 39 === c ? (m = 4 === d ? (w = 1 - $i(e, l, p), x = $i(e, f, p), I = $i(e, f, h), b = $i(s, f, h), _ = 1 - $i(s, l, h), 1 - $i(e, l, h)) : (w = $i(s, p, l), x = 1 - $i(s, p, f), I = 1 - $i(s, h, f), b = 1 - $i(e, h, f), _ = $i(e, h, l), $i(s, h, l)), N.push(Yi[c]), N.push(Vi[c]), N.push(Ji[c])) : 85 === c && (_ = I = v = w = 0, m = b = x = E = 1), (_ < 0 || 1 < _ || m < 0 || 1 < m || E < 0 || 1 < E || x < 0 || 1 < x || I < 0 || 1 < I || b < 0 || 1 < b) && console.log("MarchingSquaresJS-isoBands: " + c + " " + g + " " + h + "," + l + "," + p + "," + f + " " + d + " " + _ + " " + m + " " + E + " " + w + " " + x + " " + v + " " + I + " " + b), o.cells[a][u] = {
                                cval: c,
                                cval_real: g,
                                flipped: d,
                                topleft: _,
                                topright: m,
                                righttop: E,
                                rightbottom: w,
                                bottomright: x,
                                bottomleft: v,
                                leftbottom: I,
                                lefttop: b,
                                edges: N
                            }
                        }
                    }
                }
            }
            return o
        }(t, e, n);
        return u = si.polygons ? (si.verbose && console.log("MarchingSquaresJS-isoBands: returning single polygons for each grid cell"), c = [], h = 0, l.cells.forEach(function (t, r) {
            t.forEach(function (t, e) {
                if (void 0 !== t) {
                    var n = Qi[t.cval](t);
                    "object" == typeof n && to(n) ? "object" == typeof n[0] && to(n[0]) ? "object" == typeof n[0][0] && to(n[0][0]) ? n.forEach(function (t) {
                        t.forEach(function (t) {
                            t[0] += e, t[1] += r
                        }), c[h++] = t
                    }) : (n.forEach(function (t) {
                        t[0] += e, t[1] += r
                    }), c[h++] = n) : console.log("MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates") : console.log("MarchingSquaresJS-isoBands: bandcell polygon with null coordinates")
                }
            })
        }), c) : (si.verbose && console.log("MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"), function (t) {
            for (var e = [], n = t.rows, r = t.cols, i = [], o = 0; o < n; o++) for (var s = 0; s < r; s++) if (void 0 !== t.cells[o][s] && 0 < t.cells[o][s].edges.length) {
                var a = no(t.cells[o][s]), u = null, c = s, h = o;
                null !== a && i.push([a.p[0] + c, a.p[1] + h]);
                do {
                    if (null === (u = ro(t.cells[h][c], a.x, a.y, a.o))) break;
                    if (i.push([u.p[0] + c, u.p[1] + h]), c += u.x, (h += (a = u).y) < 0 || n <= h || c < 0 || r <= c || void 0 === t.cells[h][c]) {
                        var l = eo(t, c -= u.x, h -= u.y, u.x, u.y, u.o);
                        if (null === l) break;
                        l.path.forEach(function (t) {
                            i.push(t)
                        }), c = l.i, h = l.j, a = l
                    }
                } while (void 0 !== t.cells[h][c] && 0 < t.cells[h][c].edges.length);
                e.push(i), i = [], 0 < t.cells[o][s].edges.length && s--
            }
            return e
        }(l)), "function" == typeof si.successCallback && si.successCallback(u), u
    }

    var ui = 64, ci = 16, hi = 4, li = 1, pi = [], fi = [], gi = [], di = [], yi = [], _i = [], mi = [], vi = [],
        xi = [], Ei = [], wi = [], bi = [], Ii = [], Ni = [], Ci = [], Si = [], Mi = [], Li = [], Pi = [], Oi = [],
        Ri = [], Ti = [], Ai = [], Di = [];
    mi[85] = Ei[85] = -1, vi[85] = wi[85] = 0, xi[85] = bi[85] = 1, Pi[85] = Ti[85] = 1, Oi[85] = Ai[85] = 0, Ri[85] = Di[85] = 1, pi[85] = di[85] = 0, fi[85] = yi[85] = -1, gi[85] = Ci[85] = 0, Si[85] = Ii[85] = 0, Mi[85] = Ni[85] = 1, _i[85] = Li[85] = 1, Ti[1] = Ti[169] = 0, Ai[1] = Ai[169] = -1, Di[1] = Di[169] = 0, Ii[1] = Ii[169] = -1, Ni[1] = Ni[169] = 0, Ci[1] = Ci[169] = 0, Ei[4] = Ei[166] = 0, wi[4] = wi[166] = -1, bi[4] = bi[166] = 1, Si[4] = Si[166] = 1, Mi[4] = Mi[166] = 0, Li[4] = Li[166] = 0, mi[16] = mi[154] = 0, vi[16] = vi[154] = 1, xi[16] = xi[154] = 1, di[16] = di[154] = 1, yi[16] = yi[154] = 0, _i[16] = _i[154] = 1, Pi[64] = Pi[106] = 0, Oi[64] = Oi[106] = 1, Ri[64] = Ri[106] = 0, pi[64] = pi[106] = -1, fi[64] = fi[106] = 0, gi[64] = gi[106] = 1, Pi[2] = Pi[168] = 0, Oi[2] = Oi[168] = -1, Ri[2] = Ri[168] = 1, Ti[2] = Ti[168] = 0, Ai[2] = Ai[168] = -1, Di[2] = Di[168] = 0, Ii[2] = Ii[168] = -1, Ni[2] = Ni[168] = 0, Ci[2] = Ci[168] = 0, Si[2] = Si[168] = -1, Mi[2] = Mi[168] = 0, Li[2] = Li[168] = 1, mi[8] = mi[162] = 0, vi[8] = vi[162] = -1, xi[8] = xi[162] = 0, Ei[8] = Ei[162] = 0, wi[8] = wi[162] = -1, bi[8] = bi[162] = 1, Ii[8] = Ii[162] = 1, Ni[8] = Ni[162] = 0, Ci[8] = Ci[162] = 1, Si[8] = Si[162] = 1, Mi[8] = Mi[162] = 0, Li[8] = Li[162] = 0, mi[32] = mi[138] = 0, vi[32] = vi[138] = 1, xi[32] = xi[138] = 1, Ei[32] = Ei[138] = 0, wi[32] = wi[138] = 1, bi[32] = bi[138] = 0, pi[32] = pi[138] = 1, fi[32] = fi[138] = 0, gi[32] = gi[138] = 0, di[32] = di[138] = 1, yi[32] = yi[138] = 0, _i[32] = _i[138] = 1, Ti[128] = Ti[42] = 0, Ai[128] = Ai[42] = 1, Di[128] = Di[42] = 1, Pi[128] = Pi[42] = 0, Oi[128] = Oi[42] = 1, Ri[128] = Ri[42] = 0, pi[128] = pi[42] = -1, fi[128] = fi[42] = 0, gi[128] = gi[42] = 1, di[128] = di[42] = -1, yi[128] = yi[42] = 0, _i[128] = _i[42] = 0, Ei[5] = Ei[165] = -1, wi[5] = wi[165] = 0, bi[5] = bi[165] = 0, Ti[5] = Ti[165] = 1, Ai[5] = Ai[165] = 0, Di[5] = Di[165] = 0, Si[20] = Si[150] = 0, Mi[20] = Mi[150] = 1, Li[20] = Li[150] = 1, di[20] = di[150] = 0, yi[20] = yi[150] = -1, _i[20] = _i[150] = 1, mi[80] = mi[90] = -1, vi[80] = vi[90] = 0, xi[80] = xi[90] = 1, Pi[80] = Pi[90] = 1, Oi[80] = Oi[90] = 0,Ri[80] = Ri[90] = 1,Ii[65] = Ii[105] = 0,Ni[65] = Ni[105] = 1,Ci[65] = Ci[105] = 0,pi[65] = pi[105] = 0,fi[65] = fi[105] = -1,gi[65] = gi[105] = 0,mi[160] = mi[10] = -1,vi[160] = vi[10] = 0,xi[160] = xi[10] = 1,Ei[160] = Ei[10] = -1,wi[160] = wi[10] = 0,bi[160] = bi[10] = 0,Ti[160] = Ti[10] = 1,Ai[160] = Ai[10] = 0,Di[160] = Di[10] = 0,Pi[160] = Pi[10] = 1,Oi[160] = Oi[10] = 0,Ri[160] = Ri[10] = 1,Si[130] = Si[40] = 0,Mi[130] = Mi[40] = 1,Li[130] = Li[40] = 1,Ii[130] = Ii[40] = 0,Ni[130] = Ni[40] = 1,Ci[130] = Ci[40] = 0,pi[130] = pi[40] = 0,fi[130] = fi[40] = -1,gi[130] = gi[40] = 0,di[130] = di[40] = 0,yi[130] = yi[40] = -1,_i[130] = _i[40] = 1,Ei[37] = Ei[133] = 0,wi[37] = wi[133] = 1,bi[37] = bi[133] = 1,Ti[37] = Ti[133] = 0,Ai[37] = Ai[133] = 1,Di[37] = Di[133] = 0,pi[37] = pi[133] = -1,fi[37] = fi[133] = 0,gi[37] = gi[133] = 0,di[37] = di[133] = 1,yi[37] = yi[133] = 0,_i[37] = _i[133] = 0,Si[148] = Si[22] = -1,Mi[148] = Mi[22] = 0,Li[148] = Li[22] = 0,Ti[148] = Ti[22] = 0,Ai[148] = Ai[22] = -1,Di[148] = Di[22] = 1,Pi[148] = Pi[22] = 0,Oi[148] = Oi[22] = 1,Ri[148] = Ri[22] = 1,di[148] = di[22] = -1,yi[148] = yi[22] = 0,_i[148] = _i[22] = 1,mi[82] = mi[88] = 0,vi[82] = vi[88] = -1,xi[82] = xi[88] = 1,Si[82] = Si[88] = 1,Mi[82] = Mi[88] = 0,Li[82] = Li[88] = 1,Ii[82] = Ii[88] = -1,Ni[82] = Ni[88] = 0,Ci[82] = Ci[88] = 1,Pi[82] = Pi[88] = 0,Oi[82] = Oi[88] = -1,Ri[82] = Ri[88] = 0,mi[73] = mi[97] = 0,vi[73] = vi[97] = 1,xi[73] = xi[97] = 0,Ei[73] = Ei[97] = 0,wi[73] = wi[97] = -1,bi[73] = bi[97] = 0,Ii[73] = Ii[97] = 1,Ni[73] = Ni[97] = 0,Ci[73] = Ci[97] = 0,pi[73] = pi[97] = 1,fi[73] = fi[97] = 0,gi[73] = gi[97] = 1,mi[145] = mi[25] = 0,vi[145] = vi[25] = -1,xi[145] = xi[25] = 0,Ii[145] = Ii[25] = 1,Ni[145] = Ni[25] = 0,Ci[145] = Ci[25] = 1,Ti[145] = Ti[25] = 0,Ai[145] = Ai[25] = 1,Di[145] = Di[25] = 1,di[145] = di[25] = -1,yi[145] = yi[25] = 0,_i[145] = _i[25] = 0,Ei[70] = Ei[100] = 0,wi[70] = wi[100] = 1,bi[70] = bi[100] = 0,Si[70] = Si[100] = -1,Mi[70] = Mi[100] = 0,Li[70] = Li[100] = 1,Pi[70] = Pi[100] = 0,Oi[70] = Oi[100] = -1,Ri[70] = Ri[100] = 1,pi[70] = pi[100] = 1,fi[70] = fi[100] = 0,gi[70] = gi[100] = 0,Ei[101] = Ei[69] = 0,wi[101] = wi[69] = 1,bi[101] = bi[69] = 0,pi[101] = pi[69] = 1,fi[101] = fi[69] = 0,gi[101] = gi[69] = 0,Ti[149] = Ti[21] = 0,Ai[149] = Ai[21] = 1,Di[149] = Di[21] = 1,di[149] = di[21] = -1,yi[149] = yi[21] = 0,_i[149] = _i[21] = 0,Si[86] = Si[84] = -1,Mi[86] = Mi[84] = 0,Li[86] = Li[84] = 1,Pi[86] = Pi[84] = 0,Oi[86] = Oi[84] = -1,Ri[86] = Ri[84] = 1,mi[89] = mi[81] = 0,vi[89] = vi[81] = -1,xi[89] = xi[81] = 0,Ii[89] = Ii[81] = 1,Ni[89] = Ni[81] = 0,Ci[89] = Ci[81] = 1,mi[96] = mi[74] = 0,vi[96] = vi[74] = 1,xi[96] = xi[74] = 0,Ei[96] = Ei[74] = -1,wi[96] = wi[74] = 0,bi[96] = bi[74] = 1,Pi[96] = Pi[74] = 1,Oi[96] = Oi[74] = 0,Ri[96] = Ri[74] = 0,pi[96] = pi[74] = 1,fi[96] = fi[74] = 0,gi[96] = gi[74] = 1,mi[24] = mi[146] = 0,vi[24] = vi[146] = -1,xi[24] = xi[146] = 1,Si[24] = Si[146] = 1,Mi[24] = Mi[146] = 0,Li[24] = Li[146] = 1,Ii[24] = Ii[146] = 0,Ni[24] = Ni[146] = 1,Ci[24] = Ci[146] = 1,di[24] = di[146] = 0,yi[24] = yi[146] = -1,_i[24] = _i[146] = 0,Ei[6] = Ei[164] = -1,wi[6] = wi[164] = 0,bi[6] = bi[164] = 1,Si[6] = Si[164] = -1,Mi[6] = Mi[164] = 0,Li[6] = Li[164] = 0,Ti[6] = Ti[164] = 0,Ai[6] = Ai[164] = -1,Di[6] = Di[164] = 1,Pi[6] = Pi[164] = 1,Oi[6] = Oi[164] = 0,Ri[6] = Ri[164] = 0,Ii[129] = Ii[41] = 0,Ni[129] = Ni[41] = 1,Ci[129] = Ci[41] = 1,Ti[129] = Ti[41] = 0,Ai[129] = Ai[41] = 1,Di[129] = Di[41] = 0,pi[129] = pi[41] = -1,fi[129] = fi[41] = 0,gi[129] = gi[41] = 0,di[129] = di[41] = 0,yi[129] = yi[41] = -1,_i[129] = _i[41] = 0,Si[66] = Si[104] = 0,Mi[66] = Mi[104] = 1,Li[66] = Li[104] = 0,Ii[66] = Ii[104] = -1,Ni[66] = Ni[104] = 0,Ci[66] = Ci[104] = 1,Pi[66] = Pi[104] = 0,Oi[66] = Oi[104] = -1,Ri[66] = Ri[104] = 0,pi[66] = pi[104] = 0,fi[66] = fi[104] = -1,gi[66] = gi[104] = 1,mi[144] = mi[26] = -1,vi[144] = vi[26] = 0,xi[144] = xi[26] = 0,Ti[144] = Ti[26] = 1,Ai[144] = Ai[26] = 0,Di[144] = Di[26] = 1,Pi[144] = Pi[26] = 0,Oi[144] = Oi[26] = 1,Ri[144] = Ri[26] = 1,di[144] = di[26] = -1,yi[144] = yi[26] = 0,_i[144] = _i[26] = 1,Ei[36] = Ei[134] = 0,wi[36] = wi[134] = 1,bi[36] = bi[134] = 1,Si[36] = Si[134] = 0,Mi[36] = Mi[134] = 1,Li[36] = Li[134] = 0,pi[36] = pi[134] = 0,fi[36] = fi[134] = -1,gi[36] = gi[134] = 1,di[36] = di[134] = 1,yi[36] = yi[134] = 0,_i[36] = _i[134] = 0,mi[9] = mi[161] = -1,vi[9] = vi[161] = 0,xi[9] = xi[161] = 0,Ei[9] = Ei[161] = 0,wi[9] = wi[161] = -1,bi[9] = bi[161] = 0,Ii[9] = Ii[161] = 1,Ni[9] = Ni[161] = 0,Ci[9] = Ci[161] = 0,Ti[9] = Ti[161] = 1,Ai[9] = Ai[161] = 0,Di[9] = Di[161] = 1,mi[136] = 0,vi[136] = 1,xi[136] = 1,Ei[136] = 0,wi[136] = 1,bi[136] = 0,Si[136] = -1,Mi[136] = 0,Li[136] = 1,Ii[136] = -1,Ni[136] = 0,Ci[136] = 0,Ti[136] = 0,Ai[136] = -1,Di[136] = 0,Pi[136] = 0,Oi[136] = -1,Ri[136] = 1,pi[136] = 1,fi[136] = 0,gi[136] = 0,di[136] = 1,yi[136] = 0,_i[136] = 1,mi[34] = 0,vi[34] = -1,xi[34] = 0,Ei[34] = 0,wi[34] = -1,bi[34] = 1,Si[34] = 1,Mi[34] = 0,Li[34] = 0,Ii[34] = 1,Ni[34] = 0,Ci[34] = 1,Ti[34] = 0,Ai[34] = 1,Di[34] = 1,Pi[34] = 0,Oi[34] = 1,Ri[34] = 0,pi[34] = -1,fi[34] = 0,gi[34] = 1,di[34] = -1,yi[34] = 0,_i[34] = 0,mi[35] = 0,vi[35] = 1,xi[35] = 1,Ei[35] = 0,wi[35] = -1,bi[35] = 1,Si[35] = 1,Mi[35] = 0,Li[35] = 0,Ii[35] = -1,Ni[35] = 0,Ci[35] = 0,Ti[35] = 0,Ai[35] = -1,Di[35] = 0,Pi[35] = 0,Oi[35] = 1,Ri[35] = 0,pi[35] = -1,fi[35] = 0,gi[35] = 1,di[35] = 1,yi[35] = 0,_i[35] = 1,mi[153] = 0,vi[153] = 1,xi[153] = 1,Ii[153] = -1,Ni[153] = 0,Ci[153] = 0,Ti[153] = 0,Ai[153] = -1,Di[153] = 0,di[153] = 1,yi[153] = 0,_i[153] = 1,Ei[102] = 0,wi[102] = -1,bi[102] = 1,Si[102] = 1,Mi[102] = 0,Li[102] = 0,Pi[102] = 0,Oi[102] = 1,Ri[102] = 0,pi[102] = -1,fi[102] = 0,gi[102] = 1,mi[155] = 0,vi[155] = -1,xi[155] = 0,Ii[155] = 1,Ni[155] = 0,Ci[155] = 1,Ti[155] = 0,Ai[155] = 1,Di[155] = 1,di[155] = -1,yi[155] = 0,_i[155] = 0,Ei[103] = 0,wi[103] = 1,bi[103] = 0,Si[103] = -1,Mi[103] = 0,Li[103] = 1,Pi[103] = 0,Oi[103] = -1,Ri[103] = 1,pi[103] = 1,fi[103] = 0,gi[103] = 0,mi[152] = 0,vi[152] = 1,xi[152] = 1,Si[152] = -1,Mi[152] = 0,Li[152] = 1,Ii[152] = -1,Ni[152] = 0,Ci[152] = 0,Ti[152] = 0,Ai[152] = -1,Di[152] = 0,Pi[152] = 0,Oi[152] = -1,Ri[152] = 1,di[152] = 1,yi[152] = 0,_i[152] = 1,mi[156] = 0,vi[156] = -1,xi[156] = 1,Si[156] = 1,Mi[156] = 0,Li[156] = 1,Ii[156] = -1,Ni[156] = 0,Ci[156] = 0,Ti[156] = 0,Ai[156] = -1,Di[156] = 0,Pi[156] = 0,Oi[156] = 1,Ri[156] = 1,di[156] = -1,yi[156] = 0,_i[156] = 1,mi[137] = 0,vi[137] = 1,xi[137] = 1,Ei[137] = 0,wi[137] = 1,bi[137] = 0,Ii[137] = -1,Ni[137] = 0,Ci[137] = 0,Ti[137] = 0,Ai[137] = -1,Di[137] = 0,pi[137] = 1,fi[137] = 0,gi[137] = 0,di[137] = 1,yi[137] = 0,_i[137] = 1,mi[139] = 0,vi[139] = 1,xi[139] = 1,Ei[139] = 0,wi[139] = -1,bi[139] = 0,Ii[139] = 1,Ni[139] = 0,Ci[139] = 0,Ti[139] = 0,Ai[139] = 1,Di[139] = 0,pi[139] = -1,fi[139] = 0,gi[139] = 0,di[139] = 1,yi[139] = 0,_i[139] = 1,mi[98] = 0,vi[98] = -1,xi[98] = 0,Ei[98] = 0,wi[98] = -1,bi[98] = 1,Si[98] = 1,Mi[98] = 0,Li[98] = 0,Ii[98] = 1,Ni[98] = 0,Ci[98] = 1,Pi[98] = 0,Oi[98] = 1,Ri[98] = 0,pi[98] = -1,fi[98] = 0,gi[98] = 1,mi[99] = 0,vi[99] = 1,xi[99] = 0,Ei[99] = 0,wi[99] = -1,bi[99] = 1,Si[99] = 1,Mi[99] = 0,Li[99] = 0,Ii[99] = -1,Ni[99] = 0,Ci[99] = 1,Pi[99] = 0,Oi[99] = -1,Ri[99] = 0,pi[99] = 1,fi[99] = 0,gi[99] = 1,Ei[38] = 0,wi[38] = -1,bi[38] = 1,Si[38] = 1,Mi[38] = 0,Li[38] = 0,Ti[38] = 0,Ai[38] = 1,Di[38] = 1,Pi[38] = 0,Oi[38] = 1,Ri[38] = 0,pi[38] = -1,fi[38] = 0,gi[38] = 1,di[38] = -1,yi[38] = 0,_i[38] = 0,Ei[39] = 0,wi[39] = 1,bi[39] = 1,Si[39] = -1,Mi[39] = 0,Li[39] = 0,Ti[39] = 0,Ai[39] = -1,Di[39] = 1,Pi[39] = 0,Oi[39] = 1,Ri[39] = 0,pi[39] = -1,fi[39] = 0,gi[39] = 1,di[39] = 1,yi[39] = 0,_i[39] = 0;
    var Fi = function (t) {
        return [[t.bottomleft, 0], [0, 0], [0, t.leftbottom]]
    }, qi = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0]]
    }, Gi = function (t) {
        return [[t.topright, 1], [1, 1], [1, t.righttop]]
    }, Bi = function (t) {
        return [[0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, ki = function (t) {
        return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop]]
    }, zi = function (t) {
        return [[t.bottomright, 0], [t.bottomleft, 0], [1, t.righttop], [1, t.rightbottom]]
    }, ji = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.topleft, 1], [t.topright, 1]]
    }, Xi = function (t) {
        return [[0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
    }, Ui = [], Yi = [], Vi = [], Hi = [], Wi = [], Ji = [], Zi = [], Ki = [];
    Hi[1] = Wi[1] = 18, Hi[169] = Wi[169] = 18, Vi[4] = Yi[4] = 12, Vi[166] = Yi[166] = 12, Ui[16] = Ki[16] = 4, Ui[154] = Ki[154] = 4, Ji[64] = Zi[64] = 22, Ji[106] = Zi[106] = 22, Vi[2] = Ji[2] = 17, Hi[2] = Wi[2] = 18, Vi[168] = Ji[168] = 17, Hi[168] = Wi[168] = 18, Ui[8] = Hi[8] = 9, Yi[8] = Vi[8] = 12, Ui[162] = Hi[162] = 9, Yi[162] = Vi[162] = 12, Ui[32] = Ki[32] = 4, Yi[32] = Zi[32] = 1, Ui[138] = Ki[138] = 4, Yi[138] = Zi[138] = 1, Wi[128] = Ki[128] = 21, Ji[128] = Zi[128] = 22, Wi[42] = Ki[42] = 21, Ji[42] = Zi[42] = 22, Yi[5] = Wi[5] = 14, Yi[165] = Wi[165] = 14, Vi[20] = Ki[20] = 6, Vi[150] = Ki[150] = 6, Ui[80] = Ji[80] = 11, Ui[90] = Ji[90] = 11, Hi[65] = Zi[65] = 3, Hi[105] = Zi[105] = 3, Ui[160] = Ji[160] = 11, Yi[160] = Wi[160] = 14, Ui[10] = Ji[10] = 11, Yi[10] = Wi[10] = 14, Vi[130] = Ki[130] = 6, Hi[130] = Zi[130] = 3, Vi[40] = Ki[40] = 6, Hi[40] = Zi[40] = 3, Yi[101] = Zi[101] = 1, Yi[69] = Zi[69] = 1, Wi[149] = Ki[149] = 21, Wi[21] = Ki[21] = 21, Vi[86] = Ji[86] = 17, Vi[84] = Ji[84] = 17, Ui[89] = Hi[89] = 9, Ui[81] = Hi[81] = 9, Ui[96] = Zi[96] = 0, Yi[96] = Ji[96] = 15, Ui[74] = Zi[74] = 0, Yi[74] = Ji[74] = 15, Ui[24] = Vi[24] = 8, Hi[24] = Ki[24] = 7, Ui[146] = Vi[146] = 8, Hi[146] = Ki[146] = 7, Yi[6] = Ji[6] = 15, Vi[6] = Wi[6] = 16, Yi[164] = Ji[164] = 15, Vi[164] = Wi[164] = 16, Hi[129] = Ki[129] = 7, Wi[129] = Zi[129] = 20, Hi[41] = Ki[41] = 7, Wi[41] = Zi[41] = 20, Vi[66] = Zi[66] = 2, Hi[66] = Ji[66] = 19, Vi[104] = Zi[104] = 2, Hi[104] = Ji[104] = 19, Ui[144] = Wi[144] = 10, Ji[144] = Ki[144] = 23, Ui[26] = Wi[26] = 10, Ji[26] = Ki[26] = 23, Yi[36] = Ki[36] = 5, Vi[36] = Zi[36] = 2, Yi[134] = Ki[134] = 5, Vi[134] = Zi[134] = 2, Ui[9] = Wi[9] = 10, Yi[9] = Hi[9] = 13, Ui[161] = Wi[161] = 10, Yi[161] = Hi[161] = 13, Yi[37] = Ki[37] = 5, Wi[37] = Zi[37] = 20, Yi[133] = Ki[133] = 5, Wi[133] = Zi[133] = 20, Vi[148] = Wi[148] = 16, Ji[148] = Ki[148] = 23, Vi[22] = Wi[22] = 16, Ji[22] = Ki[22] = 23, Ui[82] = Vi[82] = 8, Hi[82] = Ji[82] = 19, Ui[88] = Vi[88] = 8, Hi[88] = Ji[88] = 19, Ui[73] = Zi[73] = 0, Yi[73] = Hi[73] = 13, Ui[97] = Zi[97] = 0, Yi[97] = Hi[97] = 13, Ui[145] = Hi[145] = 9, Wi[145] = Ki[145] = 21, Ui[25] = Hi[25] = 9, Wi[25] = Ki[25] = 21, Yi[70] = Zi[70] = 1,Vi[70] = Ji[70] = 17,Yi[100] = Zi[100] = 1,Vi[100] = Ji[100] = 17,Ui[34] = Hi[34] = 9,Yi[34] = Vi[34] = 12,Wi[34] = Ki[34] = 21,Ji[34] = Zi[34] = 22,Ui[136] = Ki[136] = 4,Yi[136] = Zi[136] = 1,Vi[136] = Ji[136] = 17,Hi[136] = Wi[136] = 18,Ui[35] = Ki[35] = 4,Yi[35] = Vi[35] = 12,Hi[35] = Wi[35] = 18,Ji[35] = Zi[35] = 22,Ui[153] = Ki[153] = 4,Hi[153] = Wi[153] = 18,Yi[102] = Vi[102] = 12,Ji[102] = Zi[102] = 22,Ui[155] = Hi[155] = 9,Wi[155] = Ki[155] = 23,Yi[103] = Zi[103] = 1,Vi[103] = Ji[103] = 17,Ui[152] = Ki[152] = 4,Vi[152] = Ji[152] = 17,Hi[152] = Wi[152] = 18,Ui[156] = Vi[156] = 8,Hi[156] = Wi[156] = 18,Ji[156] = Ki[156] = 23,Ui[137] = Ki[137] = 4,Yi[137] = Zi[137] = 1,Hi[137] = Wi[137] = 18,Ui[139] = Ki[139] = 4,Yi[139] = Hi[139] = 13,Wi[139] = Zi[139] = 20,Ui[98] = Hi[98] = 9,Yi[98] = Vi[98] = 12,Ji[98] = Zi[98] = 22,Ui[99] = Zi[99] = 0,Yi[99] = Vi[99] = 12,Hi[99] = Ji[99] = 19,Yi[38] = Vi[38] = 12,Wi[38] = Ki[38] = 21,Ji[38] = Zi[38] = 22,Yi[39] = Ki[39] = 5,Vi[39] = Wi[39] = 16,Ji[39] = Zi[39] = 22;
    var Qi = [];

    function $i(t, e, n) {
        return (t - e) / (n - e)
    }

    function to(t) {
        return -1 < t.constructor.toString().indexOf("Array")
    }

    function eo(t, e, n, r, i, o) {
        for (var s = t.cells[n][e], a = s.cval_real, u = e + r, c = n + i, h = [], l = !1; !l;) {
            if (void 0 === t.cells[c] || void 0 === t.cells[c][u]) if (c -= i, u -= r, a = (s = t.cells[c][u]).cval_real, -1 === i) if (0 === o) if (a & li) h.push([u, c]), r = -1, o = i = 0; else {
                if (!(a & hi)) {
                    h.push([u + s.bottomright, c]), o = i = 1, l = !(r = 0);
                    break
                }
                h.push([u + 1, c]), r = 1, o = i = 0
            } else {
                if (!(a & li)) {
                    if (a & hi) {
                        h.push([u + s.bottomright, c]), o = i = 1, l = !(r = 0);
                        break
                    }
                    h.push([u + s.bottomleft, c]), i = 1, l = !(o = r = 0);
                    break
                }
                h.push([u, c]), r = -1, o = i = 0
            } else if (1 === i) if (0 === o) {
                if (!(a & ci)) {
                    if (a & ui) {
                        h.push([u + s.topleft, c + 1]), i = -1, l = !(o = r = 0);
                        break
                    }
                    h.push([u + s.topright, c + 1]), i = -1, o = 1, l = !(r = 0);
                    break
                }
                h.push([u + 1, c + 1]), i = 0, o = r = 1
            } else h.push([u + 1, c + 1]), i = 0, o = r = 1; else if (-1 === r) if (0 === o) {
                if (!(a & ui)) {
                    if (a & li) {
                        h.push([u, c + s.leftbottom]), r = 1, l = !(o = i = 0);
                        break
                    }
                    h.push([u, c + s.lefttop]), o = r = 1, l = !(i = 0);
                    break
                }
                h.push([u, c + 1]), i = 1, o = r = 0
            } else {
                if (!(a & ui)) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                h.push([u, c + 1]), i = 1, o = r = 0
            } else {
                if (1 !== r) {
                    console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
                    break
                }
                if (0 === o) {
                    if (!(a & hi)) {
                        h.push([u + 1, c + s.rightbottom]), r = -1, l = !(o = i = 0);
                        break
                    }
                    h.push([u + 1, c]), r = 0, i = -1, o = 1
                } else {
                    if (!(a & hi)) {
                        if (a & ci) {
                            h.push([u + 1, c + s.righttop]), r = -1, i = 0, o = 1;
                            break
                        }
                        h.push([u + 1, c + s.rightbottom]), r = -1, l = !(o = i = 0);
                        break
                    }
                    h.push([u + 1, c]), r = 0, i = -1, o = 1
                }
            } else if (a = (s = t.cells[c][u]).cval_real, -1 === r) if (0 === o) if (void 0 !== t.cells[c - 1] && void 0 !== t.cells[c - 1][u]) r = 0, i = -1, o = 1; else {
                if (!(a & li)) {
                    h.push([u + s.bottomright, c]), o = i = 1, l = !(r = 0);
                    break
                }
                h.push([u, c])
            } else {
                if (!(a & ui)) {
                    console.log("MarchingSquaresJS-isoBands: found entry from top at " + u + "," + c);
                    break
                }
                console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!")
            } else if (1 === r) {
                if (0 === o) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                if (void 0 !== t.cells[c + 1] && void 0 !== t.cells[c + 1][u]) i = 1, o = r = 0; else {
                    if (!(a & ci)) {
                        h.push([u + s.topleft, c + 1]), i = -1, l = !(o = r = 0);
                        break
                    }
                    h.push([u + 1, c + 1]), i = 0, o = r = 1
                }
            } else if (-1 === i) {
                if (1 !== o) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                if (void 0 !== t.cells[c][u + 1]) i = 0, o = r = 1; else {
                    if (!(a & hi)) {
                        h.push([u + 1, c + s.righttop]), r = -1, o = 1, l = !(i = 0);
                        break
                    }
                    h.push([u + 1, c]), r = 0, i = -1, o = 1
                }
            } else {
                if (1 !== i) {
                    console.log("MarchingSquaresJS-isoBands: where did we came from???");
                    break
                }
                if (0 !== o) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                if (void 0 !== t.cells[c][u - 1]) r = -1, o = i = 0; else {
                    if (!(a & ui)) {
                        h.push([u, c + s.leftbottom]), r = 1, l = !(o = i = 0);
                        break
                    }
                    h.push([u, c + 1]), i = 1, o = r = 0
                }
            }
            if (c += i, (u += r) === e && c === n) break
        }
        return {path: h, i: u, j: c, x: r, y: i, o: o}
    }

    function no(t) {
        if (0 < t.edges.length) {
            var e = t.edges[t.edges.length - 1], n = t.cval_real;
            switch (e) {
                case 0:
                    return n & ci ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [t.topleft, 1], x: 0, y: -1, o: 0};
                case 1:
                    return n & hi ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [1, t.rightbottom], x: -1, y: 0, o: 0};
                case 2:
                    return n & hi ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [t.topleft, 1], x: 0, y: -1, o: 0};
                case 3:
                    return n & li ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 4:
                    return n & ci ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                case 5:
                    return n & hi ? {p: [t.topright, 1], x: 0, y: -1, o: 1} : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 6:
                    return n & hi ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                case 7:
                    return n & li ? {p: [t.topright, 1], x: 0, y: -1, o: 1} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 8:
                    return n & hi ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [1, t.righttop], x: -1, y: 0, o: 1};
                case 9:
                    return n & li ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 10:
                    return n & li ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {p: [1, t.righttop], x: -1, y: 0, o: 1};
                case 11:
                    return n & ui ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 12:
                    return n & hi ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 13:
                    return n & li ? {p: [1, t.rightbottom], x: -1, y: 0, o: 0} : {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    };
                case 14:
                    return n & li ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 15:
                    return n & ui ? {p: [1, t.rightbottom], x: -1, y: 0, o: 0} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 16:
                    return n & hi ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {
                        p: [0, t.leftbottom],
                        x: 1,
                        y: 0,
                        o: 0
                    };
                case 17:
                    return n & ui ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 18:
                    return n & li ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 19:
                    return n & ui ? {p: [t.bottomleft, 0], x: 0, y: 1, o: 0} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 20:
                    return n & ui ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [0, t.leftbottom], x: 1, y: 0, o: 0};
                case 21:
                    return n & ci ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                case 22:
                    return n & ui ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 23:
                    return n & ci ? {p: [0, t.lefttop], x: 1, y: 0, o: 1} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                default:
                    console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(t)
            }
        }
        return null
    }

    function ro(t, e, n, r) {
        var i, o, s, a, u, c = t.cval;
        switch (e) {
            case-1:
                switch (r) {
                    case 0:
                        i = Yi[c], s = Ei[c], a = wi[c], u = bi[c];
                        break;
                    default:
                        i = Ui[c], s = mi[c], a = vi[c], u = xi[c]
                }
                break;
            case 1:
                switch (r) {
                    case 0:
                        i = Wi[c], s = Ti[c], a = Ai[c], u = Di[c];
                        break;
                    default:
                        i = Ji[c], s = Pi[c], a = Oi[c], u = Ri[c]
                }
                break;
            default:
                switch (n) {
                    case-1:
                        switch (r) {
                            case 0:
                                i = Zi[c], s = pi[c], a = fi[c], u = gi[c];
                                break;
                            default:
                                i = Ki[c], s = di[c], a = yi[c], u = _i[c]
                        }
                        break;
                    case 1:
                        switch (r) {
                            case 0:
                                i = Hi[c], s = Ii[c], a = Ni[c], u = Ci[c];
                                break;
                            default:
                                i = Vi[c], s = Si[c], a = Mi[c], u = Li[c]
                        }
                }
        }
        if (o = t.edges.indexOf(i), void 0 === t.edges[o]) return null;
        switch (function (t, e) {
            delete t.edges[e];
            for (var n = e + 1; n < t.edges.length; n++) t.edges[n - 1] = t.edges[n];
            t.edges.pop()
        }(t, o), c = t.cval_real, i) {
            case 0:
                n = c & ci ? (e = t.topleft, 1) : (e = 1, t.righttop);
                break;
            case 1:
                n = c & hi ? (e = 1, t.rightbottom) : (e = t.topleft, 1);
                break;
            case 2:
                n = c & hi ? (e = t.topleft, 1) : (e = t.bottomright, 0);
                break;
            case 3:
                n = c & li ? (e = t.bottomleft, 0) : (e = t.topleft, 1);
                break;
            case 4:
                n = c & ci ? (e = t.topright, 1) : (e = 1, t.righttop);
                break;
            case 5:
                n = c & hi ? (e = 1, t.rightbottom) : (e = t.topright, 1);
                break;
            case 6:
                n = c & hi ? (e = t.topright, 1) : (e = t.bottomright, 0);
                break;
            case 7:
                n = c & li ? (e = t.bottomleft, 0) : (e = t.topright, 1);
                break;
            case 8:
                n = c & hi ? (e = 1, t.righttop) : (e = t.bottomright, 0);
                break;
            case 9:
                n = c & li ? (e = t.bottomleft, 0) : (e = 1, t.righttop);
                break;
            case 10:
                n = c & li ? (e = 1, t.righttop) : (e = 0, t.leftbottom);
                break;
            case 11:
                n = c & ui ? (e = 0, t.lefttop) : (e = 1, t.righttop);
                break;
            case 12:
                n = c & hi ? (e = 1, t.rightbottom) : (e = t.bottomright, 0);
                break;
            case 13:
                n = c & li ? (e = t.bottomleft, 0) : (e = 1, t.rightbottom);
                break;
            case 14:
                n = c & li ? (e = 1, t.rightbottom) : (e = 0, t.leftbottom);
                break;
            case 15:
                n = c & ui ? (e = 0, t.lefttop) : (e = 1, t.rightbottom);
                break;
            case 16:
                n = c & hi ? (e = 0, t.leftbottom) : (e = t.bottomright, 0);
                break;
            case 17:
                n = c & ui ? (e = 0, t.lefttop) : (e = t.bottomright, 0);
                break;
            case 18:
                n = c & li ? (e = t.bottomleft, 0) : (e = 0, t.leftbottom);
                break;
            case 19:
                n = c & ui ? (e = 0, t.lefttop) : (e = t.bottomleft, 0);
                break;
            case 20:
                n = c & ui ? (e = 0, t.leftbottom) : (e = t.topleft, 1);
                break;
            case 21:
                n = c & ci ? (e = t.topright, 1) : (e = 0, t.leftbottom);
                break;
            case 22:
                n = c & ui ? (e = 0, t.lefttop) : (e = t.topleft, 1);
                break;
            case 23:
                n = c & ci ? (e = t.topright, 1) : (e = 0, t.lefttop);
                break;
            default:
                return console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(t), null
        }
        return void 0 !== e && void 0 !== n && void 0 !== s && void 0 !== a && void 0 !== u || (console.log("MarchingSquaresJS-isoBands: undefined value!"), console.log(t), console.log(e + " " + n + " " + s + " " + a + " " + u)), {
            p: [e, n],
            x: s,
            y: a,
            o: u
        }
    }

    function io(t) {
        var n = [], r = [];
        t.forEach(function (t) {
            var e = rr(B([t]));
            r.push(e), n.push({ring: t, area: e})
        }), r.sort(function (t, e) {
            return e - t
        });
        var i = [];
        return r.forEach(function (t) {
            for (var e = 0; e < n.length; e++) if (n[e].area === t) {
                i.push(n[e].ring), n.splice(e, 1);
                break
            }
        }), i
    }

    function oo(t) {
        for (var e = t.map(function (t) {
            return {lrCoordinates: t, grouped: !1}
        }), n = []; !ao(e);) for (var r = 0; r < e.length; r++) if (!e[r].grouped) {
            var i = [];
            i.push(e[r].lrCoordinates), e[r].grouped = !0;
            for (var o = B([e[r].lrCoordinates]), s = r + 1; s < e.length; s++) e[s].grouped || so(B([e[s].lrCoordinates]), o) && (i.push(e[s].lrCoordinates), e[s].grouped = !0);
            n.push(i)
        }
        return n
    }

    function so(t, e) {
        for (var n = We(t), r = 0; r < n.features.length; r++) if (!re(n.features[r], e)) return !1;
        return !0
    }

    function ao(t) {
        for (var e = 0; e < t.length; e++) if (!1 === t[e].grouped) return !1;
        return !0
    }

    function uo(t, i, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var o = e.pivot, n = e.mutate;
        if (!t) throw new Error("geojson is required");
        if (null == i || isNaN(i)) throw new Error("angle is required");
        return 0 === i || (o || (o = He(t)), !1 !== n && void 0 !== n || (t = le(t)), N(t, function (t) {
            var e = Un(o, t) + i, n = Vn(o, t), r = Z(Qr(o, n, e));
            t[0] = r[0], t[1] = r[1]
        })), t
    }

    function co(n, r, t) {
        if (!H(t = t || {})) throw new Error("options is invalid");
        var i = t.origin, e = t.mutate;
        if (!n) throw new Error("geojson required");
        if ("number" != typeof r || 0 === r) throw new Error("invalid factor");
        var o = Array.isArray(i) || "object" == typeof i;
        return !0 !== e && (n = le(n)), "FeatureCollection" !== n.type || o ? ho(n, r, i) : (L(n, function (t, e) {
            n.features[e] = ho(t, r, i)
        }), n)
    }

    function ho(t, i, o) {
        var e = "Point" === rt(t);
        return o = function (t, e) {
            if (null == e && (e = "centroid"), Array.isArray(e) || "object" == typeof e) return J(e);
            var n = t.bbox ? t.bbox : W(t), r = n[0], i = n[1], o = n[2], s = n[3];
            switch (e) {
                case"sw":
                case"southwest":
                case"westsouth":
                case"bottomleft":
                    return X([r, i]);
                case"se":
                case"southeast":
                case"eastsouth":
                case"bottomright":
                    return X([o, i]);
                case"nw":
                case"northwest":
                case"westnorth":
                case"topleft":
                    return X([r, s]);
                case"ne":
                case"northeast":
                case"eastnorth":
                case"topright":
                    return X([o, s]);
                case"center":
                    return Ve(t);
                case void 0:
                case null:
                case"centroid":
                    return He(t);
                default:
                    throw new Error("invalid origin")
            }
        }(t, o), 1 === i || e || N(t, function (t) {
            var e = Vn(o, t), n = Un(o, t), r = Z(Qr(o, e * i, n));
            t[0] = r[0], t[1] = r[1], 3 === t.length && (t[2] *= i)
        }), t
    }

    function lo(t) {
        var e = t[0], n = t[1];
        return [n[0] - e[0], n[1] - e[1]]
    }

    function po(t, e) {
        return t[0] * e[1] - e[0] * t[1]
    }

    function fo(t, e, n) {
        var S = [], M = l(e, n), L = Z(t), P = [];
        return L.forEach(function (t, e) {
            if (e !== L.length - 1) {
                var n = (E = t, w = L[e + 1], b = M, I = Math.sqrt((E[0] - w[0]) * (E[0] - w[0]) + (E[1] - w[1]) * (E[1] - w[1])), N = E[0] + b * (w[1] - E[1]) / I, C = w[0] + b * (w[1] - E[1]) / I, [[N, E[1] + b * (E[0] - w[0]) / I], [C, w[1] + b * (E[0] - w[0]) / I]]);
                if (S.push(n), 0 < e) {
                    var r = S[e - 1],
                        i = (a = s = r, 0 !== po(lo(o = n), lo(a)) && (c = s, y = (u = o)[0], _ = lo(u), m = c[0], x = po(_, v = lo(c)), f = [(g = po((l = p = y, [(h = m)[0] - l[0], h[1] - l[1]]), v) / x) * (d = _)[0], g * d[1]], [p[0] + f[0], p[1] + f[1]]));
                    !1 !== i && (r[1] = i, n[0] = i), P.push(r[0]), e === L.length - 2 && (P.push(n[0]), P.push(n[1]))
                }
                2 === L.length && (P.push(n[0]), P.push(n[1]))
            }
            var o, s, a, u, c, h, l, p, f, g, d, y, _, m, v, x, E, w, b, I, N, C
        }), U(P, t.properties)
    }

    function go(t, e, n) {
        var r = e[0] - t[0], i = e[1] - t[1], o = n[0] - e[0], s = n[1] - e[1];
        return Math.sign(r * s - o * i)
    }

    function yo(e, t) {
        return t.geometry.coordinates[0].every(function (t) {
            return re(X(t), e)
        })
    }

    Qi[1] = Qi[169] = Fi, Qi[4] = Qi[166] = qi, Qi[16] = Qi[154] = Gi, Qi[64] = Qi[106] = Bi, Qi[168] = Qi[2] = ki, Qi[162] = Qi[8] = zi, Qi[138] = Qi[32] = ji, Qi[42] = Qi[128] = Xi, Qi[5] = Qi[165] = function (t) {
        return [[0, 0], [0, t.leftbottom], [1, t.rightbottom], [1, 0]]
    }, Qi[20] = Qi[150] = function (t) {
        return [[1, 0], [t.bottomright, 0], [t.topright, 1], [1, 1]]
    }, Qi[80] = Qi[90] = function (t) {
        return [[1, 1], [1, t.righttop], [0, t.lefttop], [0, 1]]
    }, Qi[65] = Qi[105] = function (t) {
        return [[t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]]
    }, Qi[160] = Qi[10] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [0, t.leftbottom], [0, t.lefttop]]
    }, Qi[130] = Qi[40] = function (t) {
        return [[t.topleft, 1], [t.topright, 1], [t.bottomright, 0], [t.bottomleft, 0]]
    }, Qi[85] = function () {
        return [[0, 0], [0, 1], [1, 1], [1, 0]]
    }, Qi[101] = Qi[69] = function (t) {
        return [[1, t.rightbottom], [1, 0], [0, 0], [0, 1], [t.topleft, 1]]
    }, Qi[149] = Qi[21] = function (t) {
        return [[t.topright, 1], [1, 1], [1, 0], [0, 0], [0, t.leftbottom]]
    }, Qi[86] = Qi[84] = function (t) {
        return [[1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [1, 1]]
    }, Qi[89] = Qi[81] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, 1]]
    }, Qi[96] = Qi[74] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, Qi[24] = Qi[146] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [t.topright, 1]]
    }, Qi[6] = Qi[164] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop]]
    }, Qi[129] = Qi[41] = function (t) {
        return [[t.topright, 1], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1]]
    }, Qi[66] = Qi[104] = function (t) {
        return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, Qi[144] = Qi[26] = function (t) {
        return [[1, 1], [1, t.righttop], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
    }, Qi[36] = Qi[134] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [t.topleft, 1], [t.topright, 1]]
    }, Qi[9] = Qi[161] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom]]
    }, Qi[37] = Qi[133] = function (t) {
        return [[1, t.rightbottom], [1, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]]
    }, Qi[148] = Qi[22] = function (t) {
        return [[1, 1], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
    }, Qi[82] = Qi[88] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1]]
    }, Qi[73] = Qi[97] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]]
    }, Qi[145] = Qi[25] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]]
    }, Qi[70] = Qi[100] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, Qi[34] = function (t) {
        return [Xi(t), zi(t)]
    }, Qi[35] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
    }, Qi[136] = function (t) {
        return [ji(t), ki(t)]
    }, Qi[153] = function (t) {
        return [Gi(t), Fi(t)]
    }, Qi[102] = function (t) {
        return [qi(t), Bi(t)]
    }, Qi[155] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]]
    }, Qi[103] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, Qi[152] = function (t) {
        return [Gi(t), ki(t)]
    }, Qi[156] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
    }, Qi[137] = function (t) {
        return [ji(t), Fi(t)]
    }, Qi[139] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]]
    }, Qi[98] = function (t) {
        return [zi(t), Bi(t)]
    }, Qi[99] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, Qi[38] = function (t) {
        return [qi(t), Xi(t)]
    }, Qi[39] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
    };
    var _o = function t(e) {
        this.id = t.buildId(e), this.coordinates = e, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = !1
    };
    _o.buildId = function (t) {
        return t.join(",")
    }, _o.prototype.removeInnerEdge = function (e) {
        this.innerEdges = this.innerEdges.filter(function (t) {
            return t.from.id !== e.from.id
        })
    }, _o.prototype.removeOuterEdge = function (e) {
        this.outerEdges = this.outerEdges.filter(function (t) {
            return t.to.id !== e.to.id
        })
    }, _o.prototype.addOuterEdge = function (t) {
        this.outerEdges.push(t), this.outerEdgesSorted = !1
    }, _o.prototype.sortOuterEdges = function () {
        var o = this;
        this.outerEdgesSorted || (this.outerEdges.sort(function (t, e) {
            var n = t.to, r = e.to;
            if (0 <= n.coordinates[0] - o.coordinates[0] && r.coordinates[0] - o.coordinates[0] < 0) return 1;
            if (n.coordinates[0] - o.coordinates[0] < 0 && 0 <= r.coordinates[0] - o.coordinates[0]) return -1;
            if (n.coordinates[0] - o.coordinates[0] == 0 && r.coordinates[0] - o.coordinates[0] == 0) return 0 <= n.coordinates[1] - o.coordinates[1] || 0 <= r.coordinates[1] - o.coordinates[1] ? n.coordinates[1] - r.coordinates[1] : r.coordinates[1] - n.coordinates[1];
            var i = go(o.coordinates, n.coordinates, r.coordinates);
            return i < 0 ? 1 : 0 < i ? -1 : Math.pow(n.coordinates[0] - o.coordinates[0], 2) + Math.pow(n.coordinates[1] - o.coordinates[1], 2) - (Math.pow(r.coordinates[0] - o.coordinates[0], 2) + Math.pow(r.coordinates[1] - o.coordinates[1], 2))
        }), this.outerEdgesSorted = !0)
    }, _o.prototype.getOuterEdges = function () {
        return this.sortOuterEdges(), this.outerEdges
    }, _o.prototype.getOuterEdge = function (t) {
        return this.sortOuterEdges(), this.outerEdges[t]
    }, _o.prototype.addInnerEdge = function (t) {
        this.innerEdges.push(t)
    };
    var mo = function (t, e) {
        this.from = t, this.to = e, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this)
    };
    mo.prototype.getSymetric = function () {
        return this.symetric || (this.symetric = new mo(this.to, this.from), this.symetric.symetric = this), this.symetric
    }, mo.prototype.deleteEdge = function () {
        this.from.removeOuterEdge(this), this.to.removeInnerEdge(this)
    }, mo.prototype.isEqual = function (t) {
        return this.from.id === t.from.id && this.to.id === t.to.id
    }, mo.prototype.toString = function () {
        return "Edge { " + this.from.id + " -> " + this.to.id + " }"
    }, mo.prototype.toLineString = function () {
        return U([this.from.coordinates, this.to.coordinates])
    }, mo.prototype.compareTo = function (t) {
        return go(t.from.coordinates, t.to.coordinates, this.to.coordinates)
    };
    var vo = function () {
        this.edges = [], this.polygon = void 0, this.envelope = void 0
    }, xo = {length: {configurable: !0}};
    vo.prototype.push = function (t) {
        this[this.edges.length] = t, this.edges.push(t), this.polygon = this.envelope = void 0
    }, vo.prototype.get = function (t) {
        return this.edges[t]
    }, xo.length.get = function () {
        return this.edges.length
    }, vo.prototype.forEach = function (t) {
        this.edges.forEach(t)
    }, vo.prototype.map = function (t) {
        return this.edges.map(t)
    }, vo.prototype.some = function (t) {
        return this.edges.some(t)
    }, vo.prototype.isValid = function () {
        return !0
    }, vo.prototype.isHole = function () {
        var r = this, t = this.edges.reduce(function (t, e, n) {
                return e.from.coordinates[1] > r.edges[t].from.coordinates[1] && (t = n), t
            }, 0), e = (0 === t ? this.length : t) - 1, n = (t + 1) % this.length,
            i = go(this.edges[e].from.coordinates, this.edges[t].from.coordinates, this.edges[n].from.coordinates);
        return 0 === i ? this.edges[e].from.coordinates[0] > this.edges[n].from.coordinates[0] : 0 < i
    }, vo.prototype.toMultiPoint = function () {
        return u(this.edges.map(function (t) {
            return t.from.coordinates
        }))
    }, vo.prototype.toPolygon = function () {
        if (this.polygon) return this.polygon;
        var t = this.edges.map(function (t) {
            return t.from.coordinates
        });
        return t.push(this.edges[0].from.coordinates), this.polygon = B([t])
    }, vo.prototype.getEnvelope = function () {
        return this.envelope ? this.envelope : this.envelope = ze(this.toPolygon())
    }, vo.findEdgeRingContaining = function (c, t) {
        var h, l, p = c.getEnvelope();
        return t.forEach(function (t) {
            var e, n, r, i, o, s, a = t.getEnvelope();
            if (l && (h = l.getEnvelope()), n = p, r = (e = a).geometry.coordinates.map(function (t) {
                return t[0]
            }), i = e.geometry.coordinates.map(function (t) {
                return t[1]
            }), o = n.geometry.coordinates.map(function (t) {
                return t[0]
            }), s = n.geometry.coordinates.map(function (t) {
                return t[1]
            }), (Math.max(null, r) !== Math.max(null, o) || Math.max(null, i) !== Math.max(null, s) || Math.min(null, r) !== Math.min(null, o) || Math.min(null, i) !== Math.min(null, s)) && yo(a, p)) {
                var u = c.map(function (t) {
                    return t.from.coordinates
                }).find(function (r) {
                    return !t.some(function (t) {
                        return e = r, n = t.from.coordinates, e[0] === n[0] && e[1] === n[1];
                        var e, n
                    })
                });
                u && t.inside(X(u)) && (l && !yo(h, a) || (l = t))
            }
        }), l
    }, vo.prototype.inside = function (t) {
        return re(t, this.toPolygon())
    }, Object.defineProperties(vo.prototype, xo);
    var Eo = function () {
        this.edges = [], this.nodes = {}
    };

    function wo(t, e) {
        for (var n = 0; n < t.coordinates.length - 1; n++) if (r = t.coordinates[n], i = t.coordinates[n + 1], o = e.coordinates, void 0, s = o[0] - r[0], a = o[1] - r[1], u = i[0] - r[0], c = i[1] - r[1], 0 == s * c - a * u && (Math.abs(u) >= Math.abs(c) ? 0 < u ? r[0] <= o[0] && o[0] <= i[0] : i[0] <= o[0] && o[0] <= r[0] : 0 < c ? r[1] <= o[1] && o[1] <= i[1] : i[1] <= o[1] && o[1] <= r[1])) return !0;
        var r, i, o, s, a, u, c;
        return !1
    }

    function bo(t, e) {
        return 0 < zn(e, Ar(t)).features.length
    }

    function Io(t, e) {
        return !(t[0] > e[0] || t[2] < e[2] || t[1] > e[1] || t[3] < e[3])
    }

    function No(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function Co(t, e) {
        for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r;) {
            for (var s = 0; s < e.coordinates.length - 1; s++) {
                var a = !0;
                0 !== s && s !== e.coordinates.length - 2 || (a = !1), Lo(e.coordinates[s], e.coordinates[s + 1], t.coordinates[o], a) ? n = !0 : r = !0
            }
            o++
        }
        return n && r
    }

    function So(t, e) {
        return 0 < zn(t, Ar(e)).features.length
    }

    function Mo(t, e) {
        for (var n = !1, r = !1, i = t.coordinates[0].length, o = 0; o < i && n && r;) re(X(t.coordinates[0][o]), e) ? n = !0 : r = !0, o++;
        return r && r
    }

    function Lo(t, e, n, r) {
        var i = n[0] - t[0], o = n[1] - t[1], s = e[0] - t[0], a = e[1] - t[1];
        return 0 == i * a - o * s && (r ? Math.abs(s) >= Math.abs(a) ? 0 < s ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : 0 < a ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1] : Math.abs(s) >= Math.abs(a) ? 0 < s ? t[0] < n[0] && n[0] < e[0] : e[0] < n[0] && n[0] < t[0] : 0 < a ? t[1] < n[1] && n[1] < e[1] : e[1] < n[1] && n[1] < t[1])
    }

    Eo.fromGeoJson = function (t) {
        !function (t) {
            if (!t) throw new Error("No geojson passed");
            if ("FeatureCollection" !== t.type && "GeometryCollection" !== t.type && "MultiLineString" !== t.type && "LineString" !== t.type && "Feature" !== t.type) throw new Error("Invalid input type '" + t.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature")
        }(t);
        var i = new Eo;
        return A(t, function (t) {
            $(t, "LineString", "Graph::fromGeoJson"), C(t, function (t, e) {
                if (t) {
                    var n = i.getNode(t), r = i.getNode(e);
                    i.addEdge(n, r)
                }
                return e
            })
        }), i
    }, Eo.prototype.getNode = function (t) {
        var e = _o.buildId(t), n = this.nodes[e];
        return n || (n = this.nodes[e] = new _o(t)), n
    }, Eo.prototype.addEdge = function (t, e) {
        var n = new mo(t, e), r = n.getSymetric();
        this.edges.push(n), this.edges.push(r)
    }, Eo.prototype.deleteDangles = function () {
        var e = this;
        Object.keys(this.nodes).map(function (t) {
            return e.nodes[t]
        }).forEach(function (t) {
            return e._removeIfDangle(t)
        })
    }, Eo.prototype._removeIfDangle = function (t) {
        var e = this;
        if (t.innerEdges.length <= 1) {
            var n = t.getOuterEdges().map(function (t) {
                return t.to
            });
            this.removeNode(t), n.forEach(function (t) {
                return e._removeIfDangle(t)
            })
        }
    }, Eo.prototype.deleteCutEdges = function () {
        var e = this;
        this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach(function (t) {
            t.label === t.symetric.label && (e.removeEdge(t.symetric), e.removeEdge(t))
        })
    }, Eo.prototype._computeNextCWEdges = function (n) {
        var e = this;
        void 0 === n ? Object.keys(this.nodes).forEach(function (t) {
            return e._computeNextCWEdges(e.nodes[t])
        }) : n.getOuterEdges().forEach(function (t, e) {
            n.getOuterEdge((0 === e ? n.getOuterEdges().length : e) - 1).symetric.next = t
        })
    }, Eo.prototype._computeNextCCWEdges = function (t, e) {
        for (var n, r, i = t.getOuterEdges(), o = i.length - 1; 0 <= o; --o) {
            var s = i[o], a = s.symetric, u = void 0, c = void 0;
            s.label === e && (u = s), a.label === e && (c = a), u && c && (c && (r = c), u && (r && (r.next = u, r = void 0), n || (n = u)))
        }
        r && (r.next = n)
    }, Eo.prototype._findLabeledEdgeRings = function () {
        var n = [], r = 0;
        return this.edges.forEach(function (t) {
            if (!(0 <= t.label)) {
                n.push(t);
                for (var e = t; e.label = r, e = e.next, !t.isEqual(e);) ;
                r++
            }
        }), n
    }, Eo.prototype.getEdgeRings = function () {
        var n = this;
        this._computeNextCWEdges(), this.edges.forEach(function (t) {
            t.label = void 0
        }), this._findLabeledEdgeRings().forEach(function (e) {
            n._findIntersectionNodes(e).forEach(function (t) {
                n._computeNextCCWEdges(t, e.label)
            })
        });
        var e = [];
        return this.edges.forEach(function (t) {
            t.ring || e.push(n._findEdgeRing(t))
        }), e
    }, Eo.prototype._findIntersectionNodes = function (n) {
        for (var t = [], r = n, e = function () {
            var e = 0;
            r.from.getOuterEdges().forEach(function (t) {
                t.label === n.label && ++e
            }), 1 < e && t.push(r.from), r = r.next
        }; e(), !n.isEqual(r);) ;
        return t
    }, Eo.prototype._findEdgeRing = function (t) {
        for (var e = t, n = new vo; n.push(e), e.ring = n, e = e.next, !t.isEqual(e);) ;
        return n
    }, Eo.prototype.removeNode = function (t) {
        var e = this;
        t.getOuterEdges().forEach(function (t) {
            return e.removeEdge(t)
        }), t.innerEdges.forEach(function (t) {
            return e.removeEdge(t)
        }), delete this.nodes[t.id]
    }, Eo.prototype.removeEdge = function (e) {
        this.edges = this.edges.filter(function (t) {
            return !t.isEqual(e)
        }), e.deleteEdge()
    };
    var Po = Lt(function (t, e) {
        function n(t) {
            var e = [];
            for (var n in t) e.push(n);
            return e
        }

        (t.exports = "function" == typeof Object.keys ? Object.keys : n).shim = n
    }), Oo = (Po.shim, Lt(function (t, e) {
        var n = "[object Arguments]" == function () {
            return Object.prototype.toString.call(arguments)
        }();

        function r(t) {
            return "[object Arguments]" == Object.prototype.toString.call(t)
        }

        function i(t) {
            return t && "object" == typeof t && "number" == typeof t.length && Object.prototype.hasOwnProperty.call(t, "callee") && !Object.prototype.propertyIsEnumerable.call(t, "callee") || !1
        }

        (e = t.exports = n ? r : i).supported = r, e.unsupported = i
    })), Ro = (Oo.supported, Oo.unsupported, Lt(function (t) {
        var a = Array.prototype.slice, u = t.exports = function (t, e, n) {
            return n || (n = {}), t === e || (t instanceof Date && e instanceof Date ? t.getTime() === e.getTime() : !t || !e || "object" != typeof t && "object" != typeof e ? n.strict ? t === e : t == e : function (t, e, n) {
                var r, i;
                if (c(t) || c(e)) return !1;
                if (t.prototype !== e.prototype) return !1;
                if (Oo(t)) return !!Oo(e) && (t = a.call(t), e = a.call(e), u(t, e, n));
                if (h(t)) {
                    if (!h(e)) return !1;
                    if (t.length !== e.length) return !1;
                    for (r = 0; r < t.length; r++) if (t[r] !== e[r]) return !1;
                    return !0
                }
                try {
                    var o = Po(t), s = Po(e)
                } catch (t) {
                    return !1
                }
                if (o.length != s.length) return !1;
                for (o.sort(), s.sort(), r = o.length - 1; 0 <= r; r--) if (o[r] != s[r]) return !1;
                for (r = o.length - 1; 0 <= r; r--) if (i = o[r], !u(t[i], e[i], n)) return !1;
                return typeof t == typeof e
            }(t, e, n))
        };

        function c(t) {
            return null == t
        }

        function h(t) {
            return !(!t || "object" != typeof t || "number" != typeof t.length || "function" != typeof t.copy || "function" != typeof t.slice || 0 < t.length && "number" != typeof t[0])
        }
    })), To = function (t) {
        this.precision = t && t.precision ? t.precision : 17, this.direction = !(!t || !t.direction) && t.direction, this.pseudoNode = !(!t || !t.pseudoNode) && t.pseudoNode, this.objectComparator = t && t.objectComparator ? t.objectComparator : Fo
    };

    function Ao(e) {
        return e.coordinates.map(function (t) {
            return {type: e.type.replace("Multi", ""), coordinates: t}
        })
    }

    function Do(t, e) {
        return t.hasOwnProperty("coordinates") ? t.coordinates.length === e.coordinates.length : t.length === e.length
    }

    function Fo(t, e) {
        return Ro(t, e, {strict: !0})
    }

    To.prototype.compare = function (t, e) {
        if (t.type !== e.type || !Do(t, e)) return !1;
        switch (t.type) {
            case"Point":
                return this.compareCoord(t.coordinates, e.coordinates);
            case"LineString":
                return this.compareLine(t.coordinates, e.coordinates, 0, !1);
            case"Polygon":
                return this.comparePolygon(t, e);
            case"Feature":
                return this.compareFeature(t, e);
            default:
                if (0 === t.type.indexOf("Multi")) {
                    var n = this, r = Ao(t), i = Ao(e);
                    return r.every(function (e) {
                        return this.some(function (t) {
                            return n.compare(e, t)
                        })
                    }, i)
                }
        }
        return !1
    }, To.prototype.compareCoord = function (t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0; n < t.length; n++) if (t[n].toFixed(this.precision) !== e[n].toFixed(this.precision)) return !1;
        return !0
    }, To.prototype.compareLine = function (t, e, n, r) {
        if (!Do(t, e)) return !1;
        var i = this.pseudoNode ? t : this.removePseudo(t), o = this.pseudoNode ? e : this.removePseudo(e);
        if (!r || this.compareCoord(i[0], o[0]) || (o = this.fixStartIndex(o, i))) {
            var s = this.compareCoord(i[n], o[n]);
            return this.direction || s ? this.comparePath(i, o) : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o)
        }
    }, To.prototype.fixStartIndex = function (t, e) {
        for (var n, r = -1, i = 0; i < t.length; i++) if (this.compareCoord(t[i], e[0])) {
            r = i;
            break
        }
        return 0 <= r && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n
    }, To.prototype.comparePath = function (t, e) {
        var n = this;
        return t.every(function (t, e) {
            return n.compareCoord(t, this[e])
        }, e)
    }, To.prototype.comparePolygon = function (t, e) {
        if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) {
            var n = t.coordinates.slice(1, t.coordinates.length), r = e.coordinates.slice(1, e.coordinates.length),
                i = this;
            return n.every(function (e) {
                return this.some(function (t) {
                    return i.compareLine(e, t, 1, !0)
                })
            }, r)
        }
        return !1
    }, To.prototype.compareFeature = function (t, e) {
        return !(t.id !== e.id || !this.objectComparator(t.properties, e.properties) || !this.compareBBox(t, e)) && this.compare(t.geometry, e.geometry)
    }, To.prototype.compareBBox = function (t, e) {
        return !!(!t.bbox && !e.bbox || t.bbox && e.bbox && this.compareCoord(t.bbox, e.bbox))
    }, To.prototype.removePseudo = function (t) {
        return t
    };
    var qo = To;

    function Go(t, n) {
        if (!t) throw new Error("feature1 is required");
        if (!n) throw new Error("feature2 is required");
        var e = rt(t);
        if (e !== rt(n)) throw new Error("features must be of the same type");
        if ("Point" === e) throw new Error("Point geometry not supported");
        if (new qo({precision: 6}).compare(t, n)) return !1;
        var r = 0;
        switch (e) {
            case"MultiPoint":
                var i = O(t), o = O(n);
                i.forEach(function (e) {
                    o.forEach(function (t) {
                        e[0] === t[0] && e[1] === t[1] && r++
                    })
                });
                break;
            case"LineString":
            case"MultiLineString":
                F(t, function (e) {
                    F(n, function (t) {
                        Jr(e, t).features.length && r++
                    })
                });
                break;
            case"Polygon":
            case"MultiPolygon":
                F(t, function (e) {
                    F(n, function (t) {
                        zn(e, t).features.length && r++
                    })
                })
        }
        return 0 < r
    }

    var Bo = Lt(function (t) {
        function e(t, e, n, r) {
            this.dataset = [], this.epsilon = 1, this.minPts = 2, this.distance = this._euclideanDistance, this.clusters = [], this.noise = [], this._visited = [], this._assigned = [], this._datasetLength = 0, this._init(t, e, n, r)
        }

        e.prototype.run = function (t, e, n, r) {
            this._init(t, e, n, r);
            for (var i = 0; i < this._datasetLength; i++) if (1 !== this._visited[i]) {
                this._visited[i] = 1;
                var o = this._regionQuery(i);
                if (o.length < this.minPts) this.noise.push(i); else {
                    var s = this.clusters.length;
                    this.clusters.push([]), this._addToCluster(i, s), this._expandCluster(s, o)
                }
            }
            return this.clusters
        }, e.prototype._init = function (t, e, n, r) {
            if (t) {
                if (!(t instanceof Array)) throw Error("Dataset must be of type array, " + typeof t + " given");
                this.dataset = t, this.clusters = [], this.noise = [], this._datasetLength = t.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength)
            }
            e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r)
        }, e.prototype._expandCluster = function (t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                if (1 !== this._visited[r]) {
                    this._visited[r] = 1;
                    var i = this._regionQuery(r);
                    i.length >= this.minPts && (e = this._mergeArrays(e, i))
                }
                1 !== this._assigned[r] && this._addToCluster(r, t)
            }
        }, e.prototype._addToCluster = function (t, e) {
            this.clusters[e].push(t), this._assigned[t] = 1
        }, e.prototype._regionQuery = function (t) {
            for (var e = [], n = 0; n < this._datasetLength; n++) this.distance(this.dataset[t], this.dataset[n]) < this.epsilon && e.push(n);
            return e
        }, e.prototype._mergeArrays = function (t, e) {
            for (var n = e.length, r = 0; r < n; r++) {
                var i = e[r];
                t.indexOf(i) < 0 && t.push(i)
            }
            return t
        }, e.prototype._euclideanDistance = function (t, e) {
            for (var n = 0, r = Math.min(t.length, e.length); r--;) n += (t[r] - e[r]) * (t[r] - e[r]);
            return Math.sqrt(n)
        }, t.exports && (t.exports = e)
    }), ko = Lt(function (t) {
        function e(t, e, n) {
            this.k = 3, this.dataset = [], this.assignments = [], this.centroids = [], this.init(t, e, n)
        }

        e.prototype.init = function (t, e, n) {
            this.assignments = [], this.centroids = [], void 0 !== t && (this.dataset = t), void 0 !== e && (this.k = e), void 0 !== n && (this.distance = n)
        }, e.prototype.run = function (t, e) {
            this.init(t, e);
            for (var n = this.dataset.length, r = 0; r < this.k; r++) this.centroids[r] = this.randomCentroid();
            for (var i = !0; i;) {
                i = this.assign();
                for (var o = 0; o < this.k; o++) {
                    for (var s = new Array(h), a = 0, u = 0; u < h; u++) s[u] = 0;
                    for (var c = 0; c < n; c++) {
                        var h = this.dataset[c].length;
                        if (o === this.assignments[c]) {
                            for (u = 0; u < h; u++) s[u] += this.dataset[c][u];
                            a++
                        }
                    }
                    if (0 < a) {
                        for (u = 0; u < h; u++) s[u] /= a;
                        this.centroids[o] = s
                    } else this.centroids[o] = this.randomCentroid(), i = !0
                }
            }
            return this.getClusters()
        }, e.prototype.randomCentroid = function () {
            for (var t, e, n = this.dataset.length - 1; e = Math.round(Math.random() * n), t = this.dataset[e], 0 <= this.centroids.indexOf(t);) ;
            return t
        }, e.prototype.assign = function () {
            for (var t, e = !1, n = this.dataset.length, r = 0; r < n; r++) (t = this.argmin(this.dataset[r], this.centroids, this.distance)) != this.assignments[r] && (this.assignments[r] = t, e = !0);
            return e
        }, e.prototype.getClusters = function () {
            for (var t, e = new Array(this.k), n = 0; n < this.assignments.length; n++) void 0 === e[t = this.assignments[n]] && (e[t] = []), e[t].push(n);
            return e
        }, e.prototype.argmin = function (t, e, n) {
            for (var r, i = Number.MAX_VALUE, o = 0, s = e.length, a = 0; a < s; a++) (r = n(t, e[a])) < i && (i = r, o = a);
            return o
        }, e.prototype.distance = function (t, e) {
            for (var n = 0, r = Math.min(t.length, e.length); r--;) {
                var i = t[r] - e[r];
                n += i * i
            }
            return Math.sqrt(n)
        }, t.exports && (t.exports = e)
    }), zo = Lt(function (t) {
        function e(t, e, n) {
            this._queue = [], this._priorities = [], this._sorting = "desc", this._init(t, e, n)
        }

        e.prototype.insert = function (t, e) {
            for (var n = this._queue.length, r = n; r--;) {
                var i = this._priorities[r];
                "desc" === this._sorting ? i < e && (n = r) : e < i && (n = r)
            }
            this._insertAt(t, e, n)
        }, e.prototype.remove = function (t) {
            for (var e = this._queue.length; e--;) if (t === this._queue[e]) {
                this._queue.splice(e, 1), this._priorities.splice(e, 1);
                break
            }
        }, e.prototype.forEach = function (t) {
            this._queue.forEach(t)
        }, e.prototype.getElements = function () {
            return this._queue
        }, e.prototype.getElementPriority = function (t) {
            return this._priorities[t]
        }, e.prototype.getPriorities = function () {
            return this._priorities
        }, e.prototype.getElementsWithPriorities = function () {
            for (var t = [], e = 0, n = this._queue.length; e < n; e++) t.push([this._queue[e], this._priorities[e]]);
            return t
        }, e.prototype._init = function (t, e, n) {
            if (t && e) {
                if (this._queue = [], this._priorities = [], t.length !== e.length) throw new Error("Arrays must have the same length");
                for (var r = 0; r < t.length; r++) this.insert(t[r], e[r])
            }
            n && (this._sorting = n)
        }, e.prototype._insertAt = function (t, e, n) {
            this._queue.length === n ? (this._queue.push(t), this._priorities.push(e)) : (this._queue.splice(n, 0, t), this._priorities.splice(n, 0, e))
        }, t.exports && (t.exports = e)
    }), jo = Lt(function (t) {
        if (t.exports) var c = zo;

        function e(t, e, n, r) {
            this.epsilon = 1, this.minPts = 1, this.distance = this._euclideanDistance, this._reachability = [], this._processed = [], this._coreDistance = 0, this._orderedList = [], this._init(t, e, n, r)
        }

        e.prototype.run = function (t, e, n, r) {
            this._init(t, e, n, r);
            for (var i = 0, o = this.dataset.length; i < o; i++) if (1 !== this._processed[i]) {
                this._processed[i] = 1, this.clusters.push([i]);
                var s = this.clusters.length - 1;
                this._orderedList.push(i);
                var a = new c(null, null, "asc"), u = this._regionQuery(i);
                void 0 !== this._distanceToCore(i) && (this._updateQueue(i, u, a), this._expandCluster(s, a))
            }
            return this.clusters
        }, e.prototype.getReachabilityPlot = function () {
            for (var t = [], e = 0, n = this._orderedList.length; e < n; e++) {
                var r = this._orderedList[e], i = this._reachability[r];
                t.push([r, i])
            }
            return t
        }, e.prototype._init = function (t, e, n, r) {
            if (t) {
                if (!(t instanceof Array)) throw Error("Dataset must be of type array, " + typeof t + " given");
                this.dataset = t, this.clusters = [], this._reachability = new Array(this.dataset.length), this._processed = new Array(this.dataset.length), this._coreDistance = 0, this._orderedList = []
            }
            e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r)
        }, e.prototype._updateQueue = function (r, t, i) {
            var o = this;
            this._coreDistance = this._distanceToCore(r), t.forEach(function (t) {
                if (void 0 === o._processed[t]) {
                    var e = o.distance(o.dataset[r], o.dataset[t]), n = Math.max(o._coreDistance, e);
                    void 0 === o._reachability[t] ? (o._reachability[t] = n, i.insert(t, n)) : n < o._reachability[t] && (o._reachability[t] = n, i.remove(t), i.insert(t, n))
                }
            })
        }, e.prototype._expandCluster = function (t, e) {
            for (var n = e.getElements(), r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                if (void 0 === this._processed[o]) {
                    var s = this._regionQuery(o);
                    this._processed[o] = 1, this.clusters[t].push(o), this._orderedList.push(o), void 0 !== this._distanceToCore(o) && (this._updateQueue(o, s, e), this._expandCluster(t, e))
                }
            }
        }, e.prototype._distanceToCore = function (t) {
            for (var e = this.epsilon, n = 0; n < e; n++) if (this._regionQuery(t, n).length >= this.minPts) return n
        }, e.prototype._regionQuery = function (t, e) {
            e = e || this.epsilon;
            for (var n = [], r = 0, i = this.dataset.length; r < i; r++) this.distance(this.dataset[t], this.dataset[r]) < e && n.push(r);
            return n
        }, e.prototype._euclideanDistance = function (t, e) {
            for (var n = 0, r = Math.min(t.length, e.length); r--;) n += (t[r] - e[r]) * (t[r] - e[r]);
            return Math.sqrt(n)
        }, t.exports && (t.exports = e)
    }), Xo = Lt(function (t) {
        t.exports && (t.exports = {DBSCAN: Bo, KMEANS: ko, OPTICS: jo, PriorityQueue: zo})
    });
    Xo.DBSCAN, Xo.KMEANS, Xo.OPTICS, Xo.PriorityQueue;
    var Uo = function (t, e, n) {
        for (var r = t.length, i = 0, o = 0; o < r; o++) {
            var s = (t[o] || 0) - (e[o] || 0);
            i += s * s
        }
        return n ? Math.sqrt(i) : i
    }, Yo = Uo, Vo = function (t, e, n) {
        var r = Math.abs(t - e);
        return n ? r : r * r
    }, Ho = Uo;

    function Wo(t, e, n) {
        n = n || [];
        for (var r = 0; r < t; r++) n[r] = e;
        return n
    }

    var Jo = function (t, e, n, r) {
        var i = [], o = [], s = [], a = [], u = !1, c = r || 1e4, h = t.length, l = t[0].length, p = 0 < l, f = [];
        if (n) i = "kmrand" == n ? function (t, e) {
            for (var n = {}, r = [], i = e << 2, o = t.length, s = 0 < t[0].length; r.length < e && 0 < i--;) {
                var a = t[Math.floor(Math.random() * o)], u = s ? a.join("_") : "" + a;
                n[u] || (n[u] = !0, r.push(a))
            }
            if (r.length < e) throw new Error("Error initializating clusters");
            return r
        }(t, e) : "kmpp" == n ? function (t, e) {
            var n = t[0].length ? Yo : Vo, r = [], i = t.length, o = 0 < t[0].length,
                s = t[Math.floor(Math.random() * i)];
            for (o && s.join("_"), r.push(s); r.length < e;) {
                for (var a = [], u = r.length, c = 0, h = [], l = 0; l < i; l++) {
                    for (var p = 1 / 0, f = 0; f < u; f++) {
                        var g = n(t[l], r[f]);
                        g <= p && (p = g)
                    }
                    a[l] = p
                }
                for (var d = 0; d < i; d++) c += a[d];
                for (var y = 0; y < i; y++) h[y] = {i: y, v: t[y], pr: a[y] / c, cs: 0};
                h.sort(function (t, e) {
                    return t.pr - e.pr
                }), h[0].cs = h[0].pr;
                for (var _ = 1; _ < i; _++) h[_].cs = h[_ - 1].cs + h[_].pr;
                for (var m = Math.random(), v = 0; v < i - 1 && h[v++].cs < m;) ;
                r.push(h[v - 1].v)
            }
            return r
        }(t, e) : n; else for (var g = {}; i.length < e;) {
            var d = Math.floor(Math.random() * h);
            g[d] || (g[d] = !0, i.push(t[d]))
        }
        do {
            Wo(e, 0, f);
            for (var y = 0; y < h; y++) {
                for (var _ = 1 / 0, m = 0, v = 0; v < e; v++) (a = p ? Ho(t[y], i[v]) : Math.abs(t[y] - i[v])) <= _ && (_ = a, m = v);
                f[s[y] = m]++
            }
            for (var x = [], E = (o = [], 0); E < e; E++) x[E] = p ? Wo(l, 0, x[E]) : 0, o[E] = i[E];
            if (p) {
                for (var w = 0; w < e; w++) i[w] = [];
                for (var b = 0; b < h; b++) for (var I = x[s[b]], N = t[b], C = 0; C < l; C++) I[C] += N[C];
                u = !0;
                for (var S = 0; S < e; S++) {
                    for (var M = i[S], L = x[S], P = o[S], O = f[S], R = 0; R < l; R++) M[R] = L[R] / O || 0;
                    if (u) for (var T = 0; T < l; T++) if (P[T] != M[T]) {
                        u = !1;
                        break
                    }
                }
            } else {
                for (var A = 0; A < h; A++) x[s[A]] += t[A];
                for (var D = 0; D < e; D++) i[D] = x[D] / f[D] || 0;
                u = !0;
                for (var F = 0; F < e; F++) if (o[F] != i[F]) {
                    u = !1;
                    break
                }
            }
            u = u || --c <= 0
        } while (!u);
        return {it: 1e4 - c, k: e, idxs: s, centroids: i}
    };

    function Zo(t, e) {
        if (t.geometry && t.geometry.type) return t.geometry.type;
        if (t.type) return t.type;
        throw new Error("Invalid GeoJSON object for " + e)
    }

    function Ko(t) {
        for (var e = t, n = []; e.parent;) n.unshift(e), e = e.parent;
        return n
    }

    var Qo = {
        search: function (t, e, n, r) {
            t.cleanDirty();
            var i = (r = r || {}).heuristic || Qo.heuristics.manhattan, o = r.closest || !1, s = new es(function (t) {
                return t.f
            }), a = e;
            for (e.h = i(e, n), s.push(e); 0 < s.size();) {
                var u = s.pop();
                if (u === n) return Ko(u);
                u.closed = !0;
                for (var c = t.neighbors(u), h = 0, l = c.length; h < l; ++h) {
                    var p = c[h];
                    if (!p.closed && !p.isWall()) {
                        var f = u.g + p.getCost(u), g = p.visited;
                        (!g || f < p.g) && (p.visited = !0, p.parent = u, p.h = p.h || i(p, n), p.g = f, p.f = p.g + p.h, t.markDirty(p), o && (p.h < a.h || p.h === a.h && p.g < a.g) && (a = p), g ? s.rescoreElement(p) : s.push(p))
                    }
                }
            }
            return o ? Ko(a) : []
        }, heuristics: {
            manhattan: function (t, e) {
                return Math.abs(e.x - t.x) + Math.abs(e.y - t.y)
            }, diagonal: function (t, e) {
                var n = Math.sqrt(2), r = Math.abs(e.x - t.x), i = Math.abs(e.y - t.y);
                return 1 * (r + i) + (n - 2) * Math.min(r, i)
            }
        }, cleanNode: function (t) {
            t.f = 0, t.g = 0, t.h = 0, t.visited = !1, t.closed = !1, t.parent = null
        }
    };

    function $o(t, e) {
        e = e || {}, this.nodes = [], this.diagonal = !!e.diagonal, this.grid = [];
        for (var n = 0; n < t.length; n++) {
            this.grid[n] = [];
            for (var r = 0, i = t[n]; r < i.length; r++) {
                var o = new ts(n, r, i[r]);
                this.grid[n][r] = o, this.nodes.push(o)
            }
        }
        this.init()
    }

    function ts(t, e, n) {
        this.x = t, this.y = e, this.weight = n
    }

    function es(t) {
        this.content = [], this.scoreFunction = t
    }

    function ns(t, e) {
        for (var n = 0; n < e.features.length; n++) if (re(t, e.features[n])) return !0;
        return !1
    }

    $o.prototype.init = function () {
        this.dirtyNodes = [];
        for (var t = 0; t < this.nodes.length; t++) Qo.cleanNode(this.nodes[t])
    }, $o.prototype.cleanDirty = function () {
        for (var t = 0; t < this.dirtyNodes.length; t++) Qo.cleanNode(this.dirtyNodes[t]);
        this.dirtyNodes = []
    }, $o.prototype.markDirty = function (t) {
        this.dirtyNodes.push(t)
    }, $o.prototype.neighbors = function (t) {
        var e = [], n = t.x, r = t.y, i = this.grid;
        return i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]), i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]), i[n] && i[n][r - 1] && e.push(i[n][r - 1]), i[n] && i[n][r + 1] && e.push(i[n][r + 1]), this.diagonal && (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]), i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]), i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]), i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])), e
    }, $o.prototype.toString = function () {
        for (var t, e, n, r, i = [], o = this.grid, s = 0, a = o.length; s < a; s++) {
            for (t = [], n = 0, r = (e = o[s]).length; n < r; n++) t.push(e[n].weight);
            i.push(t.join(" "))
        }
        return i.join("\n")
    }, ts.prototype.toString = function () {
        return "[" + this.x + " " + this.y + "]"
    }, ts.prototype.getCost = function (t) {
        return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight
    }, ts.prototype.isWall = function () {
        return 0 === this.weight
    }, es.prototype = {
        push: function (t) {
            this.content.push(t), this.sinkDown(this.content.length - 1)
        }, pop: function () {
            var t = this.content[0], e = this.content.pop();
            return 0 < this.content.length && (this.content[0] = e, this.bubbleUp(0)), t
        }, remove: function (t) {
            var e = this.content.indexOf(t), n = this.content.pop();
            e !== this.content.length - 1 && (this.content[e] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e))
        }, size: function () {
            return this.content.length
        }, rescoreElement: function (t) {
            this.sinkDown(this.content.indexOf(t))
        }, sinkDown: function (t) {
            for (var e = this.content[t]; 0 < t;) {
                var n = (t + 1 >> 1) - 1, r = this.content[n];
                if (!(this.scoreFunction(e) < this.scoreFunction(r))) break;
                this.content[n] = e, this.content[t] = r, t = n
            }
        }, bubbleUp: function (t) {
            for (var e = this.content.length, n = this.content[t], r = this.scoreFunction(n); ;) {
                var i, o = t + 1 << 1, s = o - 1, a = null;
                if (s < e) {
                    var u = this.content[s];
                    (i = this.scoreFunction(u)) < r && (a = s)
                }
                if (o < e) {
                    var c = this.content[o];
                    this.scoreFunction(c) < (null === a ? r : i) && (a = o)
                }
                if (null === a) break;
                this.content[t] = this.content[a], this.content[a] = n, t = a
            }
        }
    };
    var rs = function (t) {
        return function () {
            return t
        }
    };

    function is(t) {
        return t[0]
    }

    function os(t) {
        return t[1]
    }

    function ss() {
        this._ = null
    }

    function as(t) {
        t.U = t.C = t.L = t.R = t.P = t.N = null
    }

    function us(t, e) {
        var n = e, r = e.R, i = n.U;
        i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.R = r.L, n.R && (n.R.U = n), r.L = n
    }

    function cs(t, e) {
        var n = e, r = e.L, i = n.U;
        i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.L = r.R, n.L && (n.L.U = n), r.R = n
    }

    function hs(t) {
        for (; t.L;) t = t.L;
        return t
    }

    function ls(t, e, n, r) {
        var i = [null, null], o = Ts.push(i) - 1;
        return i.left = t, i.right = e, n && fs(i, t, e, n), r && fs(i, e, t, r), Os[t.index].halfedges.push(o), Os[e.index].halfedges.push(o), i
    }

    function ps(t, e, n) {
        var r = [e, n];
        return r.left = t, r
    }

    function fs(t, e, n, r) {
        t[0] || t[1] ? t.left === n ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = n)
    }

    function gs(t, e, n, r, i) {
        var o, s = t[0], a = t[1], u = s[0], c = s[1], h = 0, l = 1, p = a[0] - u, f = a[1] - c;
        if (o = e - u, p || !(0 < o)) {
            if (o /= p, p < 0) {
                if (o < h) return;
                o < l && (l = o)
            } else if (0 < p) {
                if (l < o) return;
                h < o && (h = o)
            }
            if (o = r - u, p || !(o < 0)) {
                if (o /= p, p < 0) {
                    if (l < o) return;
                    h < o && (h = o)
                } else if (0 < p) {
                    if (o < h) return;
                    o < l && (l = o)
                }
                if (o = n - c, f || !(0 < o)) {
                    if (o /= f, f < 0) {
                        if (o < h) return;
                        o < l && (l = o)
                    } else if (0 < f) {
                        if (l < o) return;
                        h < o && (h = o)
                    }
                    if (o = i - c, f || !(o < 0)) {
                        if (o /= f, f < 0) {
                            if (l < o) return;
                            h < o && (h = o)
                        } else if (0 < f) {
                            if (o < h) return;
                            o < l && (l = o)
                        }
                        return (0 < h || l < 1) && (0 < h && (t[0] = [u + h * p, c + h * f]), l < 1 && (t[1] = [u + l * p, c + l * f])), !0
                    }
                }
            }
        }
    }

    function ds(t, e, n, r, i) {
        var o = t[1];
        if (o) return !0;
        var s, a, u = t[0], c = t.left, h = t.right, l = c[0], p = c[1], f = h[0], g = h[1], d = (l + f) / 2,
            y = (p + g) / 2;
        if (g === p) {
            if (d < e || r <= d) return;
            if (f < l) {
                if (u) {
                    if (u[1] >= i) return
                } else u = [d, n];
                o = [d, i]
            } else {
                if (u) {
                    if (u[1] < n) return
                } else u = [d, i];
                o = [d, n]
            }
        } else if (a = y - (s = (l - f) / (g - p)) * d, s < -1 || 1 < s) if (f < l) {
            if (u) {
                if (u[1] >= i) return
            } else u = [(n - a) / s, n];
            o = [(i - a) / s, i]
        } else {
            if (u) {
                if (u[1] < n) return
            } else u = [(i - a) / s, i];
            o = [(n - a) / s, n]
        } else if (p < g) {
            if (u) {
                if (u[0] >= r) return
            } else u = [e, s * e + a];
            o = [r, s * r + a]
        } else {
            if (u) {
                if (u[0] < e) return
            } else u = [r, s * r + a];
            o = [e, s * e + a]
        }
        return t[0] = u, t[1] = o, !0
    }

    function ys(t, e) {
        return e[+(e.left !== t.site)]
    }

    ss.prototype = {
        constructor: ss, insert: function (t, e) {
            var n, r, i;
            if (t) {
                if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) {
                    for (t = t.R; t.L;) t = t.L;
                    t.L = e
                } else t.R = e;
                n = t
            } else n = this._ ? (t = hs(this._), e.P = null, (e.N = t).P = t.L = e, t) : (e.P = e.N = null, this._ = e, null);
            for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C;) n === (r = n.U).L ? (i = r.R) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.R && (us(this, n), n = (t = n).U), n.C = !1, r.C = !0, cs(this, r)) : (i = r.L) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.L && (cs(this, n), n = (t = n).U), n.C = !1, r.C = !0, us(this, r)), n = t.U;
            this._.C = !1
        }, remove: function (t) {
            t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null;
            var e, n, r, i = t.U, o = t.L, s = t.R;
            if (n = o ? s ? hs(s) : o : s, i ? i.L === t ? i.L = n : i.R = n : this._ = n, o && s ? (r = n.C, n.C = t.C, ((n.L = o).U = n) !== s ? (i = n.U, n.U = t.U, t = n.R, i.L = t, (n.R = s).U = n) : (n.U = i, t = (i = n).R)) : (r = t.C, t = n), t && (t.U = i), !r) if (t && t.C) t.C = !1; else {
                do {
                    if (t === this._) break;
                    if (t === i.L) {
                        if ((e = i.R).C && (e.C = !1, i.C = !0, us(this, i), e = i.R), e.L && e.L.C || e.R && e.R.C) {
                            e.R && e.R.C || (e.L.C = !1, e.C = !0, cs(this, e), e = i.R), e.C = i.C, i.C = e.R.C = !1, us(this, i), t = this._;
                            break
                        }
                    } else if ((e = i.L).C && (e.C = !1, i.C = !0, cs(this, i), e = i.L), e.L && e.L.C || e.R && e.R.C) {
                        e.L && e.L.C || (e.R.C = !1, e.C = !0, us(this, e), e = i.L), e.C = i.C, i.C = e.L.C = !1, cs(this, i), t = this._;
                        break
                    }
                    e.C = !0, i = (t = i).U
                } while (!t.C);
                t && (t.C = !1)
            }
        }
    };
    var _s, ms = [];

    function vs() {
        as(this), this.x = this.y = this.arc = this.site = this.cy = null
    }

    function xs(t) {
        var e = t.P, n = t.N;
        if (e && n) {
            var r = e.site, i = t.site, o = n.site;
            if (r !== o) {
                var s = i[0], a = i[1], u = r[0] - s, c = r[1] - a, h = o[0] - s, l = o[1] - a, p = 2 * (u * l - c * h);
                if (!(-Ds <= p)) {
                    var f = u * u + c * c, g = h * h + l * l, d = (l * f - c * g) / p, y = (u * g - h * f) / p,
                        _ = ms.pop() || new vs;
                    _.arc = t, _.site = i, _.x = d + s, _.y = (_.cy = y + a) + Math.sqrt(d * d + y * y), t.circle = _;
                    for (var m = null, v = Rs._; v;) if (_.y < v.y || _.y === v.y && _.x <= v.x) {
                        if (!v.L) {
                            m = v.P;
                            break
                        }
                        v = v.L
                    } else {
                        if (!v.R) {
                            m = v;
                            break
                        }
                        v = v.R
                    }
                    Rs.insert(m, _), m || (_s = _)
                }
            }
        }
    }

    function Es(t) {
        var e = t.circle;
        e && (e.P || (_s = e.N), Rs.remove(e), ms.push(e), as(e), t.circle = null)
    }

    var ws = [];

    function bs() {
        as(this), this.edge = this.site = this.circle = null
    }

    function Is(t) {
        var e = ws.pop() || new bs;
        return e.site = t, e
    }

    function Ns(t) {
        Es(t), Ps.remove(t), ws.push(t), as(t)
    }

    function Cs(t) {
        var e = t.circle, n = e.x, r = e.cy, i = [n, r], o = t.P, s = t.N, a = [t];
        Ns(t);
        for (var u = o; u.circle && Math.abs(n - u.circle.x) < As && Math.abs(r - u.circle.cy) < As;) o = u.P, a.unshift(u), Ns(u), u = o;
        a.unshift(u), Es(u);
        for (var c = s; c.circle && Math.abs(n - c.circle.x) < As && Math.abs(r - c.circle.cy) < As;) s = c.N, a.push(c), Ns(c), c = s;
        a.push(c), Es(c);
        var h, l = a.length;
        for (h = 1; h < l; ++h) c = a[h], u = a[h - 1], fs(c.edge, u.site, c.site, i);
        u = a[0], (c = a[l - 1]).edge = ls(u.site, c.site, null, i), xs(u), xs(c)
    }

    function Ss(t) {
        for (var e, n, r, i, o, s = t[0], a = t[1], u = Ps._; u;) if (r = Ms(u, a) - s, As < r) u = u.L; else {
            if (i = s - Ls(u, a), !(As < i)) {
                -As < r ? (e = u.P, n = u) : -As < i ? n = (e = u).N : e = n = u;
                break
            }
            if (!u.R) {
                e = u;
                break
            }
            u = u.R
        }
        Os[(o = t).index] = {site: o, halfedges: []};
        var c = Is(t);
        if (Ps.insert(e, c), e || n) {
            if (e === n) return Es(e), n = Is(e.site), Ps.insert(c, n), c.edge = n.edge = ls(e.site, c.site), xs(e), void xs(n);
            if (n) {
                Es(e), Es(n);
                var h = e.site, l = h[0], p = h[1], f = t[0] - l, g = t[1] - p, d = n.site, y = d[0] - l, _ = d[1] - p,
                    m = 2 * (f * _ - g * y), v = f * f + g * g, x = y * y + _ * _,
                    E = [(_ * v - g * x) / m + l, (f * x - y * v) / m + p];
                fs(n.edge, h, d, E), c.edge = ls(h, t, null, E), n.edge = ls(t, d, null, E), xs(e), xs(n)
            } else c.edge = ls(e.site, c.site)
        }
    }

    function Ms(t, e) {
        var n = t.site, r = n[0], i = n[1], o = i - e;
        if (!o) return r;
        var s = t.P;
        if (!s) return -1 / 0;
        var a = (n = s.site)[0], u = n[1], c = u - e;
        if (!c) return a;
        var h = a - r, l = 1 / o - 1 / c, p = h / c;
        return l ? (-p + Math.sqrt(p * p - 2 * l * (h * h / (-2 * c) - u + c / 2 + i - o / 2))) / l + r : (r + a) / 2
    }

    function Ls(t, e) {
        var n = t.N;
        if (n) return Ms(n, e);
        var r = t.site;
        return r[1] === e ? r[0] : 1 / 0
    }

    var Ps, Os, Rs, Ts, As = 1e-6, Ds = 1e-12;

    function Fs(t, e) {
        return e[1] - t[1] || e[0] - t[0]
    }

    function qs(t, e) {
        var n, r, i, o = t.sort(Fs).pop();
        for (Ts = [], Os = new Array(t.length), Ps = new ss, Rs = new ss; ;) if (i = _s, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x)) o[0] === n && o[1] === r || (Ss(o), n = o[0], r = o[1]), o = t.pop(); else {
            if (!i) break;
            Cs(i.arc)
        }
        if (function () {
            for (var t, e, n, r, i = 0, o = Os.length; i < o; ++i) if ((t = Os[i]) && (r = (e = t.halfedges).length)) {
                var s = new Array(r), a = new Array(r);
                for (n = 0; n < r; ++n) s[n] = n, a[n] = (u = t, c = Ts[e[n]], p = l = void 0, h = u.site, l = c.left, h === (p = c.right) && (p = l, l = h), p ? Math.atan2(p[1] - l[1], p[0] - l[0]) : (p = h === l ? (l = c[1], c[0]) : (l = c[0], c[1]), Math.atan2(l[0] - p[0], p[1] - l[1])));
                for (s.sort(function (t, e) {
                    return a[e] - a[t]
                }), n = 0; n < r; ++n) a[n] = e[s[n]];
                for (n = 0; n < r; ++n) e[n] = a[n]
            }
            var u, c, h, l, p
        }(), e) {
            var s = +e[0][0], a = +e[0][1], u = +e[1][0], c = +e[1][1];
            !function (t, e, n, r) {
                for (var i, o = Ts.length; o--;) ds(i = Ts[o], t, e, n, r) && gs(i, t, e, n, r) && (Math.abs(i[0][0] - i[1][0]) > As || Math.abs(i[0][1] - i[1][1]) > As) || delete Ts[o]
            }(s, a, u, c), function (t, e, n, r) {
                var i, o, s, a, u, c, h, l, p, f, g, d, y, _, m = Os.length, v = !0;
                for (i = 0; i < m; ++i) if (o = Os[i]) {
                    for (s = o.site, a = (u = o.halfedges).length; a--;) Ts[u[a]] || u.splice(a, 1);
                    for (a = 0, c = u.length; a < c;) y = o, g = (f = (_ = Ts[u[a]])[+(_.left === y.site)])[0], d = f[1], l = (h = ys(o, Ts[u[++a % c]]))[0], p = h[1], (Math.abs(g - l) > As || Math.abs(d - p) > As) && (u.splice(a, 0, Ts.push(ps(s, f, Math.abs(g - t) < As && As < r - d ? [t, Math.abs(l - t) < As ? p : r] : Math.abs(d - r) < As && As < n - g ? [Math.abs(p - r) < As ? l : n, r] : Math.abs(g - n) < As && As < d - e ? [n, Math.abs(l - n) < As ? p : e] : Math.abs(d - e) < As && As < g - t ? [Math.abs(p - e) < As ? l : t, e] : null)) - 1), ++c);
                    c && (v = !1)
                }
                if (v) {
                    var x, E, w, b = 1 / 0;
                    for (i = 0, v = null; i < m; ++i) (o = Os[i]) && (w = (x = (s = o.site)[0] - t) * x + (E = s[1] - e) * E) < b && (b = w, v = o);
                    if (v) {
                        var I = [t, e], N = [t, r], C = [n, r], S = [n, e];
                        v.halfedges.push(Ts.push(ps(s = v.site, I, N)) - 1, Ts.push(ps(s, N, C)) - 1, Ts.push(ps(s, C, S)) - 1, Ts.push(ps(s, S, I)) - 1)
                    }
                }
                for (i = 0; i < m; ++i) (o = Os[i]) && (o.halfedges.length || delete Os[i])
            }(s, a, u, c)
        }
        this.edges = Ts, this.cells = Os, Ps = Rs = Ts = Os = null
    }

    function Gs(t) {
        return (t = t.slice()).push(t[0]), B([t])
    }

    function Bs(t, e, n, r) {
        var i = (r = r || {}).steps || 64, o = r.units || "kilometers", s = r.angle || 0, a = r.pivot || t,
            u = r.properties || t.properties || {};
        if (!t) throw new Error("center is required");
        if (!e) throw new Error("xSemiAxis is required");
        if (!n) throw new Error("ySemiAxis is required");
        if (!H(r)) throw new Error("options must be an object");
        if (!V(i)) throw new Error("steps must be a number");
        if (!V(s)) throw new Error("angle must be a number");
        var c = J(t);
        if ("degrees" === o) var h = m(s); else e = Qr(t, e, 90, {units: o}), n = Qr(t, n, 0, {units: o}), e = J(e)[0] - c[0], n = J(n)[1] - c[1];
        for (var l = [], p = 0; p < i; p += 1) {
            var f = -360 * p / i, g = e * n / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(ks(f), 2)),
                d = e * n / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(ks(f), 2));
            if (f < -90 && -270 <= f && (g = -g), f < -180 && -360 <= f && (d = -d), "degrees" === o) {
                var y = g * Math.cos(h) + d * Math.sin(h), _ = d * Math.cos(h) - g * Math.sin(h);
                g = y, d = _
            }
            l.push([g + c[0], d + c[1]])
        }
        return l.push(l[0]), "degrees" === o ? B([l], u) : uo(B([l], u), s, {pivot: a})
    }

    function ks(t) {
        var e = t * Math.PI / 180;
        return Math.tan(e)
    }

    function zs(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.properties, i = e.weight;
        if (!t) throw new Error("geojson is required");
        var o = 0, s = 0, a = 0;
        return R(t, function (t, e, n) {
            var r = n[i];
            if (!V(r = null == r ? 1 : r)) throw new Error("weight value must be a number for feature index " + e);
            0 < (r = Number(r)) && N(t, function (t) {
                o += t[0] * r, s += t[1] * r, a += r
            })
        }), X([o / a, s / a], n)
    }

    function js(t, e) {
        return {x: t[0] - e[0], y: t[1] - e[1]}
    }

    function Xs(t) {
        if (H(t) && (t = t.bbox), t && !Array.isArray(t)) throw new Error("bbox is invalid");
        return t ? (e = t, [Math.random() * (e[2] - e[0]) + e[0], Math.random() * (e[3] - e[1]) + e[1]]) : [360 * Ws(), 180 * Ws()];
        var e
    }

    function Us(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.bbox;
        null == t && (t = 1);
        for (var r = [], i = 0; i < t; i++) r.push(X(Xs(n)));
        return Y(r)
    }

    function Ys(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.bbox, r = e.num_vertices, i = e.max_radial_length;
        null == t && (t = 1), V(r) || (r = 10), V(i) || (i = 10);
        for (var o = [], s = 0; s < t; s++) {
            var a = [], u = Array.apply(null, new Array(r + 1)).map(Math.random);
            u.forEach(c), u.forEach(h), a[a.length - 1] = a[0], a = a.map(Hs(Xs(n))), o.push(B([a]))
        }

        function c(t, e, n) {
            n[e] = 0 < e ? t + n[e - 1] : t
        }

        function h(t) {
            t = 2 * t * Math.PI / u[u.length - 1];
            var e = Math.random();
            a.push([e * i * Math.sin(t), e * i * Math.cos(t)])
        }

        return Y(o)
    }

    function Vs(t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.bbox, r = e.num_vertices, i = e.max_length, o = e.max_rotation;
        null == t && (t = 1), (!V(r) || r < 2) && (r = 10), V(i) || (i = 1e-4), V(o) || (o = Math.PI / 8);
        for (var s = [], a = 0; a < t; a++) {
            for (var u = [Xs(n)], c = 0; c < r - 1; c++) {
                var h = (0 === c ? 2 * Math.random() * Math.PI : Math.tan((u[c][1] - u[c - 1][1]) / (u[c][0] - u[c - 1][0]))) + (Math.random() - .5) * o * 2,
                    l = Math.random() * i;
                u.push([u[c][0] + l * Math.cos(h), u[c][1] + l * Math.sin(h)])
            }
            s.push(U(u))
        }
        return Y(s)
    }

    function Hs(e) {
        return function (t) {
            return [t[0] + e[0], t[1] + e[1]]
        }
    }

    function Ws() {
        return Math.random() - .5
    }

    qs.prototype = {
        constructor: qs, polygons: function () {
            var n = this.edges;
            return this.cells.map(function (e) {
                var t = e.halfedges.map(function (t) {
                    return ys(e, n[t])
                });
                return t.data = e.site.data, t
            })
        }, triangles: function () {
            var p = [], f = this.edges;
            return this.cells.forEach(function (t, e) {
                if (r = (n = t.halfedges).length) for (var n, r, i, o, s, a, u = t.site, c = -1, h = f[n[r - 1]], l = h.left === u ? h.right : h.left; ++c < r;) i = l, l = (h = f[n[c]]).left === u ? h.right : h.left, i && l && e < i.index && e < l.index && (s = i, a = l, ((o = u)[0] - a[0]) * (s[1] - o[1]) - (o[0] - s[0]) * (a[1] - o[1]) < 0) && p.push([u.data, i.data, l.data])
            }), p
        }, links: function () {
            return this.edges.filter(function (t) {
                return t.right
            }).map(function (t) {
                return {source: t.left.data, target: t.right.data}
            })
        }, find: function (s, a, t) {
            for (var e, u, c = this, h = c._found || 0, n = c.cells.length; !(u = c.cells[h]);) if (++h >= n) return null;
            for (var r = s - u.site[0], i = a - u.site[1], l = r * r + i * i; u = c.cells[e = h], h = null, u.halfedges.forEach(function (t) {
                var e = c.edges[t], n = e.left;
                if (n !== u.site && n || (n = e.right)) {
                    var r = s - n[0], i = a - n[1], o = r * r + i * i;
                    o < l && (l = o, h = n.index)
                }
            }), null !== h;) ;
            return c._found = e, null == t || l <= t * t ? u.site : null
        }
    };
    var Js = Object.freeze({randomPosition: Xs, randomPoint: Us, randomPolygon: Ys, randomLineString: Vs});

    function Zs(t, e) {
        if (!t) throw new Error("geojson is required");
        if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection");
        if (null == e) throw new Error("filter is required");
        var n = [];
        return L(t, function (t) {
            ta(t.properties, e) && n.push(t)
        }), Y(n)
    }

    function Ks(t, e, n) {
        if (!t) throw new Error("geojson is required");
        if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection");
        if (null == e) throw new Error("property is required");
        for (var r = $s(t, e), i = Object.keys(r), o = 0; o < i.length; o++) {
            for (var s = i[o], a = r[s], u = [], c = 0; c < a.length; c++) u.push(t.features[a[c]]);
            n(Y(u), s, o)
        }
    }

    function Qs(t, e, r, i) {
        var o = i;
        return Ks(t, e, function (t, e, n) {
            o = 0 === n && void 0 === i ? t : r(o, t, e, n)
        }), o
    }

    function $s(t, i) {
        var o = {};
        return L(t, function (t, e) {
            var n = t.properties || {};
            if (n.hasOwnProperty(i)) {
                var r = n[i];
                o.hasOwnProperty(r) ? o[r].push(e) : o[r] = [e]
            }
        }), o
    }

    function ta(t, e) {
        if (void 0 === t) return !1;
        var n = typeof e;
        if ("number" === n || "string" === n) return t.hasOwnProperty(e);
        if (Array.isArray(e)) {
            for (var r = 0; r < e.length; r++) if (!ta(t, e[r])) return !1;
            return !0
        }
        return ea(t, e)
    }

    function ea(t, e) {
        for (var n = Object.keys(e), r = 0; r < n.length; r++) {
            var i = n[r];
            if (t[i] !== e[i]) return !1
        }
        return !0
    }

    function na(t, e) {
        if (!e) return {};
        if (!e.length) return {};
        for (var n = {}, r = 0; r < e.length; r++) {
            var i = e[r];
            t.hasOwnProperty(i) && (n[i] = t[i])
        }
        return n
    }

    var ra = Object.freeze({
        getCluster: Zs,
        clusterEach: Ks,
        clusterReduce: Qs,
        createBins: $s,
        applyFilter: ta,
        propertiesContainsFilter: ea,
        filterProperties: na
    });
    "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
        configurable: !0, value: function (t) {
            if (null == this) throw new TypeError(this + " is not an object");
            var e = Object(this), n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,
                r = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0;
            r = r < 0 ? Math.max(n + r, 0) : Math.min(r, n);
            var i = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;
            for (i = i < 0 ? Math.max(n + arguments[2], 0) : Math.min(i, n); r < i;) e[r] = t, ++r;
            return e
        }, writable: !0
    }), Number.isFinite = Number.isFinite || function (t) {
        return "number" == typeof t && isFinite(t)
    }, Number.isInteger = Number.isInteger || function (t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) {
        return t != t
    }, Math.trunc = Math.trunc || function (t) {
        return t < 0 ? Math.ceil(t) : Math.floor(t)
    };
    var ia = function () {
    };
    ia.prototype.interfaces_ = function () {
        return []
    }, ia.prototype.getClass = function () {
        return ia
    }, ia.prototype.equalsWithTolerance = function (t, e, n) {
        return Math.abs(t - e) <= n
    };
    var oa = function () {
    }, sa = function () {
    }, aa = {MAX_VALUE: {configurable: !0}};
    sa.isNaN = function (t) {
        return Number.isNaN(t)
    }, sa.doubleToLongBits = function (t) {
        return t
    }, sa.longBitsToDouble = function (t) {
        return t
    }, sa.isInfinite = function (t) {
        return !Number.isFinite(t)
    }, aa.MAX_VALUE.get = function () {
        return Number.MAX_VALUE
    }, Object.defineProperties(sa, aa);
    var ua = function () {
    }, ca = function () {
    }, ha = function () {
    };

    function la() {
    }

    var pa = function t() {
        if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) this.x = 0, this.y = 0, this.z = t.NULL_ORDINATE; else if (1 === arguments.length) {
            var e = arguments[0];
            this.x = e.x, this.y = e.y, this.z = e.z
        } else 2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2])
    }, fa = {
        DimensionalComparator: {configurable: !0},
        serialVersionUID: {configurable: !0},
        NULL_ORDINATE: {configurable: !0},
        X: {configurable: !0},
        Y: {configurable: !0},
        Z: {configurable: !0}
    };
    pa.prototype.setOrdinate = function (t, e) {
        switch (t) {
            case pa.X:
                this.x = e;
                break;
            case pa.Y:
                this.y = e;
                break;
            case pa.Z:
                this.z = e;
                break;
            default:
                throw new oa("Invalid ordinate index: " + t)
        }
    }, pa.prototype.equals2D = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return this.x === t.x && this.y === t.y
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return !!ia.equalsWithTolerance(this.x, e.x, n) && !!ia.equalsWithTolerance(this.y, e.y, n)
        }
    }, pa.prototype.getOrdinate = function (t) {
        switch (t) {
            case pa.X:
                return this.x;
            case pa.Y:
                return this.y;
            case pa.Z:
                return this.z
        }
        throw new oa("Invalid ordinate index: " + t)
    }, pa.prototype.equals3D = function (t) {
        return this.x === t.x && this.y === t.y && (this.z === t.z || sa.isNaN(this.z)) && sa.isNaN(t.z)
    }, pa.prototype.equals = function (t) {
        return t instanceof pa && this.equals2D(t)
    }, pa.prototype.equalInZ = function (t, e) {
        return ia.equalsWithTolerance(this.z, t.z, e)
    }, pa.prototype.compareTo = function (t) {
        var e = t;
        return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
    }, pa.prototype.clone = function () {
    }, pa.prototype.copy = function () {
        return new pa(this)
    }, pa.prototype.toString = function () {
        return "(" + this.x + ", " + this.y + ", " + this.z + ")"
    }, pa.prototype.distance3D = function (t) {
        var e = this.x - t.x, n = this.y - t.y, r = this.z - t.z;
        return Math.sqrt(e * e + n * n + r * r)
    }, pa.prototype.distance = function (t) {
        var e = this.x - t.x, n = this.y - t.y;
        return Math.sqrt(e * e + n * n)
    }, pa.prototype.hashCode = function () {
        var t = 17;
        return 37 * (t = 37 * t + pa.hashCode(this.x)) + pa.hashCode(this.y)
    }, pa.prototype.setCoordinate = function (t) {
        this.x = t.x, this.y = t.y, this.z = t.z
    }, pa.prototype.interfaces_ = function () {
        return [ua, ca, la]
    }, pa.prototype.getClass = function () {
        return pa
    }, pa.hashCode = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = sa.doubleToLongBits(t);
            return Math.trunc((e ^ e) >>> 32)
        }
    }, fa.DimensionalComparator.get = function () {
        return ga
    }, fa.serialVersionUID.get = function () {
        return 0x5cbf2c235c7e5800
    }, fa.NULL_ORDINATE.get = function () {
        return sa.NaN
    }, fa.X.get = function () {
        return 0
    }, fa.Y.get = function () {
        return 1
    }, fa.Z.get = function () {
        return 2
    }, Object.defineProperties(pa, fa);
    var ga = function (t) {
        if (this._dimensionsToTest = 2, 0 === arguments.length) ; else if (1 === arguments.length) {
            var e = t;
            if (2 !== e && 3 !== e) throw new oa("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = e
        }
    };
    ga.prototype.compare = function (t, e) {
        var n = t, r = e, i = ga.compare(n.x, r.x);
        if (0 !== i) return i;
        var o = ga.compare(n.y, r.y);
        return 0 !== o ? o : this._dimensionsToTest <= 2 ? 0 : ga.compare(n.z, r.z)
    }, ga.prototype.interfaces_ = function () {
        return [ha]
    }, ga.prototype.getClass = function () {
        return ga
    }, ga.compare = function (t, e) {
        return t < e ? -1 : e < t ? 1 : sa.isNaN(t) ? sa.isNaN(e) ? 0 : -1 : sa.isNaN(e) ? 1 : 0
    };
    var da = function () {
    };
    da.prototype.create = function () {
    }, da.prototype.interfaces_ = function () {
        return []
    }, da.prototype.getClass = function () {
        return da
    };
    var ya = function () {
    }, _a = {
        INTERIOR: {configurable: !0},
        BOUNDARY: {configurable: !0},
        EXTERIOR: {configurable: !0},
        NONE: {configurable: !0}
    };
    ya.prototype.interfaces_ = function () {
        return []
    }, ya.prototype.getClass = function () {
        return ya
    }, ya.toLocationSymbol = function (t) {
        switch (t) {
            case ya.EXTERIOR:
                return "e";
            case ya.BOUNDARY:
                return "b";
            case ya.INTERIOR:
                return "i";
            case ya.NONE:
                return "-"
        }
        throw new oa("Unknown location value: " + t)
    }, _a.INTERIOR.get = function () {
        return 0
    }, _a.BOUNDARY.get = function () {
        return 1
    }, _a.EXTERIOR.get = function () {
        return 2
    }, _a.NONE.get = function () {
        return -1
    }, Object.defineProperties(ya, _a);
    var ma = function (t, e) {
        return t.interfaces_ && -1 < t.interfaces_().indexOf(e)
    }, va = function () {
    }, xa = {LOG_10: {configurable: !0}};
    va.prototype.interfaces_ = function () {
        return []
    }, va.prototype.getClass = function () {
        return va
    }, va.log10 = function (t) {
        var e = Math.log(t);
        return sa.isInfinite(e) ? e : sa.isNaN(e) ? e : e / va.LOG_10
    }, va.min = function (t, e, n, r) {
        var i = t;
        return e < i && (i = e), n < i && (i = n), r < i && (i = r), i
    }, va.clamp = function () {
        if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t = arguments[0], e = arguments[1], n = arguments[2];
            return t < e ? e : n < t ? n : t
        }
        if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var r = arguments[0], i = arguments[1], o = arguments[2];
            return r < i ? i : o < r ? o : r
        }
    }, va.wrap = function (t, e) {
        return t < 0 ? e - -t % e : t % e
    }, va.max = function () {
        if (3 === arguments.length) {
            var t = arguments[0], e = arguments[1], n = arguments[2], r = t;
            return r < e && (r = e), r < n && (r = n), r
        }
        if (4 === arguments.length) {
            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3], u = i;
            return u < o && (u = o), u < s && (u = s), u < a && (u = a), u
        }
    }, va.average = function (t, e) {
        return (t + e) / 2
    }, xa.LOG_10.get = function () {
        return Math.log(10)
    }, Object.defineProperties(va, xa);
    var Ea = function (t) {
        this.str = t
    };
    Ea.prototype.append = function (t) {
        this.str += t
    }, Ea.prototype.setCharAt = function (t, e) {
        this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
    }, Ea.prototype.toString = function (t) {
        return this.str
    };
    var wa = function (t) {
        this.value = t
    };
    wa.prototype.intValue = function () {
        return this.value
    }, wa.prototype.compareTo = function (t) {
        return this.value < t ? -1 : this.value > t ? 1 : 0
    }, wa.isNaN = function (t) {
        return Number.isNaN(t)
    };
    var ba = function () {
    };
    ba.isWhitespace = function (t) {
        return t <= 32 && 0 <= t || 127 === t
    }, ba.toUpperCase = function (t) {
        return t.toUpperCase()
    };
    var Ia = function t() {
        if (this._hi = 0, (this._lo = 0) === arguments.length) this.init(0); else if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                this.init(e)
            } else if (arguments[0] instanceof t) {
                var n = arguments[0];
                this.init(n)
            } else if ("string" == typeof arguments[0]) {
                var r = arguments[0];
                t.call(this, t.parse(r))
            }
        } else if (2 === arguments.length) {
            var i = arguments[0], o = arguments[1];
            this.init(i, o)
        }
    }, Na = {
        PI: {configurable: !0},
        TWO_PI: {configurable: !0},
        PI_2: {configurable: !0},
        E: {configurable: !0},
        NaN: {configurable: !0},
        EPS: {configurable: !0},
        SPLIT: {configurable: !0},
        MAX_PRINT_DIGITS: {configurable: !0},
        TEN: {configurable: !0},
        ONE: {configurable: !0},
        SCI_NOT_EXPONENT_CHAR: {configurable: !0},
        SCI_NOT_ZERO: {configurable: !0}
    };
    Ia.prototype.le = function (t) {
        return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo
    }, Ia.prototype.extractSignificantDigits = function (t, e) {
        var n = this.abs(), r = Ia.magnitude(n._hi), i = Ia.TEN.pow(r);
        (n = n.divide(i)).gt(Ia.TEN) ? (n = n.divide(Ia.TEN), r += 1) : n.lt(Ia.ONE) && (n = n.multiply(Ia.TEN), r -= 1);
        for (var o = r + 1, s = new Ea, a = Ia.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {
            t && u === o && s.append(".");
            var c = Math.trunc(n._hi);
            if (c < 0) break;
            var h, l = !1;
            h = 9 < c ? (l = !0, "9") : "0" + c, s.append(h), n = n.subtract(Ia.valueOf(c)).multiply(Ia.TEN), l && n.selfAdd(Ia.TEN);
            var p = !0, f = Ia.magnitude(n._hi);
            if (f < 0 && Math.abs(f) >= a - u && (p = !1), !p) break
        }
        return e[0] = r, s.toString()
    }, Ia.prototype.sqr = function () {
        return this.multiply(this)
    }, Ia.prototype.doubleValue = function () {
        return this._hi + this._lo
    }, Ia.prototype.subtract = function () {
        if (arguments[0] instanceof Ia) {
            var t = arguments[0];
            return this.add(t.negate())
        }
        if ("number" == typeof arguments[0]) {
            var e = arguments[0];
            return this.add(-e)
        }
    }, Ia.prototype.equals = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return this._hi === t._hi && this._lo === t._lo
        }
    }, Ia.prototype.isZero = function () {
        return 0 === this._hi && 0 === this._lo
    }, Ia.prototype.selfSubtract = function () {
        if (arguments[0] instanceof Ia) {
            var t = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo)
        }
        if ("number" == typeof arguments[0]) {
            var e = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-e, 0)
        }
    }, Ia.prototype.getSpecialNumberString = function () {
        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
    }, Ia.prototype.min = function (t) {
        return this.le(t) ? this : t
    }, Ia.prototype.selfDivide = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof Ia) {
                var t = arguments[0];
                return this.selfDivide(t._hi, t._lo)
            }
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                return this.selfDivide(e, 0)
            }
        } else if (2 === arguments.length) {
            var n, r, i, o, s = arguments[0], a = arguments[1], u = null, c = null, h = null, l = null;
            return i = this._hi / s, l = (u = (h = Ia.SPLIT * i) - (u = h - i)) * (c = (l = Ia.SPLIT * s) - (c = l - s)) - (o = i * s) + u * (r = s - c) + (n = i - u) * c + n * r, l = i + (h = (this._hi - o - l + this._lo - i * a) / s), this._hi = l, this._lo = i - l + h, this
        }
    }, Ia.prototype.dump = function () {
        return "DD<" + this._hi + ", " + this._lo + ">"
    }, Ia.prototype.divide = function () {
        if (arguments[0] instanceof Ia) {
            var t, e, n, r, i = arguments[0], o = null, s = null, a = null, u = null;
            return t = (n = this._hi / i._hi) - (o = (a = Ia.SPLIT * n) - (o = a - n)), u = o * (s = (u = Ia.SPLIT * i._hi) - (s = u - i._hi)) - (r = n * i._hi) + o * (e = i._hi - s) + t * s + t * e, a = (this._hi - r - u + this._lo - n * i._lo) / i._hi, new Ia(u = n + a, n - u + a)
        }
        if ("number" == typeof arguments[0]) {
            var c = arguments[0];
            return sa.isNaN(c) ? Ia.createNaN() : Ia.copy(this).selfDivide(c, 0)
        }
    }, Ia.prototype.ge = function (t) {
        return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo
    }, Ia.prototype.pow = function (t) {
        if (0 === t) return Ia.valueOf(1);
        var e = new Ia(this), n = Ia.valueOf(1), r = Math.abs(t);
        if (1 < r) for (; 0 < r;) r % 2 == 1 && n.selfMultiply(e), 0 < (r /= 2) && (e = e.sqr()); else n = e;
        return t < 0 ? n.reciprocal() : n
    }, Ia.prototype.ceil = function () {
        if (this.isNaN()) return Ia.NaN;
        var t = Math.ceil(this._hi), e = 0;
        return t === this._hi && (e = Math.ceil(this._lo)), new Ia(t, e)
    }, Ia.prototype.compareTo = function (t) {
        var e = t;
        return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0
    }, Ia.prototype.rint = function () {
        return this.isNaN() ? this : this.add(.5).floor()
    }, Ia.prototype.setValue = function () {
        if (arguments[0] instanceof Ia) {
            var t = arguments[0];
            return this.init(t), this
        }
        if ("number" == typeof arguments[0]) {
            var e = arguments[0];
            return this.init(e), this
        }
    }, Ia.prototype.max = function (t) {
        return this.ge(t) ? this : t
    }, Ia.prototype.sqrt = function () {
        if (this.isZero()) return Ia.valueOf(0);
        if (this.isNegative()) return Ia.NaN;
        var t = 1 / Math.sqrt(this._hi), e = this._hi * t, n = Ia.valueOf(e), r = this.subtract(n.sqr())._hi * (.5 * t);
        return n.add(r)
    }, Ia.prototype.selfAdd = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof Ia) {
                var t = arguments[0];
                return this.selfAdd(t._hi, t._lo)
            }
            if ("number" == typeof arguments[0]) {
                var e, n, r, i, o, s = arguments[0], a = null;
                return a = (r = this._hi + s) - (i = r - this._hi), n = (o = (a = s - i + (this._hi - a)) + this._lo) + (r - (e = r + o)), this._hi = e + n, this._lo = n + (e - this._hi), this
            }
        } else if (2 === arguments.length) {
            var u, c, h, l, p = arguments[0], f = arguments[1], g = null, d = null, y = null;
            h = this._hi + p, c = this._lo + f, d = h - (y = h - this._hi), g = c - (l = c - this._lo);
            var _ = (u = h + (y = (d = p - y + (this._hi - d)) + c)) + (y = (g = f - l + (this._lo - g)) + (y + (h - u))),
                m = y + (u - _);
            return this._hi = _, this._lo = m, this
        }
    }, Ia.prototype.selfMultiply = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof Ia) {
                var t = arguments[0];
                return this.selfMultiply(t._hi, t._lo)
            }
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                return this.selfMultiply(e, 0)
            }
        } else if (2 === arguments.length) {
            var n, r, i = arguments[0], o = arguments[1], s = null, a = null, u = null, c = null;
            s = (u = Ia.SPLIT * this._hi) - this._hi, c = Ia.SPLIT * i, s = u - s, n = this._hi - s, a = c - i;
            var h = (u = this._hi * i) + (c = s * (a = c - a) - u + s * (r = i - a) + n * a + n * r + (this._hi * o + this._lo * i)),
                l = c + (s = u - h);
            return this._hi = h, this._lo = l, this
        }
    }, Ia.prototype.selfSqr = function () {
        return this.selfMultiply(this)
    }, Ia.prototype.floor = function () {
        if (this.isNaN()) return Ia.NaN;
        var t = Math.floor(this._hi), e = 0;
        return t === this._hi && (e = Math.floor(this._lo)), new Ia(t, e)
    }, Ia.prototype.negate = function () {
        return this.isNaN() ? this : new Ia(-this._hi, -this._lo)
    }, Ia.prototype.clone = function () {
    }, Ia.prototype.multiply = function () {
        if (arguments[0] instanceof Ia) {
            var t = arguments[0];
            return t.isNaN() ? Ia.createNaN() : Ia.copy(this).selfMultiply(t)
        }
        if ("number" == typeof arguments[0]) {
            var e = arguments[0];
            return sa.isNaN(e) ? Ia.createNaN() : Ia.copy(this).selfMultiply(e, 0)
        }
    }, Ia.prototype.isNaN = function () {
        return sa.isNaN(this._hi)
    }, Ia.prototype.intValue = function () {
        return Math.trunc(this._hi)
    }, Ia.prototype.toString = function () {
        var t = Ia.magnitude(this._hi);
        return -3 <= t && t <= 20 ? this.toStandardNotation() : this.toSciNotation()
    }, Ia.prototype.toStandardNotation = function () {
        var t = this.getSpecialNumberString();
        if (null !== t) return t;
        var e = new Array(1).fill(null), n = this.extractSignificantDigits(!0, e), r = e[0] + 1, i = n;
        if ("." === n.charAt(0)) i = "0" + n; else if (r < 0) i = "0." + Ia.stringOfChar("0", -r) + n; else if (-1 === n.indexOf(".")) {
            var o = r - n.length;
            i = n + Ia.stringOfChar("0", o) + ".0"
        }
        return this.isNegative() ? "-" + i : i
    }, Ia.prototype.reciprocal = function () {
        var t, e, n, r, i = null, o = null, s = null, a = null;
        t = (n = 1 / this._hi) - (i = (s = Ia.SPLIT * n) - (i = s - n)), o = (a = Ia.SPLIT * this._hi) - this._hi;
        var u = n + (s = (1 - (r = n * this._hi) - (a = i * (o = a - o) - r + i * (e = this._hi - o) + t * o + t * e) - n * this._lo) / this._hi);
        return new Ia(u, n - u + s)
    }, Ia.prototype.toSciNotation = function () {
        if (this.isZero()) return Ia.SCI_NOT_ZERO;
        var t = this.getSpecialNumberString();
        if (null !== t) return t;
        var e = new Array(1).fill(null), n = this.extractSignificantDigits(!1, e), r = Ia.SCI_NOT_EXPONENT_CHAR + e[0];
        if ("0" === n.charAt(0)) throw new Error("Found leading zero: " + n);
        var i = "";
        1 < n.length && (i = n.substring(1));
        var o = n.charAt(0) + "." + i;
        return this.isNegative() ? "-" + o + r : o + r
    }, Ia.prototype.abs = function () {
        return this.isNaN() ? Ia.NaN : this.isNegative() ? this.negate() : new Ia(this)
    }, Ia.prototype.isPositive = function () {
        return (0 < this._hi || 0 === this._hi) && 0 < this._lo
    }, Ia.prototype.lt = function (t) {
        return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo
    }, Ia.prototype.add = function () {
        if (arguments[0] instanceof Ia) {
            var t = arguments[0];
            return Ia.copy(this).selfAdd(t)
        }
        if ("number" == typeof arguments[0]) {
            var e = arguments[0];
            return Ia.copy(this).selfAdd(e)
        }
    }, Ia.prototype.init = function () {
        if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
                var t = arguments[0];
                this._hi = t, this._lo = 0
            } else if (arguments[0] instanceof Ia) {
                var e = arguments[0];
                this._hi = e._hi, this._lo = e._lo
            }
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            this._hi = n, this._lo = r
        }
    }, Ia.prototype.gt = function (t) {
        return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo
    }, Ia.prototype.isNegative = function () {
        return (this._hi < 0 || 0 === this._hi) && this._lo < 0
    }, Ia.prototype.trunc = function () {
        return this.isNaN() ? Ia.NaN : this.isPositive() ? this.floor() : this.ceil()
    }, Ia.prototype.signum = function () {
        return 0 < this._hi ? 1 : this._hi < 0 ? -1 : 0 < this._lo ? 1 : this._lo < 0 ? -1 : 0
    }, Ia.prototype.interfaces_ = function () {
        return [la, ua, ca]
    }, Ia.prototype.getClass = function () {
        return Ia
    }, Ia.sqr = function (t) {
        return Ia.valueOf(t).selfMultiply(t)
    }, Ia.valueOf = function () {
        if ("string" == typeof arguments[0]) {
            var t = arguments[0];
            return Ia.parse(t)
        }
        if ("number" == typeof arguments[0]) {
            var e = arguments[0];
            return new Ia(e)
        }
    }, Ia.sqrt = function (t) {
        return Ia.valueOf(t).sqrt()
    }, Ia.parse = function (t) {
        for (var e = 0, n = t.length; ba.isWhitespace(t.charAt(e));) e++;
        var r = !1;
        if (e < n) {
            var i = t.charAt(e);
            "-" !== i && "+" !== i || (e++, "-" === i && (r = !0))
        }
        for (var o = new Ia, s = 0, a = 0, u = 0; !(n <= e);) {
            var c = t.charAt(e);
            if (e++, ba.isDigit(c)) {
                var h = c - "0";
                o.selfMultiply(Ia.TEN), o.selfAdd(h), s++
            } else {
                if ("." !== c) {
                    if ("e" !== c && "E" !== c) throw new Error("Unexpected character '" + c + "' at position " + e + " in string " + t);
                    var l = t.substring(e);
                    try {
                        u = wa.parseInt(l)
                    } catch (e) {
                        throw e instanceof Error ? new Error("Invalid exponent " + l + " in string " + t) : e
                    }
                    break
                }
                a = s
            }
        }
        var p = o, f = s - a - u;
        if (0 === f) p = o; else if (0 < f) {
            var g = Ia.TEN.pow(f);
            p = o.divide(g)
        } else if (f < 0) {
            var d = Ia.TEN.pow(-f);
            p = o.multiply(d)
        }
        return r ? p.negate() : p
    }, Ia.createNaN = function () {
        return new Ia(sa.NaN, sa.NaN)
    }, Ia.copy = function (t) {
        return new Ia(t)
    }, Ia.magnitude = function (t) {
        var e = Math.abs(t), n = Math.log(e) / Math.log(10), r = Math.trunc(Math.floor(n));
        return 10 * Math.pow(10, r) <= e && (r += 1), r
    }, Ia.stringOfChar = function (t, e) {
        for (var n = new Ea, r = 0; r < e; r++) n.append(t);
        return n.toString()
    }, Na.PI.get = function () {
        return new Ia(3.141592653589793, 12246467991473532e-32)
    }, Na.TWO_PI.get = function () {
        return new Ia(6.283185307179586, 24492935982947064e-32)
    }, Na.PI_2.get = function () {
        return new Ia(1.5707963267948966, 6123233995736766e-32)
    }, Na.E.get = function () {
        return new Ia(2.718281828459045, 14456468917292502e-32)
    }, Na.NaN.get = function () {
        return new Ia(sa.NaN, sa.NaN)
    }, Na.EPS.get = function () {
        return 123259516440783e-46
    }, Na.SPLIT.get = function () {
        return 134217729
    }, Na.MAX_PRINT_DIGITS.get = function () {
        return 32
    }, Na.TEN.get = function () {
        return Ia.valueOf(10)
    }, Na.ONE.get = function () {
        return Ia.valueOf(1)
    }, Na.SCI_NOT_EXPONENT_CHAR.get = function () {
        return "E"
    }, Na.SCI_NOT_ZERO.get = function () {
        return "0.0E0"
    }, Object.defineProperties(Ia, Na);
    var Ca = function () {
    }, Sa = {DP_SAFE_EPSILON: {configurable: !0}};
    Ca.prototype.interfaces_ = function () {
        return []
    }, Ca.prototype.getClass = function () {
        return Ca
    }, Ca.orientationIndex = function (t, e, n) {
        var r = Ca.orientationIndexFilter(t, e, n);
        if (r <= 1) return r;
        var i = Ia.valueOf(e.x).selfAdd(-t.x), o = Ia.valueOf(e.y).selfAdd(-t.y), s = Ia.valueOf(n.x).selfAdd(-e.x),
            a = Ia.valueOf(n.y).selfAdd(-e.y);
        return i.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum()
    }, Ca.signOfDet2x2 = function (t, e, n, r) {
        return t.multiply(r).selfSubtract(e.multiply(n)).signum()
    }, Ca.intersection = function (t, e, n, r) {
        var i = Ia.valueOf(r.y).selfSubtract(n.y).selfMultiply(Ia.valueOf(e.x).selfSubtract(t.x)),
            o = Ia.valueOf(r.x).selfSubtract(n.x).selfMultiply(Ia.valueOf(e.y).selfSubtract(t.y)), s = i.subtract(o),
            a = Ia.valueOf(r.x).selfSubtract(n.x).selfMultiply(Ia.valueOf(t.y).selfSubtract(n.y)),
            u = Ia.valueOf(r.y).selfSubtract(n.y).selfMultiply(Ia.valueOf(t.x).selfSubtract(n.x)),
            c = a.subtract(u).selfDivide(s).doubleValue(),
            h = Ia.valueOf(t.x).selfAdd(Ia.valueOf(e.x).selfSubtract(t.x).selfMultiply(c)).doubleValue(),
            l = Ia.valueOf(e.x).selfSubtract(t.x).selfMultiply(Ia.valueOf(t.y).selfSubtract(n.y)),
            p = Ia.valueOf(e.y).selfSubtract(t.y).selfMultiply(Ia.valueOf(t.x).selfSubtract(n.x)),
            f = l.subtract(p).selfDivide(s).doubleValue(),
            g = Ia.valueOf(n.y).selfAdd(Ia.valueOf(r.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();
        return new pa(h, g)
    }, Ca.orientationIndexFilter = function (t, e, n) {
        var r = null, i = (t.x - n.x) * (e.y - n.y), o = (t.y - n.y) * (e.x - n.x), s = i - o;
        if (0 < i) {
            if (o <= 0) return Ca.signum(s);
            r = i + o
        } else {
            if (!(i < 0)) return Ca.signum(s);
            if (0 <= o) return Ca.signum(s);
            r = -i - o
        }
        var a = Ca.DP_SAFE_EPSILON * r;
        return a <= s || a <= -s ? Ca.signum(s) : 2
    }, Ca.signum = function (t) {
        return 0 < t ? 1 : t < 0 ? -1 : 0
    }, Sa.DP_SAFE_EPSILON.get = function () {
        return 1e-15
    }, Object.defineProperties(Ca, Sa);
    var Ma = function () {
    }, La = {X: {configurable: !0}, Y: {configurable: !0}, Z: {configurable: !0}, M: {configurable: !0}};
    La.X.get = function () {
        return 0
    }, La.Y.get = function () {
        return 1
    }, La.Z.get = function () {
        return 2
    }, La.M.get = function () {
        return 3
    }, Ma.prototype.setOrdinate = function (t, e, n) {
    }, Ma.prototype.size = function () {
    }, Ma.prototype.getOrdinate = function (t, e) {
    }, Ma.prototype.getCoordinate = function () {
    }, Ma.prototype.getCoordinateCopy = function (t) {
    }, Ma.prototype.getDimension = function () {
    }, Ma.prototype.getX = function (t) {
    }, Ma.prototype.clone = function () {
    }, Ma.prototype.expandEnvelope = function (t) {
    }, Ma.prototype.copy = function () {
    }, Ma.prototype.getY = function (t) {
    }, Ma.prototype.toCoordinateArray = function () {
    }, Ma.prototype.interfaces_ = function () {
        return [ca]
    }, Ma.prototype.getClass = function () {
        return Ma
    }, Object.defineProperties(Ma, La);
    var Pa = function () {
    }, Oa = function (t) {
        function e() {
            t.call(this, "Projective point not representable on the Cartesian plane.")
        }

        return t && (e.__proto__ = t), ((e.prototype = Object.create(t && t.prototype)).constructor = e).prototype.interfaces_ = function () {
            return []
        }, e.prototype.getClass = function () {
            return e
        }, e
    }(Pa), Ra = function () {
    };
    Ra.arraycopy = function (t, e, n, r, i) {
        for (var o = 0, s = e; s < e + i; s++) n[r + o] = t[s], o++
    }, Ra.getProperty = function (t) {
        return {"line.separator": "\n"}[t]
    };
    var Ta = function t() {
        if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1; else if (1 === arguments.length) {
            var e = arguments[0];
            this.x = e.x, this.y = e.y, this.w = 1
        } else if (2 === arguments.length) {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                var n = arguments[0], r = arguments[1];
                this.x = n, this.y = r, this.w = 1
            } else if (arguments[0] instanceof t && arguments[1] instanceof t) {
                var i = arguments[0], o = arguments[1];
                this.x = i.y * o.w - o.y * i.w, this.y = o.x * i.w - i.x * o.w, this.w = i.x * o.y - o.x * i.y
            } else if (arguments[0] instanceof pa && arguments[1] instanceof pa) {
                var s = arguments[0], a = arguments[1];
                this.x = s.y - a.y, this.y = a.x - s.x, this.w = s.x * a.y - a.x * s.y
            }
        } else if (3 === arguments.length) {
            var u = arguments[0], c = arguments[1], h = arguments[2];
            this.x = u, this.y = c, this.w = h
        } else if (4 === arguments.length) {
            var l = arguments[0], p = arguments[1], f = arguments[2], g = arguments[3], d = l.y - p.y, y = p.x - l.x,
                _ = l.x * p.y - p.x * l.y, m = f.y - g.y, v = g.x - f.x, x = f.x * g.y - g.x * f.y;
            this.x = y * x - v * _, this.y = m * _ - d * x, this.w = d * v - m * y
        }
    };
    Ta.prototype.getY = function () {
        var t = this.y / this.w;
        if (sa.isNaN(t) || sa.isInfinite(t)) throw new Oa;
        return t
    }, Ta.prototype.getX = function () {
        var t = this.x / this.w;
        if (sa.isNaN(t) || sa.isInfinite(t)) throw new Oa;
        return t
    }, Ta.prototype.getCoordinate = function () {
        var t = new pa;
        return t.x = this.getX(), t.y = this.getY(), t
    }, Ta.prototype.interfaces_ = function () {
        return []
    }, Ta.prototype.getClass = function () {
        return Ta
    }, Ta.intersection = function (t, e, n, r) {
        var i = t.y - e.y, o = e.x - t.x, s = t.x * e.y - e.x * t.y, a = n.y - r.y, u = r.x - n.x,
            c = n.x * r.y - r.x * n.y, h = i * u - a * o, l = (o * c - u * s) / h, p = (a * s - i * c) / h;
        if (sa.isNaN(l) || sa.isInfinite(l) || sa.isNaN(p) || sa.isInfinite(p)) throw new Oa;
        return new pa(l, p)
    };
    var Aa = function t() {
        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init(); else if (1 === arguments.length) {
            if (arguments[0] instanceof pa) {
                var e = arguments[0];
                this.init(e.x, e.x, e.y, e.y)
            } else if (arguments[0] instanceof t) {
                var n = arguments[0];
                this.init(n)
            }
        } else if (2 === arguments.length) {
            var r = arguments[0], i = arguments[1];
            this.init(r.x, i.x, r.y, i.y)
        } else if (4 === arguments.length) {
            var o = arguments[0], s = arguments[1], a = arguments[2], u = arguments[3];
            this.init(o, s, a, u)
        }
    }, Da = {serialVersionUID: {configurable: !0}};
    Aa.prototype.getArea = function () {
        return this.getWidth() * this.getHeight()
    }, Aa.prototype.equals = function (t) {
        if (!(t instanceof Aa)) return !1;
        var e = t;
        return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY()
    }, Aa.prototype.intersection = function (t) {
        if (this.isNull() || t.isNull() || !this.intersects(t)) return new Aa;
        var e = this._minx > t._minx ? this._minx : t._minx, n = this._miny > t._miny ? this._miny : t._miny,
            r = this._maxx < t._maxx ? this._maxx : t._maxx, i = this._maxy < t._maxy ? this._maxy : t._maxy;
        return new Aa(e, r, n, i)
    }, Aa.prototype.isNull = function () {
        return this._maxx < this._minx
    }, Aa.prototype.getMaxX = function () {
        return this._maxx
    }, Aa.prototype.covers = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof pa) {
                var t = arguments[0];
                return this.covers(t.x, t.y)
            }
            if (arguments[0] instanceof Aa) {
                var e = arguments[0];
                return !this.isNull() && !e.isNull() && e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy
            }
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            return !this.isNull() && n >= this._minx && n <= this._maxx && r >= this._miny && r <= this._maxy
        }
    }, Aa.prototype.intersects = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof Aa) {
                var t = arguments[0];
                return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny)
            }
            if (arguments[0] instanceof pa) {
                var e = arguments[0];
                return this.intersects(e.x, e.y)
            }
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            return !this.isNull() && !(n > this._maxx || n < this._minx || r > this._maxy || r < this._miny)
        }
    }, Aa.prototype.getMinY = function () {
        return this._miny
    }, Aa.prototype.getMinX = function () {
        return this._minx
    }, Aa.prototype.expandToInclude = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof pa) {
                var t = arguments[0];
                this.expandToInclude(t.x, t.y)
            } else if (arguments[0] instanceof Aa) {
                var e = arguments[0];
                if (e.isNull()) return null;
                this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy))
            }
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            this.isNull() ? (this._minx = n, this._maxx = n, this._miny = r, this._maxy = r) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), r < this._miny && (this._miny = r), r > this._maxy && (this._maxy = r))
        }
    }, Aa.prototype.minExtent = function () {
        if (this.isNull()) return 0;
        var t = this.getWidth(), e = this.getHeight();
        return t < e ? t : e
    }, Aa.prototype.getWidth = function () {
        return this.isNull() ? 0 : this._maxx - this._minx
    }, Aa.prototype.compareTo = function (t) {
        var e = t;
        return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0
    }, Aa.prototype.translate = function (t, e) {
        if (this.isNull()) return null;
        this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
    }, Aa.prototype.toString = function () {
        return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]"
    }, Aa.prototype.setToNull = function () {
        this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1
    }, Aa.prototype.getHeight = function () {
        return this.isNull() ? 0 : this._maxy - this._miny
    }, Aa.prototype.maxExtent = function () {
        if (this.isNull()) return 0;
        var t = this.getWidth(), e = this.getHeight();
        return e < t ? t : e
    }, Aa.prototype.expandBy = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.expandBy(t, t)
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            if (this.isNull()) return null;
            this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull()
        }
    }, Aa.prototype.contains = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof Aa) {
                var t = arguments[0];
                return this.covers(t)
            }
            if (arguments[0] instanceof pa) {
                var e = arguments[0];
                return this.covers(e)
            }
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            return this.covers(n, r)
        }
    }, Aa.prototype.centre = function () {
        return this.isNull() ? null : new pa((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
    }, Aa.prototype.init = function () {
        if (0 === arguments.length) this.setToNull(); else if (1 === arguments.length) {
            if (arguments[0] instanceof pa) {
                var t = arguments[0];
                this.init(t.x, t.x, t.y, t.y)
            } else if (arguments[0] instanceof Aa) {
                var e = arguments[0];
                this._minx = e._minx, this._maxx = e._maxx, this._miny = e._miny, this._maxy = e._maxy
            }
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            this.init(n.x, r.x, n.y, r.y)
        } else if (4 === arguments.length) {
            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3];
            this._maxx = i < o ? (this._minx = i, o) : (this._minx = o, i), this._maxy = s < a ? (this._miny = s, a) : (this._miny = a, s)
        }
    }, Aa.prototype.getMaxY = function () {
        return this._maxy
    }, Aa.prototype.distance = function (t) {
        if (this.intersects(t)) return 0;
        var e = 0;
        this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
        var n = 0;
        return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
    }, Aa.prototype.hashCode = function () {
        var t = 17;
        return 37 * (t = 37 * (t = 37 * (t = 37 * t + pa.hashCode(this._minx)) + pa.hashCode(this._maxx)) + pa.hashCode(this._miny)) + pa.hashCode(this._maxy)
    }, Aa.prototype.interfaces_ = function () {
        return [ua, la]
    }, Aa.prototype.getClass = function () {
        return Aa
    }, Aa.intersects = function () {
        if (3 === arguments.length) {
            var t = arguments[0], e = arguments[1], n = arguments[2];
            return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y)
        }
        if (4 === arguments.length) {
            var r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3], a = Math.min(o.x, s.x),
                u = Math.max(o.x, s.x), c = Math.min(r.x, i.x), h = Math.max(r.x, i.x);
            return !(u < c || h < a || (a = Math.min(o.y, s.y), u = Math.max(o.y, s.y), c = Math.min(r.y, i.y), h = Math.max(r.y, i.y), u < c || h < a))
        }
    }, Da.serialVersionUID.get = function () {
        return 0x51845cd552189800
    }, Object.defineProperties(Aa, Da);
    var Fa = {
        typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
        emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
        spaces: /\s+/,
        parenComma: /\)\s*,\s*\(/,
        doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
        trimParens: /^\s*\(?(.*?)\)?\s*$/
    }, qa = function (t) {
        this.geometryFactory = t || new bc
    };
    qa.prototype.read = function (t) {
        var e, n, r;
        t = t.replace(/[\n\r]/g, " ");
        var i = Fa.typeStr.exec(t);
        if (-1 !== t.search("EMPTY") && ((i = Fa.emptyTypeStr.exec(t))[2] = void 0), i && (n = i[1].toLowerCase(), r = i[2], Ba[n] && (e = Ba[n].apply(this, [r]))), void 0 === e) throw new Error("Could not parse WKT " + t);
        return e
    }, qa.prototype.write = function (t) {
        return this.extractGeometry(t)
    }, qa.prototype.extractGeometry = function (t) {
        var e = t.getGeometryType().toLowerCase();
        if (!Ga[e]) return null;
        var n = e.toUpperCase();
        return t.isEmpty() ? n + " EMPTY" : n + "(" + Ga[e].apply(this, [t]) + ")"
    };
    var Ga = {
        coordinate: function (t) {
            return t.x + " " + t.y
        }, point: function (t) {
            return Ga.coordinate.call(this, t._coordinates._coordinates[0])
        }, multipoint: function (t) {
            for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push("(" + Ga.point.apply(this, [t._geometries[n]]) + ")");
            return e.join(",")
        }, linestring: function (t) {
            for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n) e.push(Ga.coordinate.apply(this, [t._points._coordinates[n]]));
            return e.join(",")
        }, linearring: function (t) {
            for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n) e.push(Ga.coordinate.apply(this, [t._points._coordinates[n]]));
            return e.join(",")
        }, multilinestring: function (t) {
            for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push("(" + Ga.linestring.apply(this, [t._geometries[n]]) + ")");
            return e.join(",")
        }, polygon: function (t) {
            var e = [];
            e.push("(" + Ga.linestring.apply(this, [t._shell]) + ")");
            for (var n = 0, r = t._holes.length; n < r; ++n) e.push("(" + Ga.linestring.apply(this, [t._holes[n]]) + ")");
            return e.join(",")
        }, multipolygon: function (t) {
            for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push("(" + Ga.polygon.apply(this, [t._geometries[n]]) + ")");
            return e.join(",")
        }, geometrycollection: function (t) {
            for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push(this.extractGeometry(t._geometries[n]));
            return e.join(",")
        }
    }, Ba = {
        point: function (t) {
            if (void 0 === t) return this.geometryFactory.createPoint();
            var e = t.trim().split(Fa.spaces);
            return this.geometryFactory.createPoint(new pa(Number.parseFloat(e[0]), Number.parseFloat(e[1])))
        }, multipoint: function (t) {
            var e;
            if (void 0 === t) return this.geometryFactory.createMultiPoint();
            for (var n = t.trim().split(","), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].replace(Fa.trimParens, "$1"), r.push(Ba.point.apply(this, [e]));
            return this.geometryFactory.createMultiPoint(r)
        }, linestring: function (t) {
            if (void 0 === t) return this.geometryFactory.createLineString();
            for (var e, n = t.trim().split(","), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].trim().split(Fa.spaces), r.push(new pa(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
            return this.geometryFactory.createLineString(r)
        }, linearring: function (t) {
            if (void 0 === t) return this.geometryFactory.createLinearRing();
            for (var e, n = t.trim().split(","), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].trim().split(Fa.spaces), r.push(new pa(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
            return this.geometryFactory.createLinearRing(r)
        }, multilinestring: function (t) {
            var e;
            if (void 0 === t) return this.geometryFactory.createMultiLineString();
            for (var n = t.trim().split(Fa.parenComma), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].replace(Fa.trimParens, "$1"), r.push(Ba.linestring.apply(this, [e]));
            return this.geometryFactory.createMultiLineString(r)
        }, polygon: function (t) {
            var e, n, r;
            if (void 0 === t) return this.geometryFactory.createPolygon();
            for (var i, o = t.trim().split(Fa.parenComma), s = [], a = 0, u = o.length; a < u; ++a) e = o[a].replace(Fa.trimParens, "$1"), n = Ba.linestring.apply(this, [e]), r = this.geometryFactory.createLinearRing(n._points), 0 === a ? i = r : s.push(r);
            return this.geometryFactory.createPolygon(i, s)
        }, multipolygon: function (t) {
            var e;
            if (void 0 === t) return this.geometryFactory.createMultiPolygon();
            for (var n = t.trim().split(Fa.doubleParenComma), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].replace(Fa.trimParens, "$1"), r.push(Ba.polygon.apply(this, [e]));
            return this.geometryFactory.createMultiPolygon(r)
        }, geometrycollection: function (t) {
            if (void 0 === t) return this.geometryFactory.createGeometryCollection();
            for (var e = (t = t.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n = [], r = 0, i = e.length; r < i; ++r) n.push(this.read(e[r]));
            return this.geometryFactory.createGeometryCollection(n)
        }
    }, ka = function (t) {
        this.parser = new qa(t)
    };
    ka.prototype.write = function (t) {
        return this.parser.write(t)
    }, ka.toLineString = function (t, e) {
        if (2 !== arguments.length) throw new Error("Not implemented");
        return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
    };
    var za = function (e) {
        function t(t) {
            e.call(this, t), this.name = "RuntimeException", this.message = t, this.stack = (new e).stack
        }

        return e && (t.__proto__ = e), (t.prototype = Object.create(e && e.prototype)).constructor = t
    }(Error), ja = function (e) {
        function t() {
            if (e.call(this), 0 === arguments.length) e.call(this); else if (1 === arguments.length) {
                var t = arguments[0];
                e.call(this, t)
            }
        }

        return e && (t.__proto__ = e), ((t.prototype = Object.create(e && e.prototype)).constructor = t).prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(za), Xa = function () {
    };
    Xa.prototype.interfaces_ = function () {
        return []
    }, Xa.prototype.getClass = function () {
        return Xa
    }, Xa.shouldNeverReachHere = function () {
        if (0 === arguments.length) Xa.shouldNeverReachHere(null); else if (1 === arguments.length) {
            var t = arguments[0];
            throw new ja("Should never reach here" + (null !== t ? ": " + t : ""))
        }
    }, Xa.isTrue = function () {
        var t, e;
        if (1 === arguments.length) t = arguments[0], Xa.isTrue(t, null); else if (2 === arguments.length && (t = arguments[0], e = arguments[1], !t)) throw null === e ? new ja : new ja(e)
    }, Xa.equals = function () {
        var t, e, n;
        if (2 === arguments.length) t = arguments[0], e = arguments[1], Xa.equals(t, e, null); else if (3 === arguments.length && (t = arguments[0], e = arguments[1], n = arguments[2], !e.equals(t))) throw new ja("Expected " + t + " but encountered " + e + (null !== n ? ": " + n : ""))
    };
    var Ua = function () {
        this._result = null, this._inputLines = Array(2).fill().map(function () {
            return Array(2)
        }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new pa, this._intPt[1] = new pa, this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0
    }, Ya = {
        DONT_INTERSECT: {configurable: !0},
        DO_INTERSECT: {configurable: !0},
        COLLINEAR: {configurable: !0},
        NO_INTERSECTION: {configurable: !0},
        POINT_INTERSECTION: {configurable: !0},
        COLLINEAR_INTERSECTION: {configurable: !0}
    };
    Ua.prototype.getIndexAlongSegment = function (t, e) {
        return this.computeIntLineIndex(), this._intLineIndex[t][e]
    }, Ua.prototype.getTopologySummary = function () {
        var t = new Ea;
        return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString()
    }, Ua.prototype.computeIntersection = function (t, e, n, r) {
        this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = r, this._result = this.computeIntersect(t, e, n, r)
    }, Ua.prototype.getIntersectionNum = function () {
        return this._result
    }, Ua.prototype.computeIntLineIndex = function () {
        if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function () {
            return Array(2)
        }), this.computeIntLineIndex(0), this.computeIntLineIndex(1)); else if (1 === arguments.length) {
            var t = arguments[0], e = this.getEdgeDistance(t, 0), n = this.getEdgeDistance(t, 1);
            this._intLineIndex[t][1] = n < e ? (this._intLineIndex[t][0] = 0, 1) : (this._intLineIndex[t][0] = 1, 0)
        }
    }, Ua.prototype.isProper = function () {
        return this.hasIntersection() && this._isProper
    }, Ua.prototype.setPrecisionModel = function (t) {
        this._precisionModel = t
    }, Ua.prototype.isInteriorIntersection = function () {
        if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
        if (1 === arguments.length) {
            for (var t = arguments[0], e = 0; e < this._result; e++) if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0;
            return !1
        }
    }, Ua.prototype.getIntersection = function (t) {
        return this._intPt[t]
    }, Ua.prototype.isEndPoint = function () {
        return this.hasIntersection() && !this._isProper
    }, Ua.prototype.hasIntersection = function () {
        return this._result !== Ua.NO_INTERSECTION
    }, Ua.prototype.getEdgeDistance = function (t, e) {
        return Ua.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1])
    }, Ua.prototype.isCollinear = function () {
        return this._result === Ua.COLLINEAR_INTERSECTION
    }, Ua.prototype.toString = function () {
        return ka.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + ka.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
    }, Ua.prototype.getEndpoint = function (t, e) {
        return this._inputLines[t][e]
    }, Ua.prototype.isIntersection = function (t) {
        for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;
        return !1
    }, Ua.prototype.getIntersectionAlongSegment = function (t, e) {
        return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]]
    }, Ua.prototype.interfaces_ = function () {
        return []
    }, Ua.prototype.getClass = function () {
        return Ua
    }, Ua.computeEdgeDistance = function (t, e, n) {
        var r = Math.abs(n.x - e.x), i = Math.abs(n.y - e.y), o = -1;
        if (t.equals(e)) o = 0; else if (t.equals(n)) o = i < r ? r : i; else {
            var s = Math.abs(t.x - e.x), a = Math.abs(t.y - e.y);
            0 !== (o = i < r ? s : a) || t.equals(e) || (o = Math.max(s, a))
        }
        return Xa.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o
    }, Ua.nonRobustComputeEdgeDistance = function (t, e, n) {
        var r = t.x - e.x, i = t.y - e.y, o = Math.sqrt(r * r + i * i);
        return Xa.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o
    }, Ya.DONT_INTERSECT.get = function () {
        return 0
    }, Ya.DO_INTERSECT.get = function () {
        return 1
    }, Ya.COLLINEAR.get = function () {
        return 2
    }, Ya.NO_INTERSECTION.get = function () {
        return 0
    }, Ya.POINT_INTERSECTION.get = function () {
        return 1
    }, Ya.COLLINEAR_INTERSECTION.get = function () {
        return 2
    }, Object.defineProperties(Ua, Ya);
    var Va = function (u) {
        function s() {
            u.apply(this, arguments)
        }

        return u && (s.__proto__ = u), ((s.prototype = Object.create(u && u.prototype)).constructor = s).prototype.isInSegmentEnvelopes = function (t) {
            var e = new Aa(this._inputLines[0][0], this._inputLines[0][1]),
                n = new Aa(this._inputLines[1][0], this._inputLines[1][1]);
            return e.contains(t) && n.contains(t)
        }, s.prototype.computeIntersection = function () {
            if (3 !== arguments.length) return u.prototype.computeIntersection.apply(this, arguments);
            var t = arguments[0], e = arguments[1], n = arguments[2];
            if (this._isProper = !1, Aa.intersects(e, n, t) && 0 === Ja.orientationIndex(e, n, t) && 0 === Ja.orientationIndex(n, e, t)) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this._result = u.POINT_INTERSECTION, null;
            this._result = u.NO_INTERSECTION
        }, s.prototype.normalizeToMinimum = function (t, e, n, r, i) {
            i.x = this.smallestInAbsValue(t.x, e.x, n.x, r.x), i.y = this.smallestInAbsValue(t.y, e.y, n.y, r.y), t.x -= i.x, t.y -= i.y, e.x -= i.x, e.y -= i.y, n.x -= i.x, n.y -= i.y, r.x -= i.x, r.y -= i.y
        }, s.prototype.safeHCoordinateIntersection = function (e, n, r, i) {
            var o = null;
            try {
                o = Ta.intersection(e, n, r, i)
            } catch (t) {
                if (!(t instanceof Oa)) throw t;
                o = s.nearestEndpoint(e, n, r, i)
            }
            return o
        }, s.prototype.intersection = function (t, e, n, r) {
            var i = this.intersectionWithNormalization(t, e, n, r);
            return this.isInSegmentEnvelopes(i) || (i = new pa(s.nearestEndpoint(t, e, n, r))), null !== this._precisionModel && this._precisionModel.makePrecise(i), i
        }, s.prototype.smallestInAbsValue = function (t, e, n, r) {
            var i = t, o = Math.abs(i);
            return Math.abs(e) < o && (i = e, o = Math.abs(e)), Math.abs(n) < o && (i = n, o = Math.abs(n)), Math.abs(r) < o && (i = r), i
        }, s.prototype.checkDD = function (t, e, n, r, i) {
            var o = Ca.intersection(t, e, n, r), s = this.isInSegmentEnvelopes(o);
            Ra.out.println("DD in env = " + s + "  --------------------- " + o), 1e-4 < i.distance(o) && Ra.out.println("Distance = " + i.distance(o))
        }, s.prototype.intersectionWithNormalization = function (t, e, n, r) {
            var i = new pa(t), o = new pa(e), s = new pa(n), a = new pa(r), u = new pa;
            this.normalizeToEnvCentre(i, o, s, a, u);
            var c = this.safeHCoordinateIntersection(i, o, s, a);
            return c.x += u.x, c.y += u.y, c
        }, s.prototype.computeCollinearIntersection = function (t, e, n, r) {
            var i = Aa.intersects(t, e, n), o = Aa.intersects(t, e, r), s = Aa.intersects(n, r, t),
                a = Aa.intersects(n, r, e);
            return i && o ? (this._intPt[0] = n, this._intPt[1] = r, u.COLLINEAR_INTERSECTION) : s && a ? (this._intPt[0] = t, this._intPt[1] = e, u.COLLINEAR_INTERSECTION) : i && s ? (this._intPt[0] = n, this._intPt[1] = t, !n.equals(t) || o || a ? u.COLLINEAR_INTERSECTION : u.POINT_INTERSECTION) : i && a ? (this._intPt[0] = n, this._intPt[1] = e, !n.equals(e) || o || s ? u.COLLINEAR_INTERSECTION : u.POINT_INTERSECTION) : o && s ? (this._intPt[0] = r, this._intPt[1] = t, !r.equals(t) || i || a ? u.COLLINEAR_INTERSECTION : u.POINT_INTERSECTION) : o && a ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || i || s ? u.COLLINEAR_INTERSECTION : u.POINT_INTERSECTION) : u.NO_INTERSECTION
        }, s.prototype.normalizeToEnvCentre = function (t, e, n, r, i) {
            var o = t.x < e.x ? t.x : e.x, s = t.y < e.y ? t.y : e.y, a = t.x > e.x ? t.x : e.x,
                u = t.y > e.y ? t.y : e.y, c = n.x < r.x ? n.x : r.x, h = n.y < r.y ? n.y : r.y,
                l = n.x > r.x ? n.x : r.x, p = n.y > r.y ? n.y : r.y, f = ((c < o ? o : c) + (a < l ? a : l)) / 2,
                g = ((h < s ? s : h) + (u < p ? u : p)) / 2;
            i.x = f, i.y = g, t.x -= i.x, t.y -= i.y, e.x -= i.x, e.y -= i.y, n.x -= i.x, n.y -= i.y, r.x -= i.x, r.y -= i.y
        }, s.prototype.computeIntersect = function (t, e, n, r) {
            if (this._isProper = !1, !Aa.intersects(t, e, n, r)) return u.NO_INTERSECTION;
            var i = Ja.orientationIndex(t, e, n), o = Ja.orientationIndex(t, e, r);
            if (0 < i && 0 < o || i < 0 && o < 0) return u.NO_INTERSECTION;
            var s = Ja.orientationIndex(n, r, t), a = Ja.orientationIndex(n, r, e);
            return 0 < s && 0 < a || s < 0 && a < 0 ? u.NO_INTERSECTION : 0 === i && 0 === o && 0 === s && 0 === a ? this.computeCollinearIntersection(t, e, n, r) : (0 === i || 0 === o || 0 === s || 0 === a ? (this._isProper = !1, t.equals2D(n) || t.equals2D(r) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(r) ? this._intPt[0] = e : 0 === i ? this._intPt[0] = new pa(n) : 0 === o ? this._intPt[0] = new pa(r) : 0 === s ? this._intPt[0] = new pa(t) : 0 === a && (this._intPt[0] = new pa(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, r)), u.POINT_INTERSECTION)
        }, s.prototype.interfaces_ = function () {
            return []
        }, s.prototype.getClass = function () {
            return s
        }, s.nearestEndpoint = function (t, e, n, r) {
            var i = t, o = Ja.distancePointLine(t, n, r), s = Ja.distancePointLine(e, n, r);
            return s < o && (o = s, i = e), (s = Ja.distancePointLine(n, t, e)) < o && (o = s, i = n), (s = Ja.distancePointLine(r, t, e)) < o && (o = s, i = r), i
        }, s
    }(Ua), Ha = function () {
    };
    Ha.prototype.interfaces_ = function () {
        return []
    }, Ha.prototype.getClass = function () {
        return Ha
    }, Ha.orientationIndex = function (t, e, n) {
        var r = e.x - t.x, i = e.y - t.y, o = n.x - e.x, s = n.y - e.y;
        return Ha.signOfDet2x2(r, i, o, s)
    }, Ha.signOfDet2x2 = function (t, e, n, r) {
        var i = null, o = null, s = null;
        if (i = 1, 0 === t || 0 === r) return 0 === e || 0 === n ? 0 : 0 < e ? 0 < n ? -i : i : 0 < n ? i : -i;
        if (0 === e || 0 === n) return 0 < r ? 0 < t ? i : -i : 0 < t ? -i : i;
        if (0 < e ? 0 < r ? e <= r || (i = -i, o = t, t = n, n = o, o = e, e = r, r = o) : r = e <= -r ? (i = -i, n = -n, -r) : (o = t, t = -n, n = o, o = e, e = -r, o) : 0 < r ? -e <= r ? (i = -i, t = -t, e = -e) : (o = -t, t = n, n = o, o = -e, e = r, r = o) : r = r <= e ? (t = -t, e = -e, n = -n, -r) : (i = -i, o = -t, t = -n, n = o, o = -e, e = -r, o), 0 < t) {
            if (!(0 < n)) return i;
            if (!(t <= n)) return i
        } else {
            if (0 < n) return -i;
            if (!(n <= t)) return -i;
            i = -i, t = -t, n = -n
        }
        for (; ;) {
            if ((r -= (s = Math.floor(n / t)) * e) < 0) return -i;
            if (e < r) return i;
            if ((n -= s * t) + n < t) {
                if (e < r + r) return i
            } else {
                if (r + r < e) return -i;
                n = t - n, r = e - r, i = -i
            }
            if (0 === r) return 0 === n ? 0 : -i;
            if (0 === n) return i;
            if ((e -= (s = Math.floor(t / n)) * r) < 0) return i;
            if (r < e) return -i;
            if ((t -= s * n) + t < n) {
                if (r < e + e) return -i
            } else {
                if (e + e < r) return i;
                t = n - t, e = r - e, i = -i
            }
            if (0 === e) return 0 === t ? 0 : i;
            if (0 === t) return -i
        }
    };
    var Wa = function () {
        this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
        var t = arguments[0];
        this._p = t
    };
    Wa.prototype.countSegment = function (t, e) {
        if (t.x < this._p.x && e.x < this._p.x) return null;
        if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;
        if (t.y === this._p.y && e.y === this._p.y) {
            var n = t.x, r = e.x;
            return r < n && (n = e.x, r = t.x), this._p.x >= n && this._p.x <= r && (this._isPointOnSegment = !0), null
        }
        if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
            var i = t.x - this._p.x, o = t.y - this._p.y, s = e.x - this._p.x, a = e.y - this._p.y,
                u = Ha.signOfDet2x2(i, o, s, a);
            if (0 === u) return this._isPointOnSegment = !0, null;
            a < o && (u = -u), 0 < u && this._crossingCount++
        }
    }, Wa.prototype.isPointInPolygon = function () {
        return this.getLocation() !== ya.EXTERIOR
    }, Wa.prototype.getLocation = function () {
        return this._isPointOnSegment ? ya.BOUNDARY : this._crossingCount % 2 == 1 ? ya.INTERIOR : ya.EXTERIOR
    }, Wa.prototype.isOnSegment = function () {
        return this._isPointOnSegment
    }, Wa.prototype.interfaces_ = function () {
        return []
    }, Wa.prototype.getClass = function () {
        return Wa
    }, Wa.locatePointInRing = function () {
        if (arguments[0] instanceof pa && ma(arguments[1], Ma)) {
            for (var t = arguments[0], e = arguments[1], n = new Wa(t), r = new pa, i = new pa, o = 1; o < e.size(); o++) if (e.getCoordinate(o, r), e.getCoordinate(o - 1, i), n.countSegment(r, i), n.isOnSegment()) return n.getLocation();
            return n.getLocation()
        }
        if (arguments[0] instanceof pa && arguments[1] instanceof Array) {
            for (var s = arguments[0], a = arguments[1], u = new Wa(s), c = 1; c < a.length; c++) {
                var h = a[c], l = a[c - 1];
                if (u.countSegment(h, l), u.isOnSegment()) return u.getLocation()
            }
            return u.getLocation()
        }
    };
    var Ja = function () {
    }, Za = {
        CLOCKWISE: {configurable: !0},
        RIGHT: {configurable: !0},
        COUNTERCLOCKWISE: {configurable: !0},
        LEFT: {configurable: !0},
        COLLINEAR: {configurable: !0},
        STRAIGHT: {configurable: !0}
    };
    Ja.prototype.interfaces_ = function () {
        return []
    }, Ja.prototype.getClass = function () {
        return Ja
    }, Ja.orientationIndex = function (t, e, n) {
        return Ca.orientationIndex(t, e, n)
    }, Ja.signedArea = function () {
        if (arguments[0] instanceof Array) {
            var t = arguments[0];
            if (t.length < 3) return 0;
            for (var e = 0, n = t[0].x, r = 1; r < t.length - 1; r++) {
                var i = t[r].x - n, o = t[r + 1].y;
                e += i * (t[r - 1].y - o)
            }
            return e / 2
        }
        if (ma(arguments[0], Ma)) {
            var s = arguments[0], a = s.size();
            if (a < 3) return 0;
            var u = new pa, c = new pa, h = new pa;
            s.getCoordinate(0, c), s.getCoordinate(1, h);
            var l = c.x;
            h.x -= l;
            for (var p = 0, f = 1; f < a - 1; f++) u.y = c.y, c.x = h.x, c.y = h.y, s.getCoordinate(f + 1, h), h.x -= l, p += c.x * (u.y - h.y);
            return p / 2
        }
    }, Ja.distanceLineLine = function (t, e, n, r) {
        if (t.equals(e)) return Ja.distancePointLine(t, n, r);
        if (n.equals(r)) return Ja.distancePointLine(r, t, e);
        var i = !1;
        if (Aa.intersects(t, e, n, r)) {
            var o = (e.x - t.x) * (r.y - n.y) - (e.y - t.y) * (r.x - n.x);
            if (0 === o) i = !0; else {
                var s = (t.y - n.y) * (r.x - n.x) - (t.x - n.x) * (r.y - n.y),
                    a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / o, u = s / o;
                (u < 0 || 1 < u || a < 0 || 1 < a) && (i = !0)
            }
        } else i = !0;
        return i ? va.min(Ja.distancePointLine(t, n, r), Ja.distancePointLine(e, n, r), Ja.distancePointLine(n, t, e), Ja.distancePointLine(r, t, e)) : 0
    }, Ja.isPointInRing = function (t, e) {
        return Ja.locatePointInRing(t, e) !== ya.EXTERIOR
    }, Ja.computeLength = function (t) {
        var e = t.size();
        if (e <= 1) return 0;
        var n = 0, r = new pa;
        t.getCoordinate(0, r);
        for (var i = r.x, o = r.y, s = 1; s < e; s++) {
            t.getCoordinate(s, r);
            var a = r.x, u = r.y, c = a - i, h = u - o;
            n += Math.sqrt(c * c + h * h), i = a, o = u
        }
        return n
    }, Ja.isCCW = function (t) {
        var e = t.length - 1;
        if (e < 3) throw new oa("Ring has fewer than 4 points, so orientation cannot be determined");
        for (var n = t[0], r = 0, i = 1; i <= e; i++) {
            var o = t[i];
            o.y > n.y && (n = o, r = i)
        }
        for (var s = r; (s -= 1) < 0 && (s = e), t[s].equals2D(n) && s !== r;) ;
        for (var a = r; t[a = (a + 1) % e].equals2D(n) && a !== r;) ;
        var u = t[s], c = t[a];
        if (u.equals2D(n) || c.equals2D(n) || u.equals2D(c)) return !1;
        var h = Ja.computeOrientation(u, n, c);
        return 0 === h ? u.x > c.x : 0 < h
    }, Ja.locatePointInRing = function (t, e) {
        return Wa.locatePointInRing(t, e)
    }, Ja.distancePointLinePerpendicular = function (t, e, n) {
        var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
            i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r;
        return Math.abs(i) * Math.sqrt(r)
    }, Ja.computeOrientation = function (t, e, n) {
        return Ja.orientationIndex(t, e, n)
    }, Ja.distancePointLine = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            if (0 === e.length) throw new oa("Line array must contain at least one vertex");
            for (var n = t.distance(e[0]), r = 0; r < e.length - 1; r++) {
                var i = Ja.distancePointLine(t, e[r], e[r + 1]);
                i < n && (n = i)
            }
            return n
        }
        if (3 === arguments.length) {
            var o = arguments[0], s = arguments[1], a = arguments[2];
            if (s.x === a.x && s.y === a.y) return o.distance(s);
            var u = (a.x - s.x) * (a.x - s.x) + (a.y - s.y) * (a.y - s.y),
                c = ((o.x - s.x) * (a.x - s.x) + (o.y - s.y) * (a.y - s.y)) / u;
            if (c <= 0) return o.distance(s);
            if (1 <= c) return o.distance(a);
            var h = ((s.y - o.y) * (a.x - s.x) - (s.x - o.x) * (a.y - s.y)) / u;
            return Math.abs(h) * Math.sqrt(u)
        }
    }, Ja.isOnLine = function (t, e) {
        for (var n = new Va, r = 1; r < e.length; r++) {
            var i = e[r - 1], o = e[r];
            if (n.computeIntersection(t, i, o), n.hasIntersection()) return !0
        }
        return !1
    }, Za.CLOCKWISE.get = function () {
        return -1
    }, Za.RIGHT.get = function () {
        return Ja.CLOCKWISE
    }, Za.COUNTERCLOCKWISE.get = function () {
        return 1
    }, Za.LEFT.get = function () {
        return Ja.COUNTERCLOCKWISE
    }, Za.COLLINEAR.get = function () {
        return 0
    }, Za.STRAIGHT.get = function () {
        return Ja.COLLINEAR
    }, Object.defineProperties(Ja, Za);
    var Ka = function () {
    };
    Ka.prototype.filter = function (t) {
    }, Ka.prototype.interfaces_ = function () {
        return []
    }, Ka.prototype.getClass = function () {
        return Ka
    };
    var Qa = function () {
        var t = arguments[0];
        this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t, this._SRID = t.getSRID()
    }, $a = {
        serialVersionUID: {configurable: !0},
        SORTINDEX_POINT: {configurable: !0},
        SORTINDEX_MULTIPOINT: {configurable: !0},
        SORTINDEX_LINESTRING: {configurable: !0},
        SORTINDEX_LINEARRING: {configurable: !0},
        SORTINDEX_MULTILINESTRING: {configurable: !0},
        SORTINDEX_POLYGON: {configurable: !0},
        SORTINDEX_MULTIPOLYGON: {configurable: !0},
        SORTINDEX_GEOMETRYCOLLECTION: {configurable: !0},
        geometryChangedFilter: {configurable: !0}
    };
    Qa.prototype.isGeometryCollection = function () {
        return this.getSortIndex() === Qa.SORTINDEX_GEOMETRYCOLLECTION
    }, Qa.prototype.getFactory = function () {
        return this._factory
    }, Qa.prototype.getGeometryN = function (t) {
        return this
    }, Qa.prototype.getArea = function () {
        return 0
    }, Qa.prototype.isRectangle = function () {
        return !1
    }, Qa.prototype.equals = function () {
        if (arguments[0] instanceof Qa) {
            var t = arguments[0];
            return null !== t && this.equalsTopo(t)
        }
        if (arguments[0] instanceof Object) {
            var e = arguments[0];
            if (!(e instanceof Qa)) return !1;
            var n = e;
            return this.equalsExact(n)
        }
    }, Qa.prototype.equalsExact = function (t) {
        return this === t || this.equalsExact(t, 0)
    }, Qa.prototype.geometryChanged = function () {
        this.apply(Qa.geometryChangedFilter)
    }, Qa.prototype.geometryChangedAction = function () {
        this._envelope = null
    }, Qa.prototype.equalsNorm = function (t) {
        return null !== t && this.norm().equalsExact(t.norm())
    }, Qa.prototype.getLength = function () {
        return 0
    }, Qa.prototype.getNumGeometries = function () {
        return 1
    }, Qa.prototype.compareTo = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = t;
            return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t)
        }
        if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, r)
        }
    }, Qa.prototype.getUserData = function () {
        return this._userData
    }, Qa.prototype.getSRID = function () {
        return this._SRID
    }, Qa.prototype.getEnvelope = function () {
        return this.getFactory().toGeometry(this.getEnvelopeInternal())
    }, Qa.prototype.checkNotGeometryCollection = function (t) {
        if (t.getSortIndex() === Qa.SORTINDEX_GEOMETRYCOLLECTION) throw new oa("This method does not support GeometryCollection arguments")
    }, Qa.prototype.equal = function (t, e, n) {
        return 0 === n ? t.equals(e) : t.distance(e) <= n
    }, Qa.prototype.norm = function () {
        var t = this.copy();
        return t.normalize(), t
    }, Qa.prototype.getPrecisionModel = function () {
        return this._factory.getPrecisionModel()
    }, Qa.prototype.getEnvelopeInternal = function () {
        return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new Aa(this._envelope)
    }, Qa.prototype.setSRID = function (t) {
        this._SRID = t
    }, Qa.prototype.setUserData = function (t) {
        this._userData = t
    }, Qa.prototype.compare = function (t, e) {
        for (var n = t.iterator(), r = e.iterator(); n.hasNext() && r.hasNext();) {
            var i = n.next(), o = r.next(), s = i.compareTo(o);
            if (0 !== s) return s
        }
        return n.hasNext() ? 1 : r.hasNext() ? -1 : 0
    }, Qa.prototype.hashCode = function () {
        return this.getEnvelopeInternal().hashCode()
    }, Qa.prototype.isGeometryCollectionOrDerived = function () {
        return this.getSortIndex() === Qa.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Qa.SORTINDEX_MULTIPOINT || this.getSortIndex() === Qa.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Qa.SORTINDEX_MULTIPOLYGON
    }, Qa.prototype.interfaces_ = function () {
        return [ca, ua, la]
    }, Qa.prototype.getClass = function () {
        return Qa
    }, Qa.hasNonEmptyElements = function (t) {
        for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;
        return !1
    }, Qa.hasNullElements = function (t) {
        for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;
        return !1
    }, $a.serialVersionUID.get = function () {
        return 0x799ea46522854c00
    }, $a.SORTINDEX_POINT.get = function () {
        return 0
    }, $a.SORTINDEX_MULTIPOINT.get = function () {
        return 1
    }, $a.SORTINDEX_LINESTRING.get = function () {
        return 2
    }, $a.SORTINDEX_LINEARRING.get = function () {
        return 3
    }, $a.SORTINDEX_MULTILINESTRING.get = function () {
        return 4
    }, $a.SORTINDEX_POLYGON.get = function () {
        return 5
    }, $a.SORTINDEX_MULTIPOLYGON.get = function () {
        return 6
    }, $a.SORTINDEX_GEOMETRYCOLLECTION.get = function () {
        return 7
    }, $a.geometryChangedFilter.get = function () {
        return tu
    }, Object.defineProperties(Qa, $a);
    var tu = function () {
    };
    tu.interfaces_ = function () {
        return [Ka]
    }, tu.filter = function (t) {
        t.geometryChangedAction()
    };
    var eu = function () {
    };
    eu.prototype.filter = function (t) {
    }, eu.prototype.interfaces_ = function () {
        return []
    }, eu.prototype.getClass = function () {
        return eu
    };
    var nu = function () {
    }, ru = {
        Mod2BoundaryNodeRule: {configurable: !0},
        EndPointBoundaryNodeRule: {configurable: !0},
        MultiValentEndPointBoundaryNodeRule: {configurable: !0},
        MonoValentEndPointBoundaryNodeRule: {configurable: !0},
        MOD2_BOUNDARY_RULE: {configurable: !0},
        ENDPOINT_BOUNDARY_RULE: {configurable: !0},
        MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {configurable: !0},
        MONOVALENT_ENDPOINT_BOUNDARY_RULE: {configurable: !0},
        OGC_SFS_BOUNDARY_RULE: {configurable: !0}
    };
    nu.prototype.isInBoundary = function (t) {
    }, nu.prototype.interfaces_ = function () {
        return []
    }, nu.prototype.getClass = function () {
        return nu
    }, ru.Mod2BoundaryNodeRule.get = function () {
        return iu
    }, ru.EndPointBoundaryNodeRule.get = function () {
        return ou
    }, ru.MultiValentEndPointBoundaryNodeRule.get = function () {
        return su
    }, ru.MonoValentEndPointBoundaryNodeRule.get = function () {
        return au
    }, ru.MOD2_BOUNDARY_RULE.get = function () {
        return new iu
    }, ru.ENDPOINT_BOUNDARY_RULE.get = function () {
        return new ou
    }, ru.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {
        return new su
    }, ru.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {
        return new au
    }, ru.OGC_SFS_BOUNDARY_RULE.get = function () {
        return nu.MOD2_BOUNDARY_RULE
    }, Object.defineProperties(nu, ru);
    var iu = function () {
    };
    iu.prototype.isInBoundary = function (t) {
        return t % 2 == 1
    }, iu.prototype.interfaces_ = function () {
        return [nu]
    }, iu.prototype.getClass = function () {
        return iu
    };
    var ou = function () {
    };
    ou.prototype.isInBoundary = function (t) {
        return 0 < t
    }, ou.prototype.interfaces_ = function () {
        return [nu]
    }, ou.prototype.getClass = function () {
        return ou
    };
    var su = function () {
    };
    su.prototype.isInBoundary = function (t) {
        return 1 < t
    }, su.prototype.interfaces_ = function () {
        return [nu]
    }, su.prototype.getClass = function () {
        return su
    };
    var au = function () {
    };
    au.prototype.isInBoundary = function (t) {
        return 1 === t
    }, au.prototype.interfaces_ = function () {
        return [nu]
    }, au.prototype.getClass = function () {
        return au
    };
    var uu = function () {
    };
    uu.prototype.add = function () {
    }, uu.prototype.addAll = function () {
    }, uu.prototype.isEmpty = function () {
    }, uu.prototype.iterator = function () {
    }, uu.prototype.size = function () {
    }, uu.prototype.toArray = function () {
    }, uu.prototype.remove = function () {
    };
    var cu = function (e) {
        function t(t) {
            e.call(this), this.message = t || ""
        }

        e && (t.__proto__ = e), (t.prototype = Object.create(e && e.prototype)).constructor = t;
        var n = {name: {configurable: !0}};
        return n.name.get = function () {
            return "IndexOutOfBoundsException"
        }, Object.defineProperties(t, n), t
    }(Error), hu = function () {
    };
    hu.prototype.hasNext = function () {
    }, hu.prototype.next = function () {
    }, hu.prototype.remove = function () {
    };
    var lu = function (t) {
        function e() {
            t.apply(this, arguments)
        }

        return t && (e.__proto__ = t), ((e.prototype = Object.create(t && t.prototype)).constructor = e).prototype.get = function () {
        }, e.prototype.set = function () {
        }, e.prototype.isEmpty = function () {
        }, e
    }(uu);

    function pu(t) {
        this.message = t || ""
    }

    (pu.prototype = new Error).name = "NoSuchElementException";
    var fu = function (t) {
        function e() {
            t.call(this), this.array_ = [], arguments[0] instanceof uu && this.addAll(arguments[0])
        }

        return t && (e.__proto__ = t), ((e.prototype = Object.create(t && t.prototype)).constructor = e).prototype.ensureCapacity = function () {
        }, e.prototype.interfaces_ = function () {
            return [t, uu]
        }, e.prototype.add = function (t) {
            return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(t, arguments[1]), !0
        }, e.prototype.clear = function () {
            this.array_ = []
        }, e.prototype.addAll = function (t) {
            for (var e = t.iterator(); e.hasNext();) this.add(e.next());
            return !0
        }, e.prototype.set = function (t, e) {
            var n = this.array_[t];
            return this.array_[t] = e, n
        }, e.prototype.iterator = function () {
            return new gu(this)
        }, e.prototype.get = function (t) {
            if (t < 0 || t >= this.size()) throw new cu;
            return this.array_[t]
        }, e.prototype.isEmpty = function () {
            return 0 === this.array_.length
        }, e.prototype.size = function () {
            return this.array_.length
        }, e.prototype.toArray = function () {
            for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
            return t
        }, e.prototype.remove = function (t) {
            for (var e = !1, n = 0, r = this.array_.length; n < r; n++) if (this.array_[n] === t) {
                this.array_.splice(n, 1), e = !0;
                break
            }
            return e
        }, e
    }(lu), gu = function (e) {
        function t(t) {
            e.call(this), this.arrayList_ = t, this.position_ = 0
        }

        return e && (t.__proto__ = e), ((t.prototype = Object.create(e && e.prototype)).constructor = t).prototype.next = function () {
            if (this.position_ === this.arrayList_.size()) throw new pu;
            return this.arrayList_.get(this.position_++)
        }, t.prototype.hasNext = function () {
            return this.position_ < this.arrayList_.size()
        }, t.prototype.set = function (t) {
            return this.arrayList_.set(this.position_ - 1, t)
        }, t.prototype.remove = function () {
            this.arrayList_.remove(this.arrayList_.get(this.position_))
        }, t
    }(hu), du = function (v) {
        function t() {
            if (v.call(this), 0 === arguments.length) ; else if (1 === arguments.length) {
                var t = arguments[0];
                this.ensureCapacity(t.length), this.add(t, !0)
            } else if (2 === arguments.length) {
                var e = arguments[0], n = arguments[1];
                this.ensureCapacity(e.length), this.add(e, n)
            }
        }

        v && (t.__proto__ = v), (t.prototype = Object.create(v && v.prototype)).constructor = t;
        var e = {coordArrayType: {configurable: !0}};
        return e.coordArrayType.get = function () {
            return new Array(0).fill(null)
        }, t.prototype.getCoordinate = function (t) {
            return this.get(t)
        }, t.prototype.addAll = function () {
            if (2 !== arguments.length) return v.prototype.addAll.apply(this, arguments);
            for (var t = arguments[0], e = arguments[1], n = !1, r = t.iterator(); r.hasNext();) this.add(r.next(), e), n = !0;
            return n
        }, t.prototype.clone = function () {
            for (var t = v.prototype.clone.call(this), e = 0; e < this.size(); e++) t.add(e, this.get(e).copy());
            return t
        }, t.prototype.toCoordinateArray = function () {
            return this.toArray(t.coordArrayType)
        }, t.prototype.add = function () {
            if (1 === arguments.length) {
                var t = arguments[0];
                v.prototype.add.call(this, t)
            } else if (2 === arguments.length) {
                if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                    var e = arguments[0], n = arguments[1];
                    return this.add(e, n, !0), !0
                }
                if (arguments[0] instanceof pa && "boolean" == typeof arguments[1]) {
                    var r = arguments[0];
                    if (!arguments[1] && 1 <= this.size() && this.get(this.size() - 1).equals2D(r)) return null;
                    v.prototype.add.call(this, r)
                } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                    var i = arguments[0], o = arguments[1];
                    return this.add(i, o), !0
                }
            } else if (3 === arguments.length) {
                if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                    var s = arguments[0], a = arguments[1];
                    if (arguments[2]) for (var u = 0; u < s.length; u++) this.add(s[u], a); else for (var c = s.length - 1; 0 <= c; c--) this.add(s[c], a);
                    return !0
                }
                if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof pa) {
                    var h = arguments[0], l = arguments[1];
                    if (!arguments[2]) {
                        var p = this.size();
                        if (0 < p) {
                            if (0 < h && this.get(h - 1).equals2D(l)) return null;
                            if (h < p && this.get(h).equals2D(l)) return null
                        }
                    }
                    v.prototype.add.call(this, h, l)
                }
            } else if (4 === arguments.length) {
                var f = arguments[0], g = arguments[1], d = arguments[2], y = arguments[3], _ = 1;
                y < d && (_ = -1);
                for (var m = d; m !== y; m += _) this.add(f[m], g);
                return !0
            }
        }, t.prototype.closeRing = function () {
            0 < this.size() && this.add(new pa(this.get(0)), !1)
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, Object.defineProperties(t, e), t
    }(fu), yu = function () {
    }, _u = {
        ForwardComparator: {configurable: !0},
        BidirectionalComparator: {configurable: !0},
        coordArrayType: {configurable: !0}
    };
    _u.ForwardComparator.get = function () {
        return mu
    }, _u.BidirectionalComparator.get = function () {
        return vu
    }, _u.coordArrayType.get = function () {
        return new Array(0).fill(null)
    }, yu.prototype.interfaces_ = function () {
        return []
    }, yu.prototype.getClass = function () {
        return yu
    }, yu.isRing = function (t) {
        return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]))
    }, yu.ptNotInList = function (t, e) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            if (yu.indexOf(r, e) < 0) return r
        }
        return null
    }, yu.scroll = function (t, e) {
        var n = yu.indexOf(e, t);
        if (n < 0) return null;
        var r = new Array(t.length).fill(null);
        Ra.arraycopy(t, n, r, 0, t.length - n), Ra.arraycopy(t, 0, r, t.length - n, n), Ra.arraycopy(r, 0, t, 0, t.length)
    }, yu.equals = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            if (t === e) return !0;
            if (null === t || null === e) return !1;
            if (t.length !== e.length) return !1;
            for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;
            return !0
        }
        if (3 === arguments.length) {
            var r = arguments[0], i = arguments[1], o = arguments[2];
            if (r === i) return !0;
            if (null === r || null === i) return !1;
            if (r.length !== i.length) return !1;
            for (var s = 0; s < r.length; s++) if (0 !== o.compare(r[s], i[s])) return !1;
            return !0
        }
    }, yu.intersection = function (t, e) {
        for (var n = new du, r = 0; r < t.length; r++) e.intersects(t[r]) && n.add(t[r], !0);
        return n.toCoordinateArray()
    }, yu.hasRepeatedPoints = function (t) {
        for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;
        return !1
    }, yu.removeRepeatedPoints = function (t) {
        return yu.hasRepeatedPoints(t) ? new du(t, !1).toCoordinateArray() : t
    }, yu.reverse = function (t) {
        for (var e = t.length - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) {
            var i = t[r];
            t[r] = t[e - r], t[e - r] = i
        }
    }, yu.removeNull = function (t) {
        for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;
        var r = new Array(e).fill(null);
        if (0 === e) return r;
        for (var i = 0, o = 0; o < t.length; o++) null !== t[o] && (r[i++] = t[o]);
        return r
    }, yu.copyDeep = function () {
        if (1 === arguments.length) {
            for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = new pa(t[n]);
            return e
        }
        if (5 === arguments.length) for (var r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], u = 0; u < a; u++) o[s + u] = new pa(r[i + u])
    }, yu.isEqualReversed = function (t, e) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n], i = e[t.length - n - 1];
            if (0 !== r.compareTo(i)) return !1
        }
        return !0
    }, yu.envelope = function (t) {
        for (var e = new Aa, n = 0; n < t.length; n++) e.expandToInclude(t[n]);
        return e
    }, yu.toCoordinateArray = function (t) {
        return t.toArray(yu.coordArrayType)
    }, yu.atLeastNCoordinatesOrNothing = function (t, e) {
        return e.length >= t ? e : []
    }, yu.indexOf = function (t, e) {
        for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;
        return -1
    }, yu.increasingDirection = function (t) {
        for (var e = 0; e < Math.trunc(t.length / 2); e++) {
            var n = t.length - 1 - e, r = t[e].compareTo(t[n]);
            if (0 !== r) return r
        }
        return 1
    }, yu.compare = function (t, e) {
        for (var n = 0; n < t.length && n < e.length;) {
            var r = t[n].compareTo(e[n]);
            if (0 !== r) return r;
            n++
        }
        return n < e.length ? -1 : n < t.length ? 1 : 0
    }, yu.minCoordinate = function (t) {
        for (var e = null, n = 0; n < t.length; n++) (null === e || 0 < e.compareTo(t[n])) && (e = t[n]);
        return e
    }, yu.extract = function (t, e, n) {
        e = va.clamp(e, 0, t.length);
        var r = (n = va.clamp(n, -1, t.length)) - e + 1;
        n < 0 && (r = 0), e >= t.length && (r = 0), n < e && (r = 0);
        var i = new Array(r).fill(null);
        if (0 === r) return i;
        for (var o = 0, s = e; s <= n; s++) i[o++] = t[s];
        return i
    }, Object.defineProperties(yu, _u);
    var mu = function () {
    };
    mu.prototype.compare = function (t, e) {
        return yu.compare(t, e)
    }, mu.prototype.interfaces_ = function () {
        return [ha]
    }, mu.prototype.getClass = function () {
        return mu
    };
    var vu = function () {
    };
    vu.prototype.compare = function (t, e) {
        var n = t, r = e;
        if (n.length < r.length) return -1;
        if (n.length > r.length) return 1;
        if (0 === n.length) return 0;
        var i = yu.compare(n, r);
        return yu.isEqualReversed(n, r) ? 0 : i
    }, vu.prototype.OLDcompare = function (t, e) {
        var n = t, r = e;
        if (n.length < r.length) return -1;
        if (n.length > r.length) return 1;
        if (0 === n.length) return 0;
        for (var i = yu.increasingDirection(n), o = yu.increasingDirection(r), s = 0 < i ? 0 : n.length - 1, a = 0 < o ? 0 : n.length - 1, u = 0; u < n.length; u++) {
            var c = n[s].compareTo(r[a]);
            if (0 !== c) return c;
            s += i, a += o
        }
        return 0
    }, vu.prototype.interfaces_ = function () {
        return [ha]
    }, vu.prototype.getClass = function () {
        return vu
    };
    var xu = function () {
    };
    xu.prototype.get = function () {
    }, xu.prototype.put = function () {
    }, xu.prototype.size = function () {
    }, xu.prototype.values = function () {
    }, xu.prototype.entrySet = function () {
    };
    var Eu = function (t) {
        function e() {
            t.apply(this, arguments)
        }

        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e
    }(xu);

    function wu(t) {
        this.message = t || ""
    }

    function bu() {
    }

    (wu.prototype = new Error).name = "OperationNotSupported", (bu.prototype = new uu).contains = function () {
    };
    var Iu = function (t) {
        function e() {
            t.call(this), this.array_ = [], arguments[0] instanceof uu && this.addAll(arguments[0])
        }

        return t && (e.__proto__ = t), ((e.prototype = Object.create(t && t.prototype)).constructor = e).prototype.contains = function (t) {
            for (var e = 0, n = this.array_.length; e < n; e++) if (this.array_[e] === t) return !0;
            return !1
        }, e.prototype.add = function (t) {
            return !this.contains(t) && (this.array_.push(t), !0)
        }, e.prototype.addAll = function (t) {
            for (var e = t.iterator(); e.hasNext();) this.add(e.next());
            return !0
        }, e.prototype.remove = function (t) {
            throw new Error
        }, e.prototype.size = function () {
            return this.array_.length
        }, e.prototype.isEmpty = function () {
            return 0 === this.array_.length
        }, e.prototype.toArray = function () {
            for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
            return t
        }, e.prototype.iterator = function () {
            return new Nu(this)
        }, e
    }(bu), Nu = function (e) {
        function t(t) {
            e.call(this), this.hashSet_ = t, this.position_ = 0
        }

        return e && (t.__proto__ = e), ((t.prototype = Object.create(e && e.prototype)).constructor = t).prototype.next = function () {
            if (this.position_ === this.hashSet_.size()) throw new pu;
            return this.hashSet_.array_[this.position_++]
        }, t.prototype.hasNext = function () {
            return this.position_ < this.hashSet_.size()
        }, t.prototype.remove = function () {
            throw new wu
        }, t
    }(hu), Cu = 0;

    function Su(t) {
        return null === t ? Cu : t.color
    }

    function Mu(t) {
        return null === t ? null : t.parent
    }

    function Lu(t, e) {
        null !== t && (t.color = e)
    }

    function Pu(t) {
        return null === t ? null : t.left
    }

    function Ou(t) {
        return null === t ? null : t.right
    }

    function Ru() {
        this.root_ = null, this.size_ = 0
    }

    (Ru.prototype = new Eu).get = function (t) {
        for (var e = this.root_; null !== e;) {
            var n = t.compareTo(e.key);
            if (n < 0) e = e.left; else {
                if (!(0 < n)) return e.value;
                e = e.right
            }
        }
        return null
    }, Ru.prototype.put = function (t, e) {
        if (null === this.root_) return this.root_ = {
            key: t,
            value: e,
            left: null,
            right: null,
            parent: null,
            color: Cu,
            getValue: function () {
                return this.value
            },
            getKey: function () {
                return this.key
            }
        }, this.size_ = 1, null;
        var n, r, i = this.root_;
        do {
            if (n = i, (r = t.compareTo(i.key)) < 0) i = i.left; else {
                if (!(0 < r)) {
                    var o = i.value;
                    return i.value = e, o
                }
                i = i.right
            }
        } while (null !== i);
        var s = {
            key: t, left: null, right: null, value: e, parent: n, color: Cu, getValue: function () {
                return this.value
            }, getKey: function () {
                return this.key
            }
        };
        return r < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null
    }, Ru.prototype.fixAfterInsertion = function (t) {
        for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) if (Mu(t) === Pu(Mu(Mu(t)))) {
            var e = Ou(Mu(Mu(t)));
            1 === Su(e) ? (Lu(Mu(t), Cu), Lu(e, Cu), Lu(Mu(Mu(t)), 1), t = Mu(Mu(t))) : (t === Ou(Mu(t)) && (t = Mu(t), this.rotateLeft(t)), Lu(Mu(t), Cu), Lu(Mu(Mu(t)), 1), this.rotateRight(Mu(Mu(t))))
        } else {
            var n = Pu(Mu(Mu(t)));
            1 === Su(n) ? (Lu(Mu(t), Cu), Lu(n, Cu), Lu(Mu(Mu(t)), 1), t = Mu(Mu(t))) : (t === Pu(Mu(t)) && (t = Mu(t), this.rotateRight(t)), Lu(Mu(t), Cu), Lu(Mu(Mu(t)), 1), this.rotateLeft(Mu(Mu(t))))
        }
        this.root_.color = Cu
    }, Ru.prototype.values = function () {
        var t = new fu, e = this.getFirstEntry();
        if (null !== e) for (t.add(e.value); null !== (e = Ru.successor(e));) t.add(e.value);
        return t
    }, Ru.prototype.entrySet = function () {
        var t = new Iu, e = this.getFirstEntry();
        if (null !== e) for (t.add(e); null !== (e = Ru.successor(e));) t.add(e);
        return t
    }, Ru.prototype.rotateLeft = function (t) {
        if (null != t) {
            var e = t.right;
            t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, (e.left = t).parent = e
        }
    }, Ru.prototype.rotateRight = function (t) {
        if (null != t) {
            var e = t.left;
            t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, (e.right = t).parent = e
        }
    }, Ru.prototype.getFirstEntry = function () {
        var t = this.root_;
        if (null != t) for (; null != t.left;) t = t.left;
        return t
    }, Ru.successor = function (t) {
        if (null === t) return null;
        if (null !== t.right) {
            for (var e = t.right; null !== e.left;) e = e.left;
            return e
        }
        for (var n = t.parent, r = t; null !== n && r === n.right;) n = (r = n).parent;
        return n
    }, Ru.prototype.size = function () {
        return this.size_
    };
    var Tu = function () {
    };

    function Au() {
    }

    function Du() {
        this.array_ = [], arguments[0] instanceof uu && this.addAll(arguments[0])
    }

    Tu.prototype.interfaces_ = function () {
        return []
    }, Tu.prototype.getClass = function () {
        return Tu
    }, Au.prototype = new bu, (Du.prototype = new Au).contains = function (t) {
        for (var e = 0, n = this.array_.length; e < n; e++) if (0 === this.array_[e].compareTo(t)) return !0;
        return !1
    }, Du.prototype.add = function (t) {
        if (this.contains(t)) return !1;
        for (var e = 0, n = this.array_.length; e < n; e++) if (1 === this.array_[e].compareTo(t)) return this.array_.splice(e, 0, t), !0;
        return this.array_.push(t), !0
    }, Du.prototype.addAll = function (t) {
        for (var e = t.iterator(); e.hasNext();) this.add(e.next());
        return !0
    }, Du.prototype.remove = function (t) {
        throw new wu
    }, Du.prototype.size = function () {
        return this.array_.length
    }, Du.prototype.isEmpty = function () {
        return 0 === this.array_.length
    }, Du.prototype.toArray = function () {
        for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
        return t
    }, Du.prototype.iterator = function () {
        return new Fu(this)
    };
    var Fu = function (t) {
        this.treeSet_ = t, this.position_ = 0
    };
    Fu.prototype.next = function () {
        if (this.position_ === this.treeSet_.size()) throw new pu;
        return this.treeSet_.array_[this.position_++]
    }, Fu.prototype.hasNext = function () {
        return this.position_ < this.treeSet_.size()
    }, Fu.prototype.remove = function () {
        throw new wu
    };
    var qu = function () {
    };
    qu.sort = function () {
        var t, e, n, r, i = arguments[0];
        if (1 === arguments.length) r = function (t, e) {
            return t.compareTo(e)
        }, i.sort(r); else if (2 === arguments.length) n = arguments[1], r = function (t, e) {
            return n.compare(t, e)
        }, i.sort(r); else if (3 === arguments.length) {
            (e = i.slice(arguments[1], arguments[2])).sort();
            var o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length));
            for (i.splice(0, i.length), t = 0; t < o.length; t++) i.push(o[t])
        } else if (4 === arguments.length) for (e = i.slice(arguments[1], arguments[2]), n = arguments[3], r = function (t, e) {
            return n.compare(t, e)
        }, e.sort(r), o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length)), i.splice(0, i.length), t = 0; t < o.length; t++) i.push(o[t])
    }, qu.asList = function (t) {
        for (var e = new fu, n = 0, r = t.length; n < r; n++) e.add(t[n]);
        return e
    };
    var Gu = function () {
    }, Bu = {
        P: {configurable: !0},
        L: {configurable: !0},
        A: {configurable: !0},
        FALSE: {configurable: !0},
        TRUE: {configurable: !0},
        DONTCARE: {configurable: !0},
        SYM_FALSE: {configurable: !0},
        SYM_TRUE: {configurable: !0},
        SYM_DONTCARE: {configurable: !0},
        SYM_P: {configurable: !0},
        SYM_L: {configurable: !0},
        SYM_A: {configurable: !0}
    };
    Bu.P.get = function () {
        return 0
    }, Bu.L.get = function () {
        return 1
    }, Bu.A.get = function () {
        return 2
    }, Bu.FALSE.get = function () {
        return -1
    }, Bu.TRUE.get = function () {
        return -2
    }, Bu.DONTCARE.get = function () {
        return -3
    }, Bu.SYM_FALSE.get = function () {
        return "F"
    }, Bu.SYM_TRUE.get = function () {
        return "T"
    }, Bu.SYM_DONTCARE.get = function () {
        return "*"
    }, Bu.SYM_P.get = function () {
        return "0"
    }, Bu.SYM_L.get = function () {
        return "1"
    }, Bu.SYM_A.get = function () {
        return "2"
    }, Gu.prototype.interfaces_ = function () {
        return []
    }, Gu.prototype.getClass = function () {
        return Gu
    }, Gu.toDimensionSymbol = function (t) {
        switch (t) {
            case Gu.FALSE:
                return Gu.SYM_FALSE;
            case Gu.TRUE:
                return Gu.SYM_TRUE;
            case Gu.DONTCARE:
                return Gu.SYM_DONTCARE;
            case Gu.P:
                return Gu.SYM_P;
            case Gu.L:
                return Gu.SYM_L;
            case Gu.A:
                return Gu.SYM_A
        }
        throw new oa("Unknown dimension value: " + t)
    }, Gu.toDimensionValue = function (t) {
        switch (ba.toUpperCase(t)) {
            case Gu.SYM_FALSE:
                return Gu.FALSE;
            case Gu.SYM_TRUE:
                return Gu.TRUE;
            case Gu.SYM_DONTCARE:
                return Gu.DONTCARE;
            case Gu.SYM_P:
                return Gu.P;
            case Gu.SYM_L:
                return Gu.L;
            case Gu.SYM_A:
                return Gu.A
        }
        throw new oa("Unknown dimension symbol: " + t)
    }, Object.defineProperties(Gu, Bu);
    var ku = function () {
    };
    ku.prototype.filter = function (t) {
    }, ku.prototype.interfaces_ = function () {
        return []
    }, ku.prototype.getClass = function () {
        return ku
    };
    var zu = function () {
    };
    zu.prototype.filter = function (t, e) {
    }, zu.prototype.isDone = function () {
    }, zu.prototype.isGeometryChanged = function () {
    }, zu.prototype.interfaces_ = function () {
        return []
    }, zu.prototype.getClass = function () {
        return zu
    };
    var ju = function (i) {
        function n(t, e) {
            if (i.call(this, e), this._geometries = t || [], i.hasNullElements(this._geometries)) throw new oa("geometries must not contain null elements")
        }

        i && (n.__proto__ = i);
        var t = {serialVersionUID: {configurable: !0}};
        return ((n.prototype = Object.create(i && i.prototype)).constructor = n).prototype.computeEnvelopeInternal = function () {
            for (var t = new Aa, e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());
            return t
        }, n.prototype.getGeometryN = function (t) {
            return this._geometries[t]
        }, n.prototype.getSortIndex = function () {
            return i.SORTINDEX_GEOMETRYCOLLECTION
        }, n.prototype.getCoordinates = function () {
            for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (var r = this._geometries[n].getCoordinates(), i = 0; i < r.length; i++) t[++e] = r[i];
            return t
        }, n.prototype.getArea = function () {
            for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();
            return t
        }, n.prototype.equalsExact = function () {
            if (2 !== arguments.length) return i.prototype.equalsExact.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            if (!this.isEquivalentClass(t)) return !1;
            var n = t;
            if (this._geometries.length !== n._geometries.length) return !1;
            for (var r = 0; r < this._geometries.length; r++) if (!this._geometries[r].equalsExact(n._geometries[r], e)) return !1;
            return !0
        }, n.prototype.normalize = function () {
            for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();
            qu.sort(this._geometries)
        }, n.prototype.getCoordinate = function () {
            return this.isEmpty() ? null : this._geometries[0].getCoordinate()
        }, n.prototype.getBoundaryDimension = function () {
            for (var t = Gu.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());
            return t
        }, n.prototype.getDimension = function () {
            for (var t = Gu.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());
            return t
        }, n.prototype.getLength = function () {
            for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();
            return t
        }, n.prototype.getNumPoints = function () {
            for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();
            return t
        }, n.prototype.getNumGeometries = function () {
            return this._geometries.length
        }, n.prototype.reverse = function () {
            for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();
            return this.getFactory().createGeometryCollection(e)
        }, n.prototype.compareToSameClass = function () {
            if (1 === arguments.length) {
                var t = arguments[0], e = new Du(qu.asList(this._geometries)), n = new Du(qu.asList(t._geometries));
                return this.compare(e, n)
            }
            if (2 === arguments.length) {
                for (var r = arguments[0], i = arguments[1], o = r, s = this.getNumGeometries(), a = o.getNumGeometries(), u = 0; u < s && u < a;) {
                    var c = this.getGeometryN(u), h = o.getGeometryN(u), l = c.compareToSameClass(h, i);
                    if (0 !== l) return l;
                    u++
                }
                return u < s ? 1 : u < a ? -1 : 0
            }
        }, n.prototype.apply = function () {
            if (ma(arguments[0], eu)) for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t); else if (ma(arguments[0], zu)) {
                var n = arguments[0];
                if (0 === this._geometries.length) return null;
                for (var r = 0; r < this._geometries.length && (this._geometries[r].apply(n), !n.isDone()); r++) ;
                n.isGeometryChanged() && this.geometryChanged()
            } else if (ma(arguments[0], ku)) {
                var i = arguments[0];
                i.filter(this);
                for (var o = 0; o < this._geometries.length; o++) this._geometries[o].apply(i)
            } else if (ma(arguments[0], Ka)) {
                var s = arguments[0];
                s.filter(this);
                for (var a = 0; a < this._geometries.length; a++) this._geometries[a].apply(s)
            }
        }, n.prototype.getBoundary = function () {
            return this.checkNotGeometryCollection(this), Xa.shouldNeverReachHere(), null
        }, n.prototype.clone = function () {
            var t = i.prototype.clone.call(this);
            t._geometries = new Array(this._geometries.length).fill(null);
            for (var e = 0; e < this._geometries.length; e++) t._geometries[e] = this._geometries[e].clone();
            return t
        }, n.prototype.getGeometryType = function () {
            return "GeometryCollection"
        }, n.prototype.copy = function () {
            for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
            return new n(t, this._factory)
        }, n.prototype.isEmpty = function () {
            for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;
            return !0
        }, n.prototype.interfaces_ = function () {
            return []
        }, n.prototype.getClass = function () {
            return n
        }, t.serialVersionUID.get = function () {
            return -0x4f07bcb1f857d800
        }, Object.defineProperties(n, t), n
    }(Qa), Xu = function (n) {
        function r() {
            n.apply(this, arguments)
        }

        n && (r.__proto__ = n);
        var t = {serialVersionUID: {configurable: !0}};
        return ((r.prototype = Object.create(n && n.prototype)).constructor = r).prototype.getSortIndex = function () {
            return Qa.SORTINDEX_MULTILINESTRING
        }, r.prototype.equalsExact = function () {
            if (2 !== arguments.length) return n.prototype.equalsExact.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            return !!this.isEquivalentClass(t) && n.prototype.equalsExact.call(this, t, e)
        }, r.prototype.getBoundaryDimension = function () {
            return this.isClosed() ? Gu.FALSE : 0
        }, r.prototype.isClosed = function () {
            if (this.isEmpty()) return !1;
            for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;
            return !0
        }, r.prototype.getDimension = function () {
            return 1
        }, r.prototype.reverse = function () {
            for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[t - 1 - n] = this._geometries[n].reverse();
            return this.getFactory().createMultiLineString(e)
        }, r.prototype.getBoundary = function () {
            return new Uu(this).getBoundary()
        }, r.prototype.getGeometryType = function () {
            return "MultiLineString"
        }, r.prototype.copy = function () {
            for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
            return new r(t, this._factory)
        }, r.prototype.interfaces_ = function () {
            return [Tu]
        }, r.prototype.getClass = function () {
            return r
        }, t.serialVersionUID.get = function () {
            return 0x7155d2ab4afa8000
        }, Object.defineProperties(r, t), r
    }(ju), Uu = function () {
        if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
            var t = arguments[0], e = nu.MOD2_BOUNDARY_RULE;
            this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            this._geom = n, this._geomFact = n.getFactory(), this._bnRule = r
        }
    };
    Uu.prototype.boundaryMultiLineString = function (t) {
        if (this._geom.isEmpty()) return this.getEmptyMultiPoint();
        var e = this.computeBoundaryCoordinates(t);
        return 1 === e.length ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e)
    }, Uu.prototype.getBoundary = function () {
        return this._geom instanceof ec ? this.boundaryLineString(this._geom) : this._geom instanceof Xu ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary()
    }, Uu.prototype.boundaryLineString = function (t) {
        return this._geom.isEmpty() ? this.getEmptyMultiPoint() : t.isClosed() ? this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint() : this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
    }, Uu.prototype.getEmptyMultiPoint = function () {
        return this._geomFact.createMultiPoint()
    }, Uu.prototype.computeBoundaryCoordinates = function (t) {
        var e = new fu;
        this._endpointMap = new Ru;
        for (var n = 0; n < t.getNumGeometries(); n++) {
            var r = t.getGeometryN(n);
            0 !== r.getNumPoints() && (this.addEndpoint(r.getCoordinateN(0)), this.addEndpoint(r.getCoordinateN(r.getNumPoints() - 1)))
        }
        for (var i = this._endpointMap.entrySet().iterator(); i.hasNext();) {
            var o = i.next(), s = o.getValue().count;
            this._bnRule.isInBoundary(s) && e.add(o.getKey())
        }
        return yu.toCoordinateArray(e)
    }, Uu.prototype.addEndpoint = function (t) {
        var e = this._endpointMap.get(t);
        null === e && (e = new Yu, this._endpointMap.put(t, e)), e.count++
    }, Uu.prototype.interfaces_ = function () {
        return []
    }, Uu.prototype.getClass = function () {
        return Uu
    }, Uu.getBoundary = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return new Uu(t).getBoundary()
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return new Uu(e, n).getBoundary()
        }
    };
    var Yu = function () {
        this.count = null
    };

    function Vu() {
    }

    function Hu() {
    }

    Yu.prototype.interfaces_ = function () {
        return []
    }, Yu.prototype.getClass = function () {
        return Yu
    };
    var Wu = function () {
    };

    function Ju() {
    }

    function Zu() {
    }

    function Ku() {
    }

    var Qu = function () {
    }, $u = {NEWLINE: {configurable: !0}, SIMPLE_ORDINATE_FORMAT: {configurable: !0}};
    Qu.prototype.interfaces_ = function () {
        return []
    }, Qu.prototype.getClass = function () {
        return Qu
    }, Qu.chars = function (t, e) {
        for (var n = new Array(e).fill(null), r = 0; r < e; r++) n[r] = t;
        return String(n)
    }, Qu.getStackTrace = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = new Ju, n = new Vu(e);
            return t.printStackTrace(n), e.toString()
        }
        if (2 === arguments.length) {
            for (var r = arguments[0], i = arguments[1], o = "", s = new Ku(new Hu(Qu.getStackTrace(r))), a = 0; a < i; a++) try {
                o += s.readLine() + Qu.NEWLINE
            } catch (t) {
                if (!(t instanceof Zu)) throw t;
                Xa.shouldNeverReachHere()
            }
            return o
        }
    }, Qu.split = function (t, e) {
        for (var n = e.length, r = new fu, i = "" + t, o = i.indexOf(e); 0 <= o;) {
            var s = i.substring(0, o);
            r.add(s), o = (i = i.substring(o + n)).indexOf(e)
        }
        0 < i.length && r.add(i);
        for (var a = new Array(r.size()).fill(null), u = 0; u < a.length; u++) a[u] = r.get(u);
        return a
    }, Qu.toString = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return Qu.SIMPLE_ORDINATE_FORMAT.format(t)
        }
    }, Qu.spaces = function (t) {
        return Qu.chars(" ", t)
    }, $u.NEWLINE.get = function () {
        return Ra.getProperty("line.separator")
    }, $u.SIMPLE_ORDINATE_FORMAT.get = function () {
        return new Wu("0.#")
    }, Object.defineProperties(Qu, $u);
    var tc = function () {
    };
    tc.prototype.interfaces_ = function () {
        return []
    }, tc.prototype.getClass = function () {
        return tc
    }, tc.copyCoord = function (t, e, n, r) {
        for (var i = Math.min(t.getDimension(), n.getDimension()), o = 0; o < i; o++) n.setOrdinate(r, o, t.getOrdinate(e, o))
    }, tc.isRing = function (t) {
        var e = t.size();
        return 0 === e || !(e <= 3) && t.getOrdinate(0, Ma.X) === t.getOrdinate(e - 1, Ma.X) && t.getOrdinate(0, Ma.Y) === t.getOrdinate(e - 1, Ma.Y)
    }, tc.isEqual = function (t, e) {
        var n = t.size();
        if (n !== e.size()) return !1;
        for (var r = Math.min(t.getDimension(), e.getDimension()), i = 0; i < n; i++) for (var o = 0; o < r; o++) {
            var s = t.getOrdinate(i, o), a = e.getOrdinate(i, o);
            if (!(t.getOrdinate(i, o) === e.getOrdinate(i, o) || sa.isNaN(s) && sa.isNaN(a))) return !1
        }
        return !0
    }, tc.extend = function (t, e, n) {
        var r = t.create(n, e.getDimension()), i = e.size();
        if (tc.copy(e, 0, r, 0, i), 0 < i) for (var o = i; o < n; o++) tc.copy(e, i - 1, r, o, 1);
        return r
    }, tc.reverse = function (t) {
        for (var e = t.size() - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) tc.swap(t, r, e - r)
    }, tc.swap = function (t, e, n) {
        if (e === n) return null;
        for (var r = 0; r < t.getDimension(); r++) {
            var i = t.getOrdinate(e, r);
            t.setOrdinate(e, r, t.getOrdinate(n, r)), t.setOrdinate(n, r, i)
        }
    }, tc.copy = function (t, e, n, r, i) {
        for (var o = 0; o < i; o++) tc.copyCoord(t, e + o, n, r + o)
    }, tc.toString = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = t.size();
            if (0 === e) return "()";
            var n = t.getDimension(), r = new Ea;
            r.append("(");
            for (var i = 0; i < e; i++) {
                0 < i && r.append(" ");
                for (var o = 0; o < n; o++) 0 < o && r.append(","), r.append(Qu.toString(t.getOrdinate(i, o)))
            }
            return r.append(")"), r.toString()
        }
    }, tc.ensureValidRing = function (t, e) {
        var n = e.size();
        return 0 === n ? e : n <= 3 ? tc.createClosedRing(t, e, 4) : e.getOrdinate(0, Ma.X) === e.getOrdinate(n - 1, Ma.X) && e.getOrdinate(0, Ma.Y) === e.getOrdinate(n - 1, Ma.Y) ? e : tc.createClosedRing(t, e, n + 1)
    }, tc.createClosedRing = function (t, e, n) {
        var r = t.create(n, e.getDimension()), i = e.size();
        tc.copy(e, 0, r, 0, i);
        for (var o = i; o < n; o++) tc.copy(e, 0, r, o, 1);
        return r
    };
    var ec = function (i) {
        function e(t, e) {
            i.call(this, e), this._points = null, this.init(t)
        }

        i && (e.__proto__ = i);
        var t = {serialVersionUID: {configurable: !0}};
        return ((e.prototype = Object.create(i && i.prototype)).constructor = e).prototype.computeEnvelopeInternal = function () {
            return this.isEmpty() ? new Aa : this._points.expandEnvelope(new Aa)
        }, e.prototype.isRing = function () {
            return this.isClosed() && this.isSimple()
        }, e.prototype.getSortIndex = function () {
            return i.SORTINDEX_LINESTRING
        }, e.prototype.getCoordinates = function () {
            return this._points.toCoordinateArray()
        }, e.prototype.equalsExact = function () {
            if (2 !== arguments.length) return i.prototype.equalsExact.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            if (!this.isEquivalentClass(t)) return !1;
            var n = t;
            if (this._points.size() !== n._points.size()) return !1;
            for (var r = 0; r < this._points.size(); r++) if (!this.equal(this._points.getCoordinate(r), n._points.getCoordinate(r), e)) return !1;
            return !0
        }, e.prototype.normalize = function () {
            for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {
                var e = this._points.size() - 1 - t;
                if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) return 0 < this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) && tc.reverse(this._points), null
            }
        }, e.prototype.getCoordinate = function () {
            return this.isEmpty() ? null : this._points.getCoordinate(0)
        }, e.prototype.getBoundaryDimension = function () {
            return this.isClosed() ? Gu.FALSE : 0
        }, e.prototype.isClosed = function () {
            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
        }, e.prototype.getEndPoint = function () {
            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
        }, e.prototype.getDimension = function () {
            return 1
        }, e.prototype.getLength = function () {
            return Ja.computeLength(this._points)
        }, e.prototype.getNumPoints = function () {
            return this._points.size()
        }, e.prototype.reverse = function () {
            var t = this._points.copy();
            return tc.reverse(t), this.getFactory().createLineString(t)
        }, e.prototype.compareToSameClass = function () {
            if (1 === arguments.length) {
                for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) {
                    var r = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));
                    if (0 !== r) return r;
                    e++, n++
                }
                return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0
            }
            if (2 === arguments.length) {
                var i = arguments[0];
                return arguments[1].compare(this._points, i._points)
            }
        }, e.prototype.apply = function () {
            if (ma(arguments[0], eu)) for (var t = arguments[0], e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e)); else if (ma(arguments[0], zu)) {
                var n = arguments[0];
                if (0 === this._points.size()) return null;
                for (var r = 0; r < this._points.size() && (n.filter(this._points, r), !n.isDone()); r++) ;
                n.isGeometryChanged() && this.geometryChanged()
            } else ma(arguments[0], ku) ? arguments[0].filter(this) : ma(arguments[0], Ka) && arguments[0].filter(this)
        }, e.prototype.getBoundary = function () {
            return new Uu(this).getBoundary()
        }, e.prototype.isEquivalentClass = function (t) {
            return t instanceof e
        }, e.prototype.clone = function () {
            var t = i.prototype.clone.call(this);
            return t._points = this._points.clone(), t
        }, e.prototype.getCoordinateN = function (t) {
            return this._points.getCoordinate(t)
        }, e.prototype.getGeometryType = function () {
            return "LineString"
        }, e.prototype.copy = function () {
            return new e(this._points.copy(), this._factory)
        }, e.prototype.getCoordinateSequence = function () {
            return this._points
        }, e.prototype.isEmpty = function () {
            return 0 === this._points.size()
        }, e.prototype.init = function (t) {
            if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new oa("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
            this._points = t
        }, e.prototype.isCoordinate = function (t) {
            for (var e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;
            return !1
        }, e.prototype.getStartPoint = function () {
            return this.isEmpty() ? null : this.getPointN(0)
        }, e.prototype.getPointN = function (t) {
            return this.getFactory().createPoint(this._points.getCoordinate(t))
        }, e.prototype.interfaces_ = function () {
            return [Tu]
        }, e.prototype.getClass = function () {
            return e
        }, t.serialVersionUID.get = function () {
            return 0x2b2b51ba435c8e00
        }, Object.defineProperties(e, t), e
    }(Qa), nc = function () {
    };
    nc.prototype.interfaces_ = function () {
        return []
    }, nc.prototype.getClass = function () {
        return nc
    };
    var rc = function (n) {
        function t(t, e) {
            n.call(this, e), this._coordinates = t || null, this.init(this._coordinates)
        }

        n && (t.__proto__ = n);
        var e = {serialVersionUID: {configurable: !0}};
        return ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.computeEnvelopeInternal = function () {
            if (this.isEmpty()) return new Aa;
            var t = new Aa;
            return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t
        }, t.prototype.getSortIndex = function () {
            return n.SORTINDEX_POINT
        }, t.prototype.getCoordinates = function () {
            return this.isEmpty() ? [] : [this.getCoordinate()]
        }, t.prototype.equalsExact = function () {
            if (2 !== arguments.length) return n.prototype.equalsExact.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e))
        }, t.prototype.normalize = function () {
        }, t.prototype.getCoordinate = function () {
            return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null
        }, t.prototype.getBoundaryDimension = function () {
            return Gu.FALSE
        }, t.prototype.getDimension = function () {
            return 0
        }, t.prototype.getNumPoints = function () {
            return this.isEmpty() ? 0 : 1
        }, t.prototype.reverse = function () {
            return this.copy()
        }, t.prototype.getX = function () {
            if (null === this.getCoordinate()) throw new Error("getX called on empty Point");
            return this.getCoordinate().x
        }, t.prototype.compareToSameClass = function () {
            if (1 === arguments.length) {
                var t = arguments[0];
                return this.getCoordinate().compareTo(t.getCoordinate())
            }
            if (2 === arguments.length) {
                var e = arguments[0];
                return arguments[1].compare(this._coordinates, e._coordinates)
            }
        }, t.prototype.apply = function () {
            if (ma(arguments[0], eu)) {
                var t = arguments[0];
                if (this.isEmpty()) return null;
                t.filter(this.getCoordinate())
            } else if (ma(arguments[0], zu)) {
                var e = arguments[0];
                if (this.isEmpty()) return null;
                e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged()
            } else ma(arguments[0], ku) ? arguments[0].filter(this) : ma(arguments[0], Ka) && arguments[0].filter(this)
        }, t.prototype.getBoundary = function () {
            return this.getFactory().createGeometryCollection(null)
        }, t.prototype.clone = function () {
            var t = n.prototype.clone.call(this);
            return t._coordinates = this._coordinates.clone(), t
        }, t.prototype.getGeometryType = function () {
            return "Point"
        }, t.prototype.copy = function () {
            return new t(this._coordinates.copy(), this._factory)
        }, t.prototype.getCoordinateSequence = function () {
            return this._coordinates
        }, t.prototype.getY = function () {
            if (null === this.getCoordinate()) throw new Error("getY called on empty Point");
            return this.getCoordinate().y
        }, t.prototype.isEmpty = function () {
            return 0 === this._coordinates.size()
        }, t.prototype.init = function (t) {
            null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), Xa.isTrue(t.size() <= 1), this._coordinates = t
        }, t.prototype.isSimple = function () {
            return !0
        }, t.prototype.interfaces_ = function () {
            return [nc]
        }, t.prototype.getClass = function () {
            return t
        }, e.serialVersionUID.get = function () {
            return 0x44077bad161cbc00
        }, Object.defineProperties(t, e), t
    }(Qa), ic = function () {
    };
    ic.prototype.interfaces_ = function () {
        return []
    }, ic.prototype.getClass = function () {
        return ic
    };
    var oc = function (s) {
        function r(t, e, n) {
            if (s.call(this, n), this._shell = null, (this._holes = null) === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), s.hasNullElements(e)) throw new oa("holes must not contain null elements");
            if (t.isEmpty() && s.hasNonEmptyElements(e)) throw new oa("shell is empty but holes are not");
            this._shell = t, this._holes = e
        }

        s && (r.__proto__ = s);
        var t = {serialVersionUID: {configurable: !0}};
        return ((r.prototype = Object.create(s && s.prototype)).constructor = r).prototype.computeEnvelopeInternal = function () {
            return this._shell.getEnvelopeInternal()
        }, r.prototype.getSortIndex = function () {
            return s.SORTINDEX_POLYGON
        }, r.prototype.getCoordinates = function () {
            if (this.isEmpty()) return [];
            for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), r = 0; r < n.length; r++) t[++e] = n[r];
            for (var i = 0; i < this._holes.length; i++) for (var o = this._holes[i].getCoordinates(), s = 0; s < o.length; s++) t[++e] = o[s];
            return t
        }, r.prototype.getArea = function () {
            var t = 0;
            t += Math.abs(Ja.signedArea(this._shell.getCoordinateSequence()));
            for (var e = 0; e < this._holes.length; e++) t -= Math.abs(Ja.signedArea(this._holes[e].getCoordinateSequence()));
            return t
        }, r.prototype.isRectangle = function () {
            if (0 !== this.getNumInteriorRing()) return !1;
            if (null === this._shell) return !1;
            if (5 !== this._shell.getNumPoints()) return !1;
            for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
                var r = t.getX(n);
                if (r !== e.getMinX() && r !== e.getMaxX()) return !1;
                var i = t.getY(n);
                if (i !== e.getMinY() && i !== e.getMaxY()) return !1
            }
            for (var o = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) {
                var u = t.getX(a), c = t.getY(a);
                if (u !== o == (c !== s)) return !1;
                o = u, s = c
            }
            return !0
        }, r.prototype.equalsExact = function () {
            if (2 !== arguments.length) return s.prototype.equalsExact.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            if (!this.isEquivalentClass(t)) return !1;
            var n = t, r = this._shell, i = n._shell;
            if (!r.equalsExact(i, e)) return !1;
            if (this._holes.length !== n._holes.length) return !1;
            for (var o = 0; o < this._holes.length; o++) if (!this._holes[o].equalsExact(n._holes[o], e)) return !1;
            return !0
        }, r.prototype.normalize = function () {
            if (0 === arguments.length) {
                this.normalize(this._shell, !0);
                for (var t = 0; t < this._holes.length; t++) this.normalize(this._holes[t], !1);
                qu.sort(this._holes)
            } else if (2 === arguments.length) {
                var e = arguments[0], n = arguments[1];
                if (e.isEmpty()) return null;
                var r = new Array(e.getCoordinates().length - 1).fill(null);
                Ra.arraycopy(e.getCoordinates(), 0, r, 0, r.length);
                var i = yu.minCoordinate(e.getCoordinates());
                yu.scroll(r, i), Ra.arraycopy(r, 0, e.getCoordinates(), 0, r.length), e.getCoordinates()[r.length] = r[0], Ja.isCCW(e.getCoordinates()) === n && yu.reverse(e.getCoordinates())
            }
        }, r.prototype.getCoordinate = function () {
            return this._shell.getCoordinate()
        }, r.prototype.getNumInteriorRing = function () {
            return this._holes.length
        }, r.prototype.getBoundaryDimension = function () {
            return 1
        }, r.prototype.getDimension = function () {
            return 2
        }, r.prototype.getLength = function () {
            var t = 0;
            t += this._shell.getLength();
            for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();
            return t
        }, r.prototype.getNumPoints = function () {
            for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();
            return t
        }, r.prototype.reverse = function () {
            var t = this.copy();
            t._shell = this._shell.copy().reverse(), t._holes = new Array(this._holes.length).fill(null);
            for (var e = 0; e < this._holes.length; e++) t._holes[e] = this._holes[e].copy().reverse();
            return t
        }, r.prototype.convexHull = function () {
            return this.getExteriorRing().convexHull()
        }, r.prototype.compareToSameClass = function () {
            if (1 === arguments.length) {
                var t = arguments[0], e = this._shell, n = t._shell;
                return e.compareToSameClass(n)
            }
            if (2 === arguments.length) {
                var r = arguments[0], i = arguments[1], o = r, s = this._shell, a = o._shell,
                    u = s.compareToSameClass(a, i);
                if (0 !== u) return u;
                for (var c = this.getNumInteriorRing(), h = o.getNumInteriorRing(), l = 0; l < c && l < h;) {
                    var p = this.getInteriorRingN(l), f = o.getInteriorRingN(l), g = p.compareToSameClass(f, i);
                    if (0 !== g) return g;
                    l++
                }
                return l < c ? 1 : l < h ? -1 : 0
            }
        }, r.prototype.apply = function (t) {
            if (ma(t, eu)) {
                this._shell.apply(t);
                for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t)
            } else if (ma(t, zu)) {
                if (this._shell.apply(t), !t.isDone()) for (var n = 0; n < this._holes.length && (this._holes[n].apply(t), !t.isDone()); n++) ;
                t.isGeometryChanged() && this.geometryChanged()
            } else if (ma(t, ku)) t.filter(this); else if (ma(t, Ka)) {
                t.filter(this), this._shell.apply(t);
                for (var r = 0; r < this._holes.length; r++) this._holes[r].apply(t)
            }
        }, r.prototype.getBoundary = function () {
            if (this.isEmpty()) return this.getFactory().createMultiLineString();
            var t = new Array(this._holes.length + 1).fill(null);
            t[0] = this._shell;
            for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];
            return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
        }, r.prototype.clone = function () {
            var t = s.prototype.clone.call(this);
            t._shell = this._shell.clone(), t._holes = new Array(this._holes.length).fill(null);
            for (var e = 0; e < this._holes.length; e++) t._holes[e] = this._holes[e].clone();
            return t
        }, r.prototype.getGeometryType = function () {
            return "Polygon"
        }, r.prototype.copy = function () {
            for (var t = this._shell.copy(), e = new Array(this._holes.length).fill(null), n = 0; n < e.length; n++) e[n] = this._holes[n].copy();
            return new r(t, e, this._factory)
        }, r.prototype.getExteriorRing = function () {
            return this._shell
        }, r.prototype.isEmpty = function () {
            return this._shell.isEmpty()
        }, r.prototype.getInteriorRingN = function (t) {
            return this._holes[t]
        }, r.prototype.interfaces_ = function () {
            return [ic]
        }, r.prototype.getClass = function () {
            return r
        }, t.serialVersionUID.get = function () {
            return -0x307ffefd8dc97200
        }, Object.defineProperties(r, t), r
    }(Qa), sc = function (n) {
        function r() {
            n.apply(this, arguments)
        }

        n && (r.__proto__ = n);
        var t = {serialVersionUID: {configurable: !0}};
        return ((r.prototype = Object.create(n && n.prototype)).constructor = r).prototype.getSortIndex = function () {
            return Qa.SORTINDEX_MULTIPOINT
        }, r.prototype.isValid = function () {
            return !0
        }, r.prototype.equalsExact = function () {
            if (2 !== arguments.length) return n.prototype.equalsExact.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            return !!this.isEquivalentClass(t) && n.prototype.equalsExact.call(this, t, e)
        }, r.prototype.getCoordinate = function () {
            if (1 !== arguments.length) return n.prototype.getCoordinate.apply(this, arguments);
            var t = arguments[0];
            return this._geometries[t].getCoordinate()
        }, r.prototype.getBoundaryDimension = function () {
            return Gu.FALSE
        }, r.prototype.getDimension = function () {
            return 0
        }, r.prototype.getBoundary = function () {
            return this.getFactory().createGeometryCollection(null)
        }, r.prototype.getGeometryType = function () {
            return "MultiPoint"
        }, r.prototype.copy = function () {
            for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
            return new r(t, this._factory)
        }, r.prototype.interfaces_ = function () {
            return [nc]
        }, r.prototype.getClass = function () {
            return r
        }, t.serialVersionUID.get = function () {
            return -0x6fb1ed4162e0fc00
        }, Object.defineProperties(r, t), r
    }(ju), ac = function (n) {
        function t(t, e) {
            t instanceof pa && e instanceof bc && (t = e.getCoordinateSequenceFactory().create(t)), n.call(this, t, e), this.validateConstruction()
        }

        n && (t.__proto__ = n);
        var e = {MINIMUM_VALID_SIZE: {configurable: !0}, serialVersionUID: {configurable: !0}};
        return ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.getSortIndex = function () {
            return Qa.SORTINDEX_LINEARRING
        }, t.prototype.getBoundaryDimension = function () {
            return Gu.FALSE
        }, t.prototype.isClosed = function () {
            return !!this.isEmpty() || n.prototype.isClosed.call(this)
        }, t.prototype.reverse = function () {
            var t = this._points.copy();
            return tc.reverse(t), this.getFactory().createLinearRing(t)
        }, t.prototype.validateConstruction = function () {
            if (!this.isEmpty() && !n.prototype.isClosed.call(this)) throw new oa("Points of LinearRing do not form a closed linestring");
            if (1 <= this.getCoordinateSequence().size() && this.getCoordinateSequence().size() < t.MINIMUM_VALID_SIZE) throw new oa("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)")
        }, t.prototype.getGeometryType = function () {
            return "LinearRing"
        }, t.prototype.copy = function () {
            return new t(this._points.copy(), this._factory)
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, e.MINIMUM_VALID_SIZE.get = function () {
            return 4
        }, e.serialVersionUID.get = function () {
            return -0x3b229e262367a600
        }, Object.defineProperties(t, e), t
    }(ec), uc = function (n) {
        function r() {
            n.apply(this, arguments)
        }

        n && (r.__proto__ = n);
        var t = {serialVersionUID: {configurable: !0}};
        return ((r.prototype = Object.create(n && n.prototype)).constructor = r).prototype.getSortIndex = function () {
            return Qa.SORTINDEX_MULTIPOLYGON
        }, r.prototype.equalsExact = function () {
            if (2 !== arguments.length) return n.prototype.equalsExact.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            return !!this.isEquivalentClass(t) && n.prototype.equalsExact.call(this, t, e)
        }, r.prototype.getBoundaryDimension = function () {
            return 1
        }, r.prototype.getDimension = function () {
            return 2
        }, r.prototype.reverse = function () {
            for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();
            return this.getFactory().createMultiPolygon(e)
        }, r.prototype.getBoundary = function () {
            if (this.isEmpty()) return this.getFactory().createMultiLineString();
            for (var t = new fu, e = 0; e < this._geometries.length; e++) for (var n = this._geometries[e].getBoundary(), r = 0; r < n.getNumGeometries(); r++) t.add(n.getGeometryN(r));
            var i = new Array(t.size()).fill(null);
            return this.getFactory().createMultiLineString(t.toArray(i))
        }, r.prototype.getGeometryType = function () {
            return "MultiPolygon"
        }, r.prototype.copy = function () {
            for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
            return new r(t, this._factory)
        }, r.prototype.interfaces_ = function () {
            return [ic]
        }, r.prototype.getClass = function () {
            return r
        }, t.serialVersionUID.get = function () {
            return -0x7a5aa1369171980
        }, Object.defineProperties(r, t), r
    }(ju), cc = function (t) {
        this._factory = t || null, this._isUserDataCopied = !1
    }, hc = {
        NoOpGeometryOperation: {configurable: !0},
        CoordinateOperation: {configurable: !0},
        CoordinateSequenceOperation: {configurable: !0}
    };
    cc.prototype.setCopyUserData = function (t) {
        this._isUserDataCopied = t
    }, cc.prototype.edit = function (t, e) {
        if (null === t) return null;
        var n = this.editInternal(t, e);
        return this._isUserDataCopied && n.setUserData(t.getUserData()), n
    }, cc.prototype.editInternal = function (t, e) {
        return null === this._factory && (this._factory = t.getFactory()), t instanceof ju ? this.editGeometryCollection(t, e) : t instanceof oc ? this.editPolygon(t, e) : t instanceof rc ? e.edit(t, this._factory) : t instanceof ec ? e.edit(t, this._factory) : (Xa.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null)
    }, cc.prototype.editGeometryCollection = function (t, e) {
        for (var n = e.edit(t, this._factory), r = new fu, i = 0; i < n.getNumGeometries(); i++) {
            var o = this.edit(n.getGeometryN(i), e);
            null === o || o.isEmpty() || r.add(o)
        }
        return n.getClass() === sc ? this._factory.createMultiPoint(r.toArray([])) : n.getClass() === Xu ? this._factory.createMultiLineString(r.toArray([])) : n.getClass() === uc ? this._factory.createMultiPolygon(r.toArray([])) : this._factory.createGeometryCollection(r.toArray([]))
    }, cc.prototype.editPolygon = function (t, e) {
        var n = e.edit(t, this._factory);
        if (null === n && (n = this._factory.createPolygon(null)), n.isEmpty()) return n;
        var r = this.edit(n.getExteriorRing(), e);
        if (null === r || r.isEmpty()) return this._factory.createPolygon();
        for (var i = new fu, o = 0; o < n.getNumInteriorRing(); o++) {
            var s = this.edit(n.getInteriorRingN(o), e);
            null === s || s.isEmpty() || i.add(s)
        }
        return this._factory.createPolygon(r, i.toArray([]))
    }, cc.prototype.interfaces_ = function () {
        return []
    }, cc.prototype.getClass = function () {
        return cc
    }, cc.GeometryEditorOperation = function () {
    }, hc.NoOpGeometryOperation.get = function () {
        return lc
    }, hc.CoordinateOperation.get = function () {
        return pc
    }, hc.CoordinateSequenceOperation.get = function () {
        return fc
    }, Object.defineProperties(cc, hc);
    var lc = function () {
    };
    lc.prototype.edit = function (t, e) {
        return t
    }, lc.prototype.interfaces_ = function () {
        return [cc.GeometryEditorOperation]
    }, lc.prototype.getClass = function () {
        return lc
    };
    var pc = function () {
    };
    pc.prototype.edit = function (t, e) {
        var n = this.editCoordinates(t.getCoordinates(), t);
        return null === n ? t : t instanceof ac ? e.createLinearRing(n) : t instanceof ec ? e.createLineString(n) : t instanceof rc ? 0 < n.length ? e.createPoint(n[0]) : e.createPoint() : t
    }, pc.prototype.interfaces_ = function () {
        return [cc.GeometryEditorOperation]
    }, pc.prototype.getClass = function () {
        return pc
    };
    var fc = function () {
    };
    fc.prototype.edit = function (t, e) {
        return t instanceof ac ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof ec ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof rc ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t
    }, fc.prototype.interfaces_ = function () {
        return [cc.GeometryEditorOperation]
    }, fc.prototype.getClass = function () {
        return fc
    };
    var gc = function () {
        if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) this._coordinates = arguments[0], this._dimension = 3; else if (Number.isInteger(arguments[0])) {
                var t = arguments[0];
                this._coordinates = new Array(t).fill(null);
                for (var e = 0; e < t; e++) this._coordinates[e] = new pa
            } else if (ma(arguments[0], Ma)) {
                var n = arguments[0];
                if (null === n) return this._coordinates = new Array(0).fill(null), null;
                this._dimension = n.getDimension(), this._coordinates = new Array(n.size()).fill(null);
                for (var r = 0; r < this._coordinates.length; r++) this._coordinates[r] = n.getCoordinateCopy(r)
            }
        } else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var i = arguments[0], o = arguments[1];
            this._coordinates = i, this._dimension = o, null === i && (this._coordinates = new Array(0).fill(null))
        } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var s = arguments[0], a = arguments[1];
            this._coordinates = new Array(s).fill(null), this._dimension = a;
            for (var u = 0; u < s; u++) this._coordinates[u] = new pa
        }
    }, dc = {serialVersionUID: {configurable: !0}};
    gc.prototype.setOrdinate = function (t, e, n) {
        switch (e) {
            case Ma.X:
                this._coordinates[t].x = n;
                break;
            case Ma.Y:
                this._coordinates[t].y = n;
                break;
            case Ma.Z:
                this._coordinates[t].z = n;
                break;
            default:
                throw new oa("invalid ordinateIndex")
        }
    }, gc.prototype.size = function () {
        return this._coordinates.length
    }, gc.prototype.getOrdinate = function (t, e) {
        switch (e) {
            case Ma.X:
                return this._coordinates[t].x;
            case Ma.Y:
                return this._coordinates[t].y;
            case Ma.Z:
                return this._coordinates[t].z
        }
        return sa.NaN
    }, gc.prototype.getCoordinate = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return this._coordinates[t]
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            n.x = this._coordinates[e].x, n.y = this._coordinates[e].y, n.z = this._coordinates[e].z
        }
    }, gc.prototype.getCoordinateCopy = function (t) {
        return new pa(this._coordinates[t])
    }, gc.prototype.getDimension = function () {
        return this._dimension
    }, gc.prototype.getX = function (t) {
        return this._coordinates[t].x
    }, gc.prototype.clone = function () {
        for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].clone();
        return new gc(t, this._dimension)
    }, gc.prototype.expandEnvelope = function (t) {
        for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);
        return t
    }, gc.prototype.copy = function () {
        for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].copy();
        return new gc(t, this._dimension)
    }, gc.prototype.toString = function () {
        if (0 < this._coordinates.length) {
            var t = new Ea(17 * this._coordinates.length);
            t.append("("), t.append(this._coordinates[0]);
            for (var e = 1; e < this._coordinates.length; e++) t.append(", "), t.append(this._coordinates[e]);
            return t.append(")"), t.toString()
        }
        return "()"
    }, gc.prototype.getY = function (t) {
        return this._coordinates[t].y
    }, gc.prototype.toCoordinateArray = function () {
        return this._coordinates
    }, gc.prototype.interfaces_ = function () {
        return [Ma, la]
    }, gc.prototype.getClass = function () {
        return gc
    }, dc.serialVersionUID.get = function () {
        return -0xcb44a778db18e00
    }, Object.defineProperties(gc, dc);
    var yc = function () {
    }, _c = {serialVersionUID: {configurable: !0}, instanceObject: {configurable: !0}};
    yc.prototype.readResolve = function () {
        return yc.instance()
    }, yc.prototype.create = function () {
        if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
                var t = arguments[0];
                return new gc(t)
            }
            if (ma(arguments[0], Ma)) {
                var e = arguments[0];
                return new gc(e)
            }
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            return 3 < r && (r = 3), r < 2 ? new gc(n) : new gc(n, r)
        }
    }, yc.prototype.interfaces_ = function () {
        return [da, la]
    }, yc.prototype.getClass = function () {
        return yc
    }, yc.instance = function () {
        return yc.instanceObject
    }, _c.serialVersionUID.get = function () {
        return -0x38e49fa6cf6f2e00
    }, _c.instanceObject.get = function () {
        return new yc
    }, Object.defineProperties(yc, _c);
    var mc = function (t) {
        function e() {
            t.call(this), this.map_ = new Map
        }

        return t && (e.__proto__ = t), ((e.prototype = Object.create(t && t.prototype)).constructor = e).prototype.get = function (t) {
            return this.map_.get(t) || null
        }, e.prototype.put = function (t, e) {
            return this.map_.set(t, e), e
        }, e.prototype.values = function () {
            for (var t = new fu, e = this.map_.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();
            return t
        }, e.prototype.entrySet = function () {
            var e = new Iu;
            return this.map_.entries().forEach(function (t) {
                return e.add(t)
            }), e
        }, e.prototype.size = function () {
            return this.map_.size()
        }, e
    }(xu), vc = function t() {
        if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t.FLOATING; else if (1 === arguments.length) if (arguments[0] instanceof Ec) {
            var e = arguments[0];
            (this._modelType = e) === t.FIXED && this.setScale(1)
        } else if ("number" == typeof arguments[0]) {
            var n = arguments[0];
            this._modelType = t.FIXED, this.setScale(n)
        } else if (arguments[0] instanceof t) {
            var r = arguments[0];
            this._modelType = r._modelType, this._scale = r._scale
        }
    }, xc = {serialVersionUID: {configurable: !0}, maximumPreciseValue: {configurable: !0}};
    vc.prototype.equals = function (t) {
        if (!(t instanceof vc)) return !1;
        var e = t;
        return this._modelType === e._modelType && this._scale === e._scale
    }, vc.prototype.compareTo = function (t) {
        var e = t, n = this.getMaximumSignificantDigits(), r = e.getMaximumSignificantDigits();
        return new wa(n).compareTo(new wa(r))
    }, vc.prototype.getScale = function () {
        return this._scale
    }, vc.prototype.isFloating = function () {
        return this._modelType === vc.FLOATING || this._modelType === vc.FLOATING_SINGLE
    }, vc.prototype.getType = function () {
        return this._modelType
    }, vc.prototype.toString = function () {
        var t = "UNKNOWN";
        return this._modelType === vc.FLOATING ? t = "Floating" : this._modelType === vc.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === vc.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t
    }, vc.prototype.makePrecise = function () {
        if ("number" == typeof arguments[0]) {
            var t = arguments[0];
            return sa.isNaN(t) ? t : this._modelType !== vc.FLOATING_SINGLE && this._modelType === vc.FIXED ? Math.round(t * this._scale) / this._scale : t
        }
        if (arguments[0] instanceof pa) {
            var e = arguments[0];
            if (this._modelType === vc.FLOATING) return null;
            e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y)
        }
    }, vc.prototype.getMaximumSignificantDigits = function () {
        var t = 16;
        return this._modelType === vc.FLOATING ? t = 16 : this._modelType === vc.FLOATING_SINGLE ? t = 6 : this._modelType === vc.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t
    }, vc.prototype.setScale = function (t) {
        this._scale = Math.abs(t)
    }, vc.prototype.interfaces_ = function () {
        return [la, ua]
    }, vc.prototype.getClass = function () {
        return vc
    }, vc.mostPrecise = function (t, e) {
        return 0 <= t.compareTo(e) ? t : e
    }, xc.serialVersionUID.get = function () {
        return 0x6bee6404e9a25c00
    }, xc.maximumPreciseValue.get = function () {
        return 9007199254740992
    }, Object.defineProperties(vc, xc);
    var Ec = function t(e) {
        this._name = e || null, t.nameToTypeMap.put(e, this)
    }, wc = {serialVersionUID: {configurable: !0}, nameToTypeMap: {configurable: !0}};
    Ec.prototype.readResolve = function () {
        return Ec.nameToTypeMap.get(this._name)
    }, Ec.prototype.toString = function () {
        return this._name
    }, Ec.prototype.interfaces_ = function () {
        return [la]
    }, Ec.prototype.getClass = function () {
        return Ec
    }, wc.serialVersionUID.get = function () {
        return -552860263173159e4
    }, wc.nameToTypeMap.get = function () {
        return new mc
    }, Object.defineProperties(Ec, wc), vc.Type = Ec, vc.FIXED = new Ec("FIXED"), vc.FLOATING = new Ec("FLOATING"), vc.FLOATING_SINGLE = new Ec("FLOATING SINGLE");
    var bc = function t() {
        this._precisionModel = new vc, this._SRID = 0, this._coordinateSequenceFactory = t.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? ma(arguments[0], da) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof vc && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]))
    }, Ic = {serialVersionUID: {configurable: !0}};
    bc.prototype.toGeometry = function (t) {
        return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new pa(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new pa(t.getMinX(), t.getMinY()), new pa(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new pa(t.getMinX(), t.getMinY()), new pa(t.getMinX(), t.getMaxY()), new pa(t.getMaxX(), t.getMaxY()), new pa(t.getMaxX(), t.getMinY()), new pa(t.getMinX(), t.getMinY())]), null)
    }, bc.prototype.createLineString = function (t) {
        return t ? t instanceof Array ? new ec(this.getCoordinateSequenceFactory().create(t), this) : ma(t, Ma) ? new ec(t, this) : void 0 : new ec(this.getCoordinateSequenceFactory().create([]), this)
    }, bc.prototype.createMultiLineString = function () {
        if (0 === arguments.length) return new Xu(null, this);
        if (1 === arguments.length) {
            var t = arguments[0];
            return new Xu(t, this)
        }
    }, bc.prototype.buildGeometry = function (t) {
        for (var e = null, n = !1, r = !1, i = t.iterator(); i.hasNext();) {
            var o = i.next(), s = o.getClass();
            null === e && (e = s), s !== e && (n = !0), o.isGeometryCollectionOrDerived() && (r = !0)
        }
        if (null === e) return this.createGeometryCollection();
        if (n || r) return this.createGeometryCollection(bc.toGeometryArray(t));
        var a = t.iterator().next();
        if (1 < t.size()) {
            if (a instanceof oc) return this.createMultiPolygon(bc.toPolygonArray(t));
            if (a instanceof ec) return this.createMultiLineString(bc.toLineStringArray(t));
            if (a instanceof rc) return this.createMultiPoint(bc.toPointArray(t));
            Xa.shouldNeverReachHere("Unhandled class: " + a.getClass().getName())
        }
        return a
    }, bc.prototype.createMultiPointFromCoords = function (t) {
        return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
    }, bc.prototype.createPoint = function () {
        if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        if (1 === arguments.length) {
            if (arguments[0] instanceof pa) {
                var t = arguments[0];
                return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null)
            }
            if (ma(arguments[0], Ma)) {
                var e = arguments[0];
                return new rc(e, this)
            }
        }
    }, bc.prototype.getCoordinateSequenceFactory = function () {
        return this._coordinateSequenceFactory
    }, bc.prototype.createPolygon = function () {
        if (0 === arguments.length) return new oc(null, null, this);
        if (1 === arguments.length) {
            if (ma(arguments[0], Ma)) {
                var t = arguments[0];
                return this.createPolygon(this.createLinearRing(t))
            }
            if (arguments[0] instanceof Array) {
                var e = arguments[0];
                return this.createPolygon(this.createLinearRing(e))
            }
            if (arguments[0] instanceof ac) {
                var n = arguments[0];
                return this.createPolygon(n, null)
            }
        } else if (2 === arguments.length) {
            var r = arguments[0], i = arguments[1];
            return new oc(r, i, this)
        }
    }, bc.prototype.getSRID = function () {
        return this._SRID
    }, bc.prototype.createGeometryCollection = function () {
        if (0 === arguments.length) return new ju(null, this);
        if (1 === arguments.length) {
            var t = arguments[0];
            return new ju(t, this)
        }
    }, bc.prototype.createGeometry = function (t) {
        return new cc(this).edit(t, {
            edit: function () {
                if (2 === arguments.length) {
                    var t = arguments[0];
                    return this._coordinateSequenceFactory.create(t)
                }
            }
        })
    }, bc.prototype.getPrecisionModel = function () {
        return this._precisionModel
    }, bc.prototype.createLinearRing = function () {
        if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
                var t = arguments[0];
                return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
            }
            if (ma(arguments[0], Ma)) {
                var e = arguments[0];
                return new ac(e, this)
            }
        }
    }, bc.prototype.createMultiPolygon = function () {
        if (0 === arguments.length) return new uc(null, this);
        if (1 === arguments.length) {
            var t = arguments[0];
            return new uc(t, this)
        }
    }, bc.prototype.createMultiPoint = function () {
        if (0 === arguments.length) return new sc(null, this);
        if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
                var t = arguments[0];
                return new sc(t, this)
            }
            if (arguments[0] instanceof Array) {
                var e = arguments[0];
                return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null)
            }
            if (ma(arguments[0], Ma)) {
                var n = arguments[0];
                if (null === n) return this.createMultiPoint(new Array(0).fill(null));
                for (var r = new Array(n.size()).fill(null), i = 0; i < n.size(); i++) {
                    var o = this.getCoordinateSequenceFactory().create(1, n.getDimension());
                    tc.copy(n, i, o, 0, 1), r[i] = this.createPoint(o)
                }
                return this.createMultiPoint(r)
            }
        }
    }, bc.prototype.interfaces_ = function () {
        return [la]
    }, bc.prototype.getClass = function () {
        return bc
    }, bc.toMultiPolygonArray = function (t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.toGeometryArray = function (t) {
        if (null === t) return null;
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.getDefaultCoordinateSequenceFactory = function () {
        return yc.instance()
    }, bc.toMultiLineStringArray = function (t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.toLineStringArray = function (t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.toMultiPointArray = function (t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.toLinearRingArray = function (t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.toPointArray = function (t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.toPolygonArray = function (t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }, bc.createPointFromInternalCoord = function (t, e) {
        return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
    }, Ic.serialVersionUID.get = function () {
        return -0x5ea75f2051eeb400
    }, Object.defineProperties(bc, Ic);
    var Nc = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Cc = function (t) {
        this.geometryFactory = t || new bc
    };
    Cc.prototype.read = function (t) {
        var e, n = (e = "string" == typeof t ? JSON.parse(t) : t).type;
        if (!Sc[n]) throw new Error("Unknown GeoJSON type: " + e.type);
        return -1 !== Nc.indexOf(n) ? Sc[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? Sc[n].apply(this, [e.geometries]) : Sc[n].apply(this, [e])
    }, Cc.prototype.write = function (t) {
        var e = t.getGeometryType();
        if (!Mc[e]) throw new Error("Geometry is not supported");
        return Mc[e].apply(this, [t])
    };
    var Sc = {
        Feature: function (t) {
            var e = {};
            for (var n in t) e[n] = t[n];
            if (t.geometry) {
                var r = t.geometry.type;
                if (!Sc[r]) throw new Error("Unknown GeoJSON type: " + t.type);
                e.geometry = this.read(t.geometry)
            }
            return t.bbox && (e.bbox = Sc.bbox.apply(this, [t.bbox])), e
        }, FeatureCollection: function (t) {
            var e = {};
            if (t.features) {
                e.features = [];
                for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]))
            }
            return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e
        }, coordinates: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) {
                var r = t[n];
                e.push(new pa(r[0], r[1]))
            }
            return e
        }, bbox: function (t) {
            return this.geometryFactory.createLinearRing([new pa(t[0], t[1]), new pa(t[2], t[1]), new pa(t[2], t[3]), new pa(t[0], t[3]), new pa(t[0], t[1])])
        }, Point: function (t) {
            var e = new pa(t[0], t[1]);
            return this.geometryFactory.createPoint(e)
        }, MultiPoint: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) e.push(Sc.Point.apply(this, [t[n]]));
            return this.geometryFactory.createMultiPoint(e)
        }, LineString: function (t) {
            var e = Sc.coordinates.apply(this, [t]);
            return this.geometryFactory.createLineString(e)
        }, MultiLineString: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) e.push(Sc.LineString.apply(this, [t[n]]));
            return this.geometryFactory.createMultiLineString(e)
        }, Polygon: function (t) {
            for (var e = Sc.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), r = [], i = 1; i < t.length; ++i) {
                var o = t[i], s = Sc.coordinates.apply(this, [o]), a = this.geometryFactory.createLinearRing(s);
                r.push(a)
            }
            return this.geometryFactory.createPolygon(n, r)
        }, MultiPolygon: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) {
                var r = t[n];
                e.push(Sc.Polygon.apply(this, [r]))
            }
            return this.geometryFactory.createMultiPolygon(e)
        }, GeometryCollection: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) {
                var r = t[n];
                e.push(this.read(r))
            }
            return this.geometryFactory.createGeometryCollection(e)
        }
    }, Mc = {
        coordinate: function (t) {
            return [t.x, t.y]
        }, Point: function (t) {
            return {type: "Point", coordinates: Mc.coordinate.apply(this, [t.getCoordinate()])}
        }, MultiPoint: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                var r = t._geometries[n], i = Mc.Point.apply(this, [r]);
                e.push(i.coordinates)
            }
            return {type: "MultiPoint", coordinates: e}
        }, LineString: function (t) {
            for (var e = [], n = t.getCoordinates(), r = 0; r < n.length; ++r) {
                var i = n[r];
                e.push(Mc.coordinate.apply(this, [i]))
            }
            return {type: "LineString", coordinates: e}
        }, MultiLineString: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                var r = t._geometries[n], i = Mc.LineString.apply(this, [r]);
                e.push(i.coordinates)
            }
            return {type: "MultiLineString", coordinates: e}
        }, Polygon: function (t) {
            var e = [], n = Mc.LineString.apply(this, [t._shell]);
            e.push(n.coordinates);
            for (var r = 0; r < t._holes.length; ++r) {
                var i = t._holes[r], o = Mc.LineString.apply(this, [i]);
                e.push(o.coordinates)
            }
            return {type: "Polygon", coordinates: e}
        }, MultiPolygon: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                var r = t._geometries[n], i = Mc.Polygon.apply(this, [r]);
                e.push(i.coordinates)
            }
            return {type: "MultiPolygon", coordinates: e}
        }, GeometryCollection: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                var r = t._geometries[n], i = r.getGeometryType();
                e.push(Mc[i].apply(this, [r]))
            }
            return {type: "GeometryCollection", geometries: e}
        }
    }, Lc = function (t) {
        this.geometryFactory = t || new bc, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Cc(this.geometryFactory)
    };
    Lc.prototype.read = function (t) {
        var e = this.parser.read(t);
        return this.precisionModel.getType() === vc.FIXED && this.reducePrecision(e), e
    }, Lc.prototype.reducePrecision = function (t) {
        var e, n;
        if (t.coordinate) this.precisionModel.makePrecise(t.coordinate); else if (t.points) for (e = 0, n = t.points.length; e < n; e++) this.precisionModel.makePrecise(t.points[e]); else if (t.geometries) for (e = 0, n = t.geometries.length; e < n; e++) this.reducePrecision(t.geometries[e])
    };
    var Pc = function () {
        this.parser = new Cc(this.geometryFactory)
    };
    Pc.prototype.write = function (t) {
        return this.parser.write(t)
    };
    var Oc = function () {
    }, Rc = {ON: {configurable: !0}, LEFT: {configurable: !0}, RIGHT: {configurable: !0}};

    function Tc(t) {
        this.message = t || ""
    }

    function Ac() {
        this.array_ = []
    }

    Oc.prototype.interfaces_ = function () {
        return []
    }, Oc.prototype.getClass = function () {
        return Oc
    }, Oc.opposite = function (t) {
        return t === Oc.LEFT ? Oc.RIGHT : t === Oc.RIGHT ? Oc.LEFT : t
    }, Rc.ON.get = function () {
        return 0
    }, Rc.LEFT.get = function () {
        return 1
    }, Rc.RIGHT.get = function () {
        return 2
    }, Object.defineProperties(Oc, Rc), (Tc.prototype = new Error).name = "EmptyStackException", (Ac.prototype = new lu).add = function (t) {
        return this.array_.push(t), !0
    }, Ac.prototype.get = function (t) {
        if (t < 0 || t >= this.size()) throw new Error;
        return this.array_[t]
    }, Ac.prototype.push = function (t) {
        return this.array_.push(t), t
    }, Ac.prototype.pop = function (t) {
        if (0 === this.array_.length) throw new Tc;
        return this.array_.pop()
    }, Ac.prototype.peek = function () {
        if (0 === this.array_.length) throw new Tc;
        return this.array_[this.array_.length - 1]
    }, Ac.prototype.empty = function () {
        return 0 === this.array_.length
    }, Ac.prototype.isEmpty = function () {
        return this.empty()
    }, Ac.prototype.search = function (t) {
        return this.array_.indexOf(t)
    }, Ac.prototype.size = function () {
        return this.array_.length
    }, Ac.prototype.toArray = function () {
        for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
        return t
    };
    var Dc = function () {
        this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null
    };
    Dc.prototype.getCoordinate = function () {
        return this._minCoord
    }, Dc.prototype.getRightmostSide = function (t, e) {
        var n = this.getRightmostSideOfSegment(t, e);
        return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n
    }, Dc.prototype.findRightmostEdgeAtVertex = function () {
        var t = this._minDe.getEdge().getCoordinates();
        Xa.isTrue(0 < this._minIndex && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
        var e = t[this._minIndex - 1], n = t[this._minIndex + 1], r = Ja.computeOrientation(this._minCoord, n, e),
            i = !1;
        e.y < this._minCoord.y && n.y < this._minCoord.y && r === Ja.COUNTERCLOCKWISE ? i = !0 : e.y > this._minCoord.y && n.y > this._minCoord.y && r === Ja.CLOCKWISE && (i = !0), i && (this._minIndex = this._minIndex - 1)
    }, Dc.prototype.getRightmostSideOfSegment = function (t, e) {
        var n = t.getEdge().getCoordinates();
        if (e < 0 || e + 1 >= n.length) return -1;
        if (n[e].y === n[e + 1].y) return -1;
        var r = Oc.LEFT;
        return n[e].y < n[e + 1].y && (r = Oc.RIGHT), r
    }, Dc.prototype.getEdge = function () {
        return this._orientedDe
    }, Dc.prototype.checkForRightmostCoordinate = function (t) {
        for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) (null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n])
    }, Dc.prototype.findRightmostEdgeAtNode = function () {
        var t = this._minDe.getNode().getEdges();
        this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1)
    }, Dc.prototype.findEdge = function (t) {
        for (var e = t.iterator(); e.hasNext();) {
            var n = e.next();
            n.isForward() && this.checkForRightmostCoordinate(n)
        }
        Xa.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === Oc.LEFT && (this._orientedDe = this._minDe.getSym())
    }, Dc.prototype.interfaces_ = function () {
        return []
    }, Dc.prototype.getClass = function () {
        return Dc
    };
    var Fc = function (n) {
        function r(t, e) {
            n.call(this, r.msgWithCoord(t, e)), this.pt = e ? new pa(e) : null, this.name = "TopologyException"
        }

        return n && (r.__proto__ = n), ((r.prototype = Object.create(n && n.prototype)).constructor = r).prototype.getCoordinate = function () {
            return this.pt
        }, r.prototype.interfaces_ = function () {
            return []
        }, r.prototype.getClass = function () {
            return r
        }, r.msgWithCoord = function (t, e) {
            return e ? t : t + " [ " + e + " ]"
        }, r
    }(za), qc = function () {
        this.array_ = []
    };
    qc.prototype.addLast = function (t) {
        this.array_.push(t)
    }, qc.prototype.removeFirst = function () {
        return this.array_.shift()
    }, qc.prototype.isEmpty = function () {
        return 0 === this.array_.length
    };
    var Gc = function () {
        this._finder = null, this._dirEdgeList = new fu, this._nodes = new fu, this._rightMostCoord = null, this._env = null, this._finder = new Dc
    };
    Gc.prototype.clearVisitedEdges = function () {
        for (var t = this._dirEdgeList.iterator(); t.hasNext();) t.next().setVisited(!1)
    }, Gc.prototype.getRightmostCoordinate = function () {
        return this._rightMostCoord
    }, Gc.prototype.computeNodeDepth = function (t) {
        for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
            var r = n.next();
            if (r.isVisited() || r.getSym().isVisited()) {
                e = r;
                break
            }
        }
        if (null === e) throw new Fc("unable to find edge to compute depths at " + t.getCoordinate());
        t.getEdges().computeDepths(e);
        for (var i = t.getEdges().iterator(); i.hasNext();) {
            var o = i.next();
            o.setVisited(!0), this.copySymDepths(o)
        }
    }, Gc.prototype.computeDepth = function (t) {
        this.clearVisitedEdges();
        var e = this._finder.getEdge();
        e.setEdgeDepths(Oc.RIGHT, t), this.copySymDepths(e), this.computeDepths(e)
    }, Gc.prototype.create = function (t) {
        this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate()
    }, Gc.prototype.findResultEdges = function () {
        for (var t = this._dirEdgeList.iterator(); t.hasNext();) {
            var e = t.next();
            1 <= e.getDepth(Oc.RIGHT) && e.getDepth(Oc.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
        }
    }, Gc.prototype.computeDepths = function (t) {
        var e = new Iu, n = new qc, r = t.getNode();
        for (n.addLast(r), e.add(r), t.setVisited(!0); !n.isEmpty();) {
            var i = n.removeFirst();
            e.add(i), this.computeNodeDepth(i);
            for (var o = i.getEdges().iterator(); o.hasNext();) {
                var s = o.next().getSym();
                if (!s.isVisited()) {
                    var a = s.getNode();
                    e.contains(a) || (n.addLast(a), e.add(a))
                }
            }
        }
    }, Gc.prototype.compareTo = function (t) {
        var e = t;
        return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0
    }, Gc.prototype.getEnvelope = function () {
        if (null === this._env) {
            for (var t = new Aa, e = this._dirEdgeList.iterator(); e.hasNext();) for (var n = e.next().getEdge().getCoordinates(), r = 0; r < n.length - 1; r++) t.expandToInclude(n[r]);
            this._env = t
        }
        return this._env
    }, Gc.prototype.addReachable = function (t) {
        var e = new Ac;
        for (e.add(t); !e.empty();) {
            var n = e.pop();
            this.add(n, e)
        }
    }, Gc.prototype.copySymDepths = function (t) {
        var e = t.getSym();
        e.setDepth(Oc.LEFT, t.getDepth(Oc.RIGHT)), e.setDepth(Oc.RIGHT, t.getDepth(Oc.LEFT))
    }, Gc.prototype.add = function (t, e) {
        t.setVisited(!0), this._nodes.add(t);
        for (var n = t.getEdges().iterator(); n.hasNext();) {
            var r = n.next();
            this._dirEdgeList.add(r);
            var i = r.getSym().getNode();
            i.isVisited() || e.push(i)
        }
    }, Gc.prototype.getNodes = function () {
        return this._nodes
    }, Gc.prototype.getDirectedEdges = function () {
        return this._dirEdgeList
    }, Gc.prototype.interfaces_ = function () {
        return [ua]
    }, Gc.prototype.getClass = function () {
        return Gc
    };
    var Bc = function t() {
        if (this.location = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
                var e = arguments[0];
                this.init(e.length)
            } else if (Number.isInteger(arguments[0])) {
                var n = arguments[0];
                this.init(1), this.location[Oc.ON] = n
            } else if (arguments[0] instanceof t) {
                var r = arguments[0];
                if (this.init(r.location.length), null !== r) for (var i = 0; i < this.location.length; i++) this.location[i] = r.location[i]
            }
        } else if (3 === arguments.length) {
            var o = arguments[0], s = arguments[1], a = arguments[2];
            this.init(3), this.location[Oc.ON] = o, this.location[Oc.LEFT] = s, this.location[Oc.RIGHT] = a
        }
    };
    Bc.prototype.setAllLocations = function (t) {
        for (var e = 0; e < this.location.length; e++) this.location[e] = t
    }, Bc.prototype.isNull = function () {
        for (var t = 0; t < this.location.length; t++) if (this.location[t] !== ya.NONE) return !1;
        return !0
    }, Bc.prototype.setAllLocationsIfNull = function (t) {
        for (var e = 0; e < this.location.length; e++) this.location[e] === ya.NONE && (this.location[e] = t)
    }, Bc.prototype.isLine = function () {
        return 1 === this.location.length
    }, Bc.prototype.merge = function (t) {
        if (t.location.length > this.location.length) {
            var e = new Array(3).fill(null);
            e[Oc.ON] = this.location[Oc.ON], e[Oc.LEFT] = ya.NONE, e[Oc.RIGHT] = ya.NONE, this.location = e
        }
        for (var n = 0; n < this.location.length; n++) this.location[n] === ya.NONE && n < t.location.length && (this.location[n] = t.location[n])
    }, Bc.prototype.getLocations = function () {
        return this.location
    }, Bc.prototype.flip = function () {
        if (this.location.length <= 1) return null;
        var t = this.location[Oc.LEFT];
        this.location[Oc.LEFT] = this.location[Oc.RIGHT], this.location[Oc.RIGHT] = t
    }, Bc.prototype.toString = function () {
        var t = new Ea;
        return 1 < this.location.length && t.append(ya.toLocationSymbol(this.location[Oc.LEFT])), t.append(ya.toLocationSymbol(this.location[Oc.ON])), 1 < this.location.length && t.append(ya.toLocationSymbol(this.location[Oc.RIGHT])), t.toString()
    }, Bc.prototype.setLocations = function (t, e, n) {
        this.location[Oc.ON] = t, this.location[Oc.LEFT] = e, this.location[Oc.RIGHT] = n
    }, Bc.prototype.get = function (t) {
        return t < this.location.length ? this.location[t] : ya.NONE
    }, Bc.prototype.isArea = function () {
        return 1 < this.location.length
    }, Bc.prototype.isAnyNull = function () {
        for (var t = 0; t < this.location.length; t++) if (this.location[t] === ya.NONE) return !0;
        return !1
    }, Bc.prototype.setLocation = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.setLocation(Oc.ON, t)
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            this.location[e] = n
        }
    }, Bc.prototype.init = function (t) {
        this.location = new Array(t).fill(null), this.setAllLocations(ya.NONE)
    }, Bc.prototype.isEqualOnSide = function (t, e) {
        return this.location[e] === t.location[e]
    }, Bc.prototype.allPositionsEqual = function (t) {
        for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;
        return !0
    }, Bc.prototype.interfaces_ = function () {
        return []
    }, Bc.prototype.getClass = function () {
        return Bc
    };
    var kc = function t() {
        if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
            if (Number.isInteger(arguments[0])) {
                var e = arguments[0];
                this.elt[0] = new Bc(e), this.elt[1] = new Bc(e)
            } else if (arguments[0] instanceof t) {
                var n = arguments[0];
                this.elt[0] = new Bc(n.elt[0]), this.elt[1] = new Bc(n.elt[1])
            }
        } else if (2 === arguments.length) {
            var r = arguments[0], i = arguments[1];
            this.elt[0] = new Bc(ya.NONE), this.elt[1] = new Bc(ya.NONE), this.elt[r].setLocation(i)
        } else if (3 === arguments.length) {
            var o = arguments[0], s = arguments[1], a = arguments[2];
            this.elt[0] = new Bc(o, s, a), this.elt[1] = new Bc(o, s, a)
        } else if (4 === arguments.length) {
            var u = arguments[0], c = arguments[1], h = arguments[2], l = arguments[3];
            this.elt[0] = new Bc(ya.NONE, ya.NONE, ya.NONE), this.elt[1] = new Bc(ya.NONE, ya.NONE, ya.NONE), this.elt[u].setLocations(c, h, l)
        }
    };
    kc.prototype.getGeometryCount = function () {
        var t = 0;
        return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
    }, kc.prototype.setAllLocations = function (t, e) {
        this.elt[t].setAllLocations(e)
    }, kc.prototype.isNull = function (t) {
        return this.elt[t].isNull()
    }, kc.prototype.setAllLocationsIfNull = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            this.elt[e].setAllLocationsIfNull(n)
        }
    }, kc.prototype.isLine = function (t) {
        return this.elt[t].isLine()
    }, kc.prototype.merge = function (t) {
        for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Bc(t.elt[e]) : this.elt[e].merge(t.elt[e])
    }, kc.prototype.flip = function () {
        this.elt[0].flip(), this.elt[1].flip()
    }, kc.prototype.getLocation = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return this.elt[t].get(Oc.ON)
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return this.elt[e].get(n)
        }
    }, kc.prototype.toString = function () {
        var t = new Ea;
        return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString()
    }, kc.prototype.isArea = function () {
        if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
        if (1 === arguments.length) {
            var t = arguments[0];
            return this.elt[t].isArea()
        }
    }, kc.prototype.isAnyNull = function (t) {
        return this.elt[t].isAnyNull()
    }, kc.prototype.setLocation = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            this.elt[t].setLocation(Oc.ON, e)
        } else if (3 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2];
            this.elt[n].setLocation(r, i)
        }
    }, kc.prototype.isEqualOnSide = function (t, e) {
        return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
    }, kc.prototype.allPositionsEqual = function (t, e) {
        return this.elt[t].allPositionsEqual(e)
    }, kc.prototype.toLine = function (t) {
        this.elt[t].isArea() && (this.elt[t] = new Bc(this.elt[t].location[0]))
    }, kc.prototype.interfaces_ = function () {
        return []
    }, kc.prototype.getClass = function () {
        return kc
    }, kc.toLineLabel = function (t) {
        for (var e = new kc(ya.NONE), n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n));
        return e
    };
    var zc = function () {
        this._startDe = null, this._maxNodeDegree = -1, this._edges = new fu, this._pts = new fu, this._label = new kc(ya.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new fu, this._geometryFactory = null;
        var t = arguments[0], e = arguments[1];
        this._geometryFactory = e, this.computePoints(t), this.computeRing()
    };
    zc.prototype.computeRing = function () {
        if (null !== this._ring) return null;
        for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);
        this._ring = this._geometryFactory.createLinearRing(t), this._isHole = Ja.isCCW(this._ring.getCoordinates())
    }, zc.prototype.isIsolated = function () {
        return 1 === this._label.getGeometryCount()
    }, zc.prototype.computePoints = function (t) {
        var e = this._startDe = t, n = !0;
        do {
            if (null === e) throw new Fc("Found null DirectedEdge");
            if (e.getEdgeRing() === this) throw new Fc("Directed Edge visited twice during ring-building at " + e.getCoordinate());
            this._edges.add(e);
            var r = e.getLabel();
            Xa.isTrue(r.isArea()), this.mergeLabel(r), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e)
        } while (e !== this._startDe)
    }, zc.prototype.getLinearRing = function () {
        return this._ring
    }, zc.prototype.getCoordinate = function (t) {
        return this._pts.get(t)
    }, zc.prototype.computeMaxNodeDegree = function () {
        this._maxNodeDegree = 0;
        var t = this._startDe;
        do {
            var e = t.getNode().getEdges().getOutgoingDegree(this);
            e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t)
        } while (t !== this._startDe);
        this._maxNodeDegree *= 2
    }, zc.prototype.addPoints = function (t, e, n) {
        var r = t.getCoordinates();
        if (e) {
            var i = 1;
            n && (i = 0);
            for (var o = i; o < r.length; o++) this._pts.add(r[o])
        } else {
            var s = r.length - 2;
            n && (s = r.length - 1);
            for (var a = s; 0 <= a; a--) this._pts.add(r[a])
        }
    }, zc.prototype.isHole = function () {
        return this._isHole
    }, zc.prototype.setInResult = function () {
        for (var t = this._startDe; t.getEdge().setInResult(!0), (t = t.getNext()) !== this._startDe;) ;
    }, zc.prototype.containsPoint = function (t) {
        var e = this.getLinearRing();
        if (!e.getEnvelopeInternal().contains(t)) return !1;
        if (!Ja.isPointInRing(t, e.getCoordinates())) return !1;
        for (var n = this._holes.iterator(); n.hasNext();) if (n.next().containsPoint(t)) return !1;
        return !0
    }, zc.prototype.addHole = function (t) {
        this._holes.add(t)
    }, zc.prototype.isShell = function () {
        return null === this._shell
    }, zc.prototype.getLabel = function () {
        return this._label
    }, zc.prototype.getEdges = function () {
        return this._edges
    }, zc.prototype.getMaxNodeDegree = function () {
        return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree
    }, zc.prototype.getShell = function () {
        return this._shell
    }, zc.prototype.mergeLabel = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.mergeLabel(t, 0), this.mergeLabel(t, 1)
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = e.getLocation(n, Oc.RIGHT);
            if (r === ya.NONE) return null;
            if (this._label.getLocation(n) === ya.NONE) return this._label.setLocation(n, r), null
        }
    }, zc.prototype.setShell = function (t) {
        null !== (this._shell = t) && t.addHole(this)
    }, zc.prototype.toPolygon = function (t) {
        for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();
        return t.createPolygon(this.getLinearRing(), e)
    }, zc.prototype.interfaces_ = function () {
        return []
    }, zc.prototype.getClass = function () {
        return zc
    };
    var jc = function (n) {
        function t() {
            var t = arguments[0], e = arguments[1];
            n.call(this, t, e)
        }

        return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.setEdgeRing = function (t, e) {
            t.setMinEdgeRing(e)
        }, t.prototype.getNext = function (t) {
            return t.getNextMin()
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(zc), Xc = function (n) {
        function t() {
            var t = arguments[0], e = arguments[1];
            n.call(this, t, e)
        }

        return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.buildMinimalRings = function () {
            var t = new fu, e = this._startDe;
            do {
                if (null === e.getMinEdgeRing()) {
                    var n = new jc(e, this._geometryFactory);
                    t.add(n)
                }
                e = e.getNext()
            } while (e !== this._startDe);
            return t
        }, t.prototype.setEdgeRing = function (t, e) {
            t.setEdgeRing(e)
        }, t.prototype.linkDirectedEdgesForMinimalEdgeRings = function () {
            for (var t = this._startDe; t.getNode().getEdges().linkMinimalDirectedEdges(this), (t = t.getNext()) !== this._startDe;) ;
        }, t.prototype.getNext = function (t) {
            return t.getNext()
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(zc), Uc = function () {
        if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ; else if (1 === arguments.length) {
            var t = arguments[0];
            this._label = t
        }
    };
    Uc.prototype.setVisited = function (t) {
        this._isVisited = t
    }, Uc.prototype.setInResult = function (t) {
        this._isInResult = t
    }, Uc.prototype.isCovered = function () {
        return this._isCovered
    }, Uc.prototype.isCoveredSet = function () {
        return this._isCoveredSet
    }, Uc.prototype.setLabel = function (t) {
        this._label = t
    }, Uc.prototype.getLabel = function () {
        return this._label
    }, Uc.prototype.setCovered = function (t) {
        this._isCovered = t, this._isCoveredSet = !0
    }, Uc.prototype.updateIM = function (t) {
        Xa.isTrue(2 <= this._label.getGeometryCount(), "found partial label"), this.computeIM(t)
    }, Uc.prototype.isInResult = function () {
        return this._isInResult
    }, Uc.prototype.isVisited = function () {
        return this._isVisited
    }, Uc.prototype.interfaces_ = function () {
        return []
    }, Uc.prototype.getClass = function () {
        return Uc
    };
    var Yc = function (n) {
        function i() {
            n.call(this), this._coord = null, this._edges = null;
            var t = arguments[0], e = arguments[1];
            this._coord = t, this._edges = e, this._label = new kc(0, ya.NONE)
        }

        return n && (i.__proto__ = n), ((i.prototype = Object.create(n && n.prototype)).constructor = i).prototype.isIncidentEdgeInResult = function () {
            for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) if (t.next().getEdge().isInResult()) return !0;
            return !1
        }, i.prototype.isIsolated = function () {
            return 1 === this._label.getGeometryCount()
        }, i.prototype.getCoordinate = function () {
            return this._coord
        }, i.prototype.print = function (t) {
            t.println("node " + this._coord + " lbl: " + this._label)
        }, i.prototype.computeIM = function (t) {
        }, i.prototype.computeMergedLocation = function (t, e) {
            var n = ya.NONE;
            if (n = this._label.getLocation(e), !t.isNull(e)) {
                var r = t.getLocation(e);
                n !== ya.BOUNDARY && (n = r)
            }
            return n
        }, i.prototype.setLabel = function () {
            if (2 !== arguments.length) return n.prototype.setLabel.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            null === this._label ? this._label = new kc(t, e) : this._label.setLocation(t, e)
        }, i.prototype.getEdges = function () {
            return this._edges
        }, i.prototype.mergeLabel = function () {
            if (arguments[0] instanceof i) {
                var t = arguments[0];
                this.mergeLabel(t._label)
            } else if (arguments[0] instanceof kc) for (var e = arguments[0], n = 0; n < 2; n++) {
                var r = this.computeMergedLocation(e, n);
                this._label.getLocation(n) === ya.NONE && this._label.setLocation(n, r)
            }
        }, i.prototype.add = function (t) {
            this._edges.insert(t), t.setNode(this)
        }, i.prototype.setLabelBoundary = function (t) {
            if (null === this._label) return null;
            var e = ya.NONE;
            null !== this._label && (e = this._label.getLocation(t));
            var n = null;
            switch (e) {
                case ya.BOUNDARY:
                    n = ya.INTERIOR;
                    break;
                case ya.INTERIOR:
                default:
                    n = ya.BOUNDARY
            }
            this._label.setLocation(t, n)
        }, i.prototype.interfaces_ = function () {
            return []
        }, i.prototype.getClass = function () {
            return i
        }, i
    }(Uc), Vc = function () {
        this.nodeMap = new Ru, this.nodeFact = null;
        var t = arguments[0];
        this.nodeFact = t
    };
    Vc.prototype.find = function (t) {
        return this.nodeMap.get(t)
    }, Vc.prototype.addNode = function () {
        if (arguments[0] instanceof pa) {
            var t = arguments[0], e = this.nodeMap.get(t);
            return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e
        }
        if (arguments[0] instanceof Yc) {
            var n = arguments[0], r = this.nodeMap.get(n.getCoordinate());
            return null === r ? (this.nodeMap.put(n.getCoordinate(), n), n) : (r.mergeLabel(n), r)
        }
    }, Vc.prototype.print = function (t) {
        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
    }, Vc.prototype.iterator = function () {
        return this.nodeMap.values().iterator()
    }, Vc.prototype.values = function () {
        return this.nodeMap.values()
    }, Vc.prototype.getBoundaryNodes = function (t) {
        for (var e = new fu, n = this.iterator(); n.hasNext();) {
            var r = n.next();
            r.getLabel().getLocation(t) === ya.BOUNDARY && e.add(r)
        }
        return e
    }, Vc.prototype.add = function (t) {
        var e = t.getCoordinate();
        this.addNode(e).add(t)
    }, Vc.prototype.interfaces_ = function () {
        return []
    }, Vc.prototype.getClass = function () {
        return Vc
    };
    var Hc = function () {
    }, Wc = {NE: {configurable: !0}, NW: {configurable: !0}, SW: {configurable: !0}, SE: {configurable: !0}};
    Hc.prototype.interfaces_ = function () {
        return []
    }, Hc.prototype.getClass = function () {
        return Hc
    }, Hc.isNorthern = function (t) {
        return t === Hc.NE || t === Hc.NW
    }, Hc.isOpposite = function (t, e) {
        return t !== e && 2 == (t - e + 4) % 4
    }, Hc.commonHalfPlane = function (t, e) {
        if (t === e) return t;
        if (2 == (t - e + 4) % 4) return -1;
        var n = t < e ? t : e;
        return 0 === n && 3 === (e < t ? t : e) ? 3 : n
    }, Hc.isInHalfPlane = function (t, e) {
        return e === Hc.SE ? t === Hc.SE || t === Hc.SW : t === e || t === e + 1
    }, Hc.quadrant = function () {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t = arguments[0], e = arguments[1];
            if (0 === t && 0 === e) throw new oa("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
            return 0 <= t ? 0 <= e ? Hc.NE : Hc.SE : 0 <= e ? Hc.NW : Hc.SW
        }
        if (arguments[0] instanceof pa && arguments[1] instanceof pa) {
            var n = arguments[0], r = arguments[1];
            if (r.x === n.x && r.y === n.y) throw new oa("Cannot compute the quadrant for two identical points " + n);
            return r.x >= n.x ? r.y >= n.y ? Hc.NE : Hc.SE : r.y >= n.y ? Hc.NW : Hc.SW
        }
    }, Wc.NE.get = function () {
        return 0
    }, Wc.NW.get = function () {
        return 1
    }, Wc.SW.get = function () {
        return 2
    }, Wc.SE.get = function () {
        return 3
    }, Object.defineProperties(Hc, Wc);
    var Jc = function () {
        if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
            var t = arguments[0];
            this._edge = t
        } else if (3 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = arguments[2];
            this._edge = e, this.init(n, r), this._label = null
        } else if (4 === arguments.length) {
            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3];
            this._edge = i, this.init(o, s), this._label = a
        }
    };
    Jc.prototype.compareDirection = function (t) {
        return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : Ja.computeOrientation(t._p0, t._p1, this._p1)
    }, Jc.prototype.getDy = function () {
        return this._dy
    }, Jc.prototype.getCoordinate = function () {
        return this._p0
    }, Jc.prototype.setNode = function (t) {
        this._node = t
    }, Jc.prototype.print = function (t) {
        var e = Math.atan2(this._dy, this._dx), n = this.getClass().getName(), r = n.lastIndexOf("."),
            i = n.substring(r + 1);
        t.print("  " + i + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label)
    }, Jc.prototype.compareTo = function (t) {
        var e = t;
        return this.compareDirection(e)
    }, Jc.prototype.getDirectedCoordinate = function () {
        return this._p1
    }, Jc.prototype.getDx = function () {
        return this._dx
    }, Jc.prototype.getLabel = function () {
        return this._label
    }, Jc.prototype.getEdge = function () {
        return this._edge
    }, Jc.prototype.getQuadrant = function () {
        return this._quadrant
    }, Jc.prototype.getNode = function () {
        return this._node
    }, Jc.prototype.toString = function () {
        var t = Math.atan2(this._dy, this._dx), e = this.getClass().getName(), n = e.lastIndexOf(".");
        return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label
    }, Jc.prototype.computeLabel = function (t) {
    }, Jc.prototype.init = function (t, e) {
        this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Hc.quadrant(this._dx, this._dy), Xa.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found")
    }, Jc.prototype.interfaces_ = function () {
        return [ua]
    }, Jc.prototype.getClass = function () {
        return Jc
    };
    var Zc = function (r) {
        function t() {
            var t = arguments[0], e = arguments[1];
            if (r.call(this, t), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = e) this.init(t.getCoordinate(0), t.getCoordinate(1)); else {
                var n = t.getNumPoints() - 1;
                this.init(t.getCoordinate(n), t.getCoordinate(n - 1))
            }
            this.computeDirectedLabel()
        }

        return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.getNextMin = function () {
            return this._nextMin
        }, t.prototype.getDepth = function (t) {
            return this._depth[t]
        }, t.prototype.setVisited = function (t) {
            this._isVisited = t
        }, t.prototype.computeDirectedLabel = function () {
            this._label = new kc(this._edge.getLabel()), this._isForward || this._label.flip()
        }, t.prototype.getNext = function () {
            return this._next
        }, t.prototype.setDepth = function (t, e) {
            if (-999 !== this._depth[t] && this._depth[t] !== e) throw new Fc("assigned depths do not match", this.getCoordinate());
            this._depth[t] = e
        }, t.prototype.isInteriorAreaEdge = function () {
            for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, Oc.LEFT) === ya.INTERIOR && this._label.getLocation(e, Oc.RIGHT) === ya.INTERIOR || (t = !1);
            return t
        }, t.prototype.setNextMin = function (t) {
            this._nextMin = t
        }, t.prototype.print = function (t) {
            r.prototype.print.call(this, t), t.print(" " + this._depth[Oc.LEFT] + "/" + this._depth[Oc.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult")
        }, t.prototype.setMinEdgeRing = function (t) {
            this._minEdgeRing = t
        }, t.prototype.isLineEdge = function () {
            var t = this._label.isLine(0) || this._label.isLine(1),
                e = !this._label.isArea(0) || this._label.allPositionsEqual(0, ya.EXTERIOR),
                n = !this._label.isArea(1) || this._label.allPositionsEqual(1, ya.EXTERIOR);
            return t && e && n
        }, t.prototype.setEdgeRing = function (t) {
            this._edgeRing = t
        }, t.prototype.getMinEdgeRing = function () {
            return this._minEdgeRing
        }, t.prototype.getDepthDelta = function () {
            var t = this._edge.getDepthDelta();
            return this._isForward || (t = -t), t
        }, t.prototype.setInResult = function (t) {
            this._isInResult = t
        }, t.prototype.getSym = function () {
            return this._sym
        }, t.prototype.isForward = function () {
            return this._isForward
        }, t.prototype.getEdge = function () {
            return this._edge
        }, t.prototype.printEdge = function (t) {
            this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t)
        }, t.prototype.setSym = function (t) {
            this._sym = t
        }, t.prototype.setVisitedEdge = function (t) {
            this.setVisited(t), this._sym.setVisited(t)
        }, t.prototype.setEdgeDepths = function (t, e) {
            var n = this.getEdge().getDepthDelta();
            this._isForward || (n = -n);
            var r = 1;
            t === Oc.LEFT && (r = -1);
            var i = Oc.opposite(t), o = e + n * r;
            this.setDepth(t, e), this.setDepth(i, o)
        }, t.prototype.getEdgeRing = function () {
            return this._edgeRing
        }, t.prototype.isInResult = function () {
            return this._isInResult
        }, t.prototype.setNext = function (t) {
            this._next = t
        }, t.prototype.isVisited = function () {
            return this._isVisited
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t.depthFactor = function (t, e) {
            return t === ya.EXTERIOR && e === ya.INTERIOR ? 1 : t === ya.INTERIOR && e === ya.EXTERIOR ? -1 : 0
        }, t
    }(Jc), Kc = function () {
    };
    Kc.prototype.createNode = function (t) {
        return new Yc(t, null)
    }, Kc.prototype.interfaces_ = function () {
        return []
    }, Kc.prototype.getClass = function () {
        return Kc
    };
    var Qc = function () {
        if (this._edges = new fu, this._nodes = null, this._edgeEndList = new fu, 0 === arguments.length) this._nodes = new Vc(new Kc); else if (1 === arguments.length) {
            var t = arguments[0];
            this._nodes = new Vc(t)
        }
    };
    Qc.prototype.printEdges = function (t) {
        t.println("Edges:");
        for (var e = 0; e < this._edges.size(); e++) {
            t.println("edge " + e + ":");
            var n = this._edges.get(e);
            n.print(t), n.eiList.print(t)
        }
    }, Qc.prototype.find = function (t) {
        return this._nodes.find(t)
    }, Qc.prototype.addNode = function () {
        if (arguments[0] instanceof Yc) {
            var t = arguments[0];
            return this._nodes.addNode(t)
        }
        if (arguments[0] instanceof pa) {
            var e = arguments[0];
            return this._nodes.addNode(e)
        }
    }, Qc.prototype.getNodeIterator = function () {
        return this._nodes.iterator()
    }, Qc.prototype.linkResultDirectedEdges = function () {
        for (var t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkResultDirectedEdges()
    }, Qc.prototype.debugPrintln = function (t) {
        Ra.out.println(t)
    }, Qc.prototype.isBoundaryNode = function (t, e) {
        var n = this._nodes.find(e);
        if (null === n) return !1;
        var r = n.getLabel();
        return null !== r && r.getLocation(t) === ya.BOUNDARY
    }, Qc.prototype.linkAllDirectedEdges = function () {
        for (var t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkAllDirectedEdges()
    }, Qc.prototype.matchInSameDirection = function (t, e, n, r) {
        return !!t.equals(n) && Ja.computeOrientation(t, e, r) === Ja.COLLINEAR && Hc.quadrant(t, e) === Hc.quadrant(n, r)
    }, Qc.prototype.getEdgeEnds = function () {
        return this._edgeEndList
    }, Qc.prototype.debugPrint = function (t) {
        Ra.out.print(t)
    }, Qc.prototype.getEdgeIterator = function () {
        return this._edges.iterator()
    }, Qc.prototype.findEdgeInSameDirection = function (t, e) {
        for (var n = 0; n < this._edges.size(); n++) {
            var r = this._edges.get(n), i = r.getCoordinates();
            if (this.matchInSameDirection(t, e, i[0], i[1])) return r;
            if (this.matchInSameDirection(t, e, i[i.length - 1], i[i.length - 2])) return r
        }
        return null
    }, Qc.prototype.insertEdge = function (t) {
        this._edges.add(t)
    }, Qc.prototype.findEdgeEnd = function (t) {
        for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
            var n = e.next();
            if (n.getEdge() === t) return n
        }
        return null
    }, Qc.prototype.addEdges = function (t) {
        for (var e = t.iterator(); e.hasNext();) {
            var n = e.next();
            this._edges.add(n);
            var r = new Zc(n, !0), i = new Zc(n, !1);
            r.setSym(i), i.setSym(r), this.add(r), this.add(i)
        }
    }, Qc.prototype.add = function (t) {
        this._nodes.add(t), this._edgeEndList.add(t)
    }, Qc.prototype.getNodes = function () {
        return this._nodes.values()
    }, Qc.prototype.findEdge = function (t, e) {
        for (var n = 0; n < this._edges.size(); n++) {
            var r = this._edges.get(n), i = r.getCoordinates();
            if (t.equals(i[0]) && e.equals(i[1])) return r
        }
        return null
    }, Qc.prototype.interfaces_ = function () {
        return []
    }, Qc.prototype.getClass = function () {
        return Qc
    }, Qc.linkResultDirectedEdges = function (t) {
        for (var e = t.iterator(); e.hasNext();) e.next().getEdges().linkResultDirectedEdges()
    };
    var $c = function () {
        this._geometryFactory = null, this._shellList = new fu;
        var t = arguments[0];
        this._geometryFactory = t
    };
    $c.prototype.sortShellsAndHoles = function (t, e, n) {
        for (var r = t.iterator(); r.hasNext();) {
            var i = r.next();
            i.isHole() ? n.add(i) : e.add(i)
        }
    }, $c.prototype.computePolygons = function (t) {
        for (var e = new fu, n = t.iterator(); n.hasNext();) {
            var r = n.next().toPolygon(this._geometryFactory);
            e.add(r)
        }
        return e
    }, $c.prototype.placeFreeHoles = function (t, e) {
        for (var n = e.iterator(); n.hasNext();) {
            var r = n.next();
            if (null === r.getShell()) {
                var i = this.findEdgeRingContaining(r, t);
                if (null === i) throw new Fc("unable to assign hole to a shell", r.getCoordinate(0));
                r.setShell(i)
            }
        }
    }, $c.prototype.buildMinimalEdgeRings = function (t, e, n) {
        for (var r = new fu, i = t.iterator(); i.hasNext();) {
            var o = i.next();
            if (2 < o.getMaxNodeDegree()) {
                o.linkDirectedEdgesForMinimalEdgeRings();
                var s = o.buildMinimalRings(), a = this.findShell(s);
                null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s)
            } else r.add(o)
        }
        return r
    }, $c.prototype.containsPoint = function (t) {
        for (var e = this._shellList.iterator(); e.hasNext();) if (e.next().containsPoint(t)) return !0;
        return !1
    }, $c.prototype.buildMaximalEdgeRings = function (t) {
        for (var e = new fu, n = t.iterator(); n.hasNext();) {
            var r = n.next();
            if (r.isInResult() && r.getLabel().isArea() && null === r.getEdgeRing()) {
                var i = new Xc(r, this._geometryFactory);
                e.add(i), i.setInResult()
            }
        }
        return e
    }, $c.prototype.placePolygonHoles = function (t, e) {
        for (var n = e.iterator(); n.hasNext();) {
            var r = n.next();
            r.isHole() && r.setShell(t)
        }
    }, $c.prototype.getPolygons = function () {
        return this.computePolygons(this._shellList)
    }, $c.prototype.findEdgeRingContaining = function (t, e) {
        for (var n = t.getLinearRing(), r = n.getEnvelopeInternal(), i = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
            var u = a.next(), c = u.getLinearRing(), h = c.getEnvelopeInternal();
            null !== o && (s = o.getLinearRing().getEnvelopeInternal());
            var l = !1;
            h.contains(r) && Ja.isPointInRing(i, c.getCoordinates()) && (l = !0), l && (null === o || s.contains(h)) && (o = u)
        }
        return o
    }, $c.prototype.findShell = function (t) {
        for (var e = 0, n = null, r = t.iterator(); r.hasNext();) {
            var i = r.next();
            i.isHole() || (n = i, e++)
        }
        return Xa.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n
    }, $c.prototype.add = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.add(t.getEdgeEnds(), t.getNodes())
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            Qc.linkResultDirectedEdges(n);
            var r = this.buildMaximalEdgeRings(e), i = new fu, o = this.buildMinimalEdgeRings(r, this._shellList, i);
            this.sortShellsAndHoles(o, this._shellList, i), this.placeFreeHoles(this._shellList, i)
        }
    }, $c.prototype.interfaces_ = function () {
        return []
    }, $c.prototype.getClass = function () {
        return $c
    };
    var th = function () {
    };
    th.prototype.getBounds = function () {
    }, th.prototype.interfaces_ = function () {
        return []
    }, th.prototype.getClass = function () {
        return th
    };
    var eh = function () {
        this._bounds = null, this._item = null;
        var t = arguments[0], e = arguments[1];
        this._bounds = t, this._item = e
    };
    eh.prototype.getItem = function () {
        return this._item
    }, eh.prototype.getBounds = function () {
        return this._bounds
    }, eh.prototype.interfaces_ = function () {
        return [th, la]
    }, eh.prototype.getClass = function () {
        return eh
    };
    var nh = function () {
        this._size = null, this._items = null, this._size = 0, this._items = new fu, this._items.add(null)
    };
    nh.prototype.poll = function () {
        if (this.isEmpty()) return null;
        var t = this._items.get(1);
        return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t
    }, nh.prototype.size = function () {
        return this._size
    }, nh.prototype.reorder = function (t) {
        for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));
        this._items.set(t, n)
    }, nh.prototype.clear = function () {
        this._size = 0, this._items.clear()
    }, nh.prototype.isEmpty = function () {
        return 0 === this._size
    }, nh.prototype.add = function (t) {
        this._items.add(null), this._size += 1;
        var e = this._size;
        for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));
        this._items.set(e, t)
    }, nh.prototype.interfaces_ = function () {
        return []
    }, nh.prototype.getClass = function () {
        return nh
    };
    var rh = function () {
    };
    rh.prototype.visitItem = function (t) {
    }, rh.prototype.interfaces_ = function () {
        return []
    }, rh.prototype.getClass = function () {
        return rh
    };
    var ih = function () {
    };
    ih.prototype.insert = function (t, e) {
    }, ih.prototype.remove = function (t, e) {
    }, ih.prototype.query = function () {
    }, ih.prototype.interfaces_ = function () {
        return []
    }, ih.prototype.getClass = function () {
        return ih
    };
    var oh = function () {
        if (this._childBoundables = new fu, this._bounds = null, this._level = null, 0 === arguments.length) ; else if (1 === arguments.length) {
            var t = arguments[0];
            this._level = t
        }
    }, sh = {serialVersionUID: {configurable: !0}};
    oh.prototype.getLevel = function () {
        return this._level
    }, oh.prototype.size = function () {
        return this._childBoundables.size()
    }, oh.prototype.getChildBoundables = function () {
        return this._childBoundables
    }, oh.prototype.addChildBoundable = function (t) {
        Xa.isTrue(null === this._bounds), this._childBoundables.add(t)
    }, oh.prototype.isEmpty = function () {
        return this._childBoundables.isEmpty()
    }, oh.prototype.getBounds = function () {
        return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds
    }, oh.prototype.interfaces_ = function () {
        return [th, la]
    }, oh.prototype.getClass = function () {
        return oh
    }, sh.serialVersionUID.get = function () {
        return 0x5a1e55ec41369800
    }, Object.defineProperties(oh, sh);
    var ah = function () {
    };
    ah.reverseOrder = function () {
        return {
            compare: function (t, e) {
                return e.compareTo(t)
            }
        }
    }, ah.min = function (t) {
        return ah.sort(t), t.get(0)
    }, ah.sort = function (t, e) {
        var n = t.toArray();
        e ? qu.sort(n, e) : qu.sort(n);
        for (var r = t.iterator(), i = 0, o = n.length; i < o; i++) r.next(), r.set(n[i])
    }, ah.singletonList = function (t) {
        var e = new fu;
        return e.add(t), e
    };
    var uh = function () {
        this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
        var t = arguments[0], e = arguments[1], n = arguments[2];
        this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance()
    };
    uh.prototype.expandToQueue = function (t, e) {
        var n = uh.isComposite(this._boundable1), r = uh.isComposite(this._boundable2);
        if (n && r) return uh.area(this._boundable1) > uh.area(this._boundable2) ? this.expand(this._boundable1, this._boundable2, t, e) : this.expand(this._boundable2, this._boundable1, t, e), null;
        if (n) return this.expand(this._boundable1, this._boundable2, t, e), null;
        if (r) return this.expand(this._boundable2, this._boundable1, t, e), null;
        throw new oa("neither boundable is composite")
    }, uh.prototype.isLeaves = function () {
        return !(uh.isComposite(this._boundable1) || uh.isComposite(this._boundable2))
    }, uh.prototype.compareTo = function (t) {
        var e = t;
        return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
    }, uh.prototype.expand = function (t, e, n, r) {
        for (var i = t.getChildBoundables().iterator(); i.hasNext();) {
            var o = i.next(), s = new uh(o, e, this._itemDistance);
            s.getDistance() < r && n.add(s)
        }
    }, uh.prototype.getBoundable = function (t) {
        return 0 === t ? this._boundable1 : this._boundable2
    }, uh.prototype.getDistance = function () {
        return this._distance
    }, uh.prototype.distance = function () {
        return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds())
    }, uh.prototype.interfaces_ = function () {
        return [ua]
    }, uh.prototype.getClass = function () {
        return uh
    }, uh.area = function (t) {
        return t.getBounds().getArea()
    }, uh.isComposite = function (t) {
        return t instanceof oh
    };
    var ch = function t() {
        if (this._root = null, this._built = !1, this._itemBoundables = new fu, this._nodeCapacity = null, 0 === arguments.length) {
            var e = t.DEFAULT_NODE_CAPACITY;
            this._nodeCapacity = e
        } else if (1 === arguments.length) {
            var n = arguments[0];
            Xa.isTrue(1 < n, "Node capacity must be greater than 1"), this._nodeCapacity = n
        }
    }, hh = {
        IntersectsOp: {configurable: !0},
        serialVersionUID: {configurable: !0},
        DEFAULT_NODE_CAPACITY: {configurable: !0}
    };
    ch.prototype.getNodeCapacity = function () {
        return this._nodeCapacity
    }, ch.prototype.lastNode = function (t) {
        return t.get(t.size() - 1)
    }, ch.prototype.size = function () {
        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
        if (1 === arguments.length) {
            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
                var n = e.next();
                n instanceof oh ? t += this.size(n) : n instanceof eh && (t += 1)
            }
            return t
        }
    }, ch.prototype.removeItem = function (t, e) {
        for (var n = null, r = t.getChildBoundables().iterator(); r.hasNext();) {
            var i = r.next();
            i instanceof eh && i.getItem() === e && (n = i)
        }
        return null !== n && (t.getChildBoundables().remove(n), !0)
    }, ch.prototype.itemsTree = function () {
        if (0 === arguments.length) {
            this.build();
            var t = this.itemsTree(this._root);
            return null === t ? new fu : t
        }
        if (1 === arguments.length) {
            for (var e = arguments[0], n = new fu, r = e.getChildBoundables().iterator(); r.hasNext();) {
                var i = r.next();
                if (i instanceof oh) {
                    var o = this.itemsTree(i);
                    null !== o && n.add(o)
                } else i instanceof eh ? n.add(i.getItem()) : Xa.shouldNeverReachHere()
            }
            return n.size() <= 0 ? null : n
        }
    }, ch.prototype.insert = function (t, e) {
        Xa.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new eh(t, e))
    }, ch.prototype.boundablesAtLevel = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = new fu;
            return this.boundablesAtLevel(t, this._root, e), e
        }
        if (3 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2];
            if (Xa.isTrue(-2 < n), r.getLevel() === n) return i.add(r), null;
            for (var o = r.getChildBoundables().iterator(); o.hasNext();) {
                var s = o.next();
                s instanceof oh ? this.boundablesAtLevel(n, s, i) : (Xa.isTrue(s instanceof eh), -1 === n && i.add(s))
            }
            return null
        }
    }, ch.prototype.query = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.build();
            var e = new fu;
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.query(t, this._root, e), e
        }
        if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.query(n, this._root, r)
        } else if (3 === arguments.length) if (ma(arguments[2], rh) && arguments[0] instanceof Object && arguments[1] instanceof oh) for (var i = arguments[0], o = arguments[1], s = arguments[2], a = o.getChildBoundables(), u = 0; u < a.size(); u++) {
            var c = a.get(u);
            this.getIntersectsOp().intersects(c.getBounds(), i) && (c instanceof oh ? this.query(i, c, s) : c instanceof eh ? s.visitItem(c.getItem()) : Xa.shouldNeverReachHere())
        } else if (ma(arguments[2], lu) && arguments[0] instanceof Object && arguments[1] instanceof oh) for (var h = arguments[0], l = arguments[1], p = arguments[2], f = l.getChildBoundables(), g = 0; g < f.size(); g++) {
            var d = f.get(g);
            this.getIntersectsOp().intersects(d.getBounds(), h) && (d instanceof oh ? this.query(h, d, p) : d instanceof eh ? p.add(d.getItem()) : Xa.shouldNeverReachHere())
        }
    }, ch.prototype.build = function () {
        if (this._built) return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0
    }, ch.prototype.getRoot = function () {
        return this.build(), this._root
    }, ch.prototype.remove = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e)
        }
        if (3 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2], o = this.removeItem(r, i);
            if (o) return !0;
            for (var s = null, a = r.getChildBoundables().iterator(); a.hasNext();) {
                var u = a.next();
                if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof oh && (o = this.remove(n, u, i))) {
                    s = u;
                    break
                }
            }
            return null !== s && s.getChildBoundables().isEmpty() && r.getChildBoundables().remove(s), o
        }
    }, ch.prototype.createHigherLevels = function (t, e) {
        Xa.isTrue(!t.isEmpty());
        var n = this.createParentBoundables(t, e + 1);
        return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1)
    }, ch.prototype.depth = function () {
        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
        if (1 === arguments.length) {
            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
                var n = e.next();
                if (n instanceof oh) {
                    var r = this.depth(n);
                    t < r && (t = r)
                }
            }
            return t + 1
        }
    }, ch.prototype.createParentBoundables = function (t, e) {
        Xa.isTrue(!t.isEmpty());
        var n = new fu;
        n.add(this.createNode(e));
        var r = new fu(t);
        ah.sort(r, this.getComparator());
        for (var i = r.iterator(); i.hasNext();) {
            var o = i.next();
            this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(o)
        }
        return n
    }, ch.prototype.isEmpty = function () {
        return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty()
    }, ch.prototype.interfaces_ = function () {
        return [la]
    }, ch.prototype.getClass = function () {
        return ch
    }, ch.compareDoubles = function (t, e) {
        return e < t ? 1 : t < e ? -1 : 0
    }, hh.IntersectsOp.get = function () {
        return lh
    }, hh.serialVersionUID.get = function () {
        return -0x35ef64c82d4c5400
    }, hh.DEFAULT_NODE_CAPACITY.get = function () {
        return 10
    }, Object.defineProperties(ch, hh);
    var lh = function () {
    }, ph = function () {
    };
    ph.prototype.distance = function (t, e) {
    }, ph.prototype.interfaces_ = function () {
        return []
    }, ph.prototype.getClass = function () {
        return ph
    };
    var fh = function (c) {
        function _(t) {
            t = t || _.DEFAULT_NODE_CAPACITY, c.call(this, t)
        }

        c && (_.__proto__ = c);
        var t = {
            STRtreeNode: {configurable: !0},
            serialVersionUID: {configurable: !0},
            xComparator: {configurable: !0},
            yComparator: {configurable: !0},
            intersectsOp: {configurable: !0},
            DEFAULT_NODE_CAPACITY: {configurable: !0}
        };
        return ((_.prototype = Object.create(c && c.prototype)).constructor = _).prototype.createParentBoundablesFromVerticalSlices = function (t, e) {
            Xa.isTrue(0 < t.length);
            for (var n = new fu, r = 0; r < t.length; r++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[r], e));
            return n
        }, _.prototype.createNode = function (t) {
            return new gh(t)
        }, _.prototype.size = function () {
            return 0 === arguments.length ? c.prototype.size.call(this) : c.prototype.size.apply(this, arguments)
        }, _.prototype.insert = function () {
            if (2 !== arguments.length) return c.prototype.insert.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            if (t.isNull()) return null;
            c.prototype.insert.call(this, t, e)
        }, _.prototype.getIntersectsOp = function () {
            return _.intersectsOp
        }, _.prototype.verticalSlices = function (t, e) {
            for (var n = Math.trunc(Math.ceil(t.size() / e)), r = new Array(e).fill(null), i = t.iterator(), o = 0; o < e; o++) {
                r[o] = new fu;
                for (var s = 0; i.hasNext() && s < n;) {
                    var a = i.next();
                    r[o].add(a), s++
                }
            }
            return r
        }, _.prototype.query = function () {
            if (1 === arguments.length) {
                var t = arguments[0];
                return c.prototype.query.call(this, t)
            }
            if (2 === arguments.length) {
                var e = arguments[0], n = arguments[1];
                c.prototype.query.call(this, e, n)
            } else if (3 === arguments.length) if (ma(arguments[2], rh) && arguments[0] instanceof Object && arguments[1] instanceof oh) {
                var r = arguments[0], i = arguments[1], o = arguments[2];
                c.prototype.query.call(this, r, i, o)
            } else if (ma(arguments[2], lu) && arguments[0] instanceof Object && arguments[1] instanceof oh) {
                var s = arguments[0], a = arguments[1], u = arguments[2];
                c.prototype.query.call(this, s, a, u)
            }
        }, _.prototype.getComparator = function () {
            return _.yComparator
        }, _.prototype.createParentBoundablesFromVerticalSlice = function (t, e) {
            return c.prototype.createParentBoundables.call(this, t, e)
        }, _.prototype.remove = function () {
            if (2 !== arguments.length) return c.prototype.remove.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            return c.prototype.remove.call(this, t, e)
        }, _.prototype.depth = function () {
            return 0 === arguments.length ? c.prototype.depth.call(this) : c.prototype.depth.apply(this, arguments)
        }, _.prototype.createParentBoundables = function (t, e) {
            Xa.isTrue(!t.isEmpty());
            var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())), r = new fu(t);
            ah.sort(r, _.xComparator);
            var i = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(n))));
            return this.createParentBoundablesFromVerticalSlices(i, e)
        }, _.prototype.nearestNeighbour = function () {
            if (1 === arguments.length) {
                if (ma(arguments[0], ph)) {
                    var t = arguments[0], e = new uh(this.getRoot(), this.getRoot(), t);
                    return this.nearestNeighbour(e)
                }
                if (arguments[0] instanceof uh) {
                    var n = arguments[0];
                    return this.nearestNeighbour(n, sa.POSITIVE_INFINITY)
                }
            } else if (2 === arguments.length) {
                if (arguments[0] instanceof _ && ma(arguments[1], ph)) {
                    var r = arguments[0], i = arguments[1], o = new uh(this.getRoot(), r.getRoot(), i);
                    return this.nearestNeighbour(o)
                }
                if (arguments[0] instanceof uh && "number" == typeof arguments[1]) {
                    var s = arguments[0], a = arguments[1], u = null, c = new nh;
                    for (c.add(s); !c.isEmpty() && 0 < a;) {
                        var h = c.poll(), l = h.getDistance();
                        if (a <= l) break;
                        h.isLeaves() ? (a = l, u = h) : h.expandToQueue(c, a)
                    }
                    return [u.getBoundable(0).getItem(), u.getBoundable(1).getItem()]
                }
            } else if (3 === arguments.length) {
                var p = arguments[0], f = arguments[1], g = arguments[2], d = new eh(p, f),
                    y = new uh(this.getRoot(), d, g);
                return this.nearestNeighbour(y)[0]
            }
        }, _.prototype.interfaces_ = function () {
            return [ih, la]
        }, _.prototype.getClass = function () {
            return _
        }, _.centreX = function (t) {
            return _.avg(t.getMinX(), t.getMaxX())
        }, _.avg = function (t, e) {
            return (t + e) / 2
        }, _.centreY = function (t) {
            return _.avg(t.getMinY(), t.getMaxY())
        }, t.STRtreeNode.get = function () {
            return gh
        }, t.serialVersionUID.get = function () {
            return 0x39920f7d5f261e0
        }, t.xComparator.get = function () {
            return {
                interfaces_: function () {
                    return [ha]
                }, compare: function (t, e) {
                    return c.compareDoubles(_.centreX(t.getBounds()), _.centreX(e.getBounds()))
                }
            }
        }, t.yComparator.get = function () {
            return {
                interfaces_: function () {
                    return [ha]
                }, compare: function (t, e) {
                    return c.compareDoubles(_.centreY(t.getBounds()), _.centreY(e.getBounds()))
                }
            }
        }, t.intersectsOp.get = function () {
            return {
                interfaces_: function () {
                    return [c.IntersectsOp]
                }, intersects: function (t, e) {
                    return t.intersects(e)
                }
            }
        }, t.DEFAULT_NODE_CAPACITY.get = function () {
            return 10
        }, Object.defineProperties(_, t), _
    }(ch), gh = function (e) {
        function t() {
            var t = arguments[0];
            e.call(this, t)
        }

        return e && (t.__proto__ = e), ((t.prototype = Object.create(e && e.prototype)).constructor = t).prototype.computeBounds = function () {
            for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
                var n = e.next();
                null === t ? t = new Aa(n.getBounds()) : t.expandToInclude(n.getBounds())
            }
            return t
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(oh), dh = function () {
    };
    dh.prototype.interfaces_ = function () {
        return []
    }, dh.prototype.getClass = function () {
        return dh
    }, dh.relativeSign = function (t, e) {
        return t < e ? -1 : e < t ? 1 : 0
    }, dh.compare = function (t, e, n) {
        if (e.equals2D(n)) return 0;
        var r = dh.relativeSign(e.x, n.x), i = dh.relativeSign(e.y, n.y);
        switch (t) {
            case 0:
                return dh.compareValue(r, i);
            case 1:
                return dh.compareValue(i, r);
            case 2:
                return dh.compareValue(i, -r);
            case 3:
                return dh.compareValue(-r, i);
            case 4:
                return dh.compareValue(-r, -i);
            case 5:
                return dh.compareValue(-i, -r);
            case 6:
                return dh.compareValue(-i, r);
            case 7:
                return dh.compareValue(r, -i)
        }
        return Xa.shouldNeverReachHere("invalid octant value"), 0
    }, dh.compareValue = function (t, e) {
        return t < 0 ? -1 : 0 < t ? 1 : e < 0 ? -1 : 0 < e ? 1 : 0
    };
    var yh = function () {
        this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
        var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3];
        this._segString = t, this.coord = new pa(e), this.segmentIndex = n, this._segmentOctant = r, this._isInterior = !e.equals2D(t.getCoordinate(n))
    };
    yh.prototype.getCoordinate = function () {
        return this.coord
    }, yh.prototype.print = function (t) {
        t.print(this.coord), t.print(" seg # = " + this.segmentIndex)
    }, yh.prototype.compareTo = function (t) {
        var e = t;
        return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : dh.compare(this._segmentOctant, this.coord, e.coord)
    }, yh.prototype.isEndPoint = function (t) {
        return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t
    }, yh.prototype.isInterior = function () {
        return this._isInterior
    }, yh.prototype.interfaces_ = function () {
        return [ua]
    }, yh.prototype.getClass = function () {
        return yh
    };
    var _h = function () {
        this._nodeMap = new Ru, this._edge = null;
        var t = arguments[0];
        this._edge = t
    };
    _h.prototype.getSplitCoordinates = function () {
        var t = new du;
        this.addEndpoints();
        for (var e = this.iterator(), n = e.next(); e.hasNext();) {
            var r = e.next();
            this.addEdgeCoordinates(n, r, t), n = r
        }
        return t.toCoordinateArray()
    }, _h.prototype.addCollapsedNodes = function () {
        var t = new fu;
        this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
        for (var e = t.iterator(); e.hasNext();) {
            var n = e.next().intValue();
            this.add(this._edge.getCoordinate(n), n)
        }
    }, _h.prototype.print = function (t) {
        t.println("Intersections:");
        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
    }, _h.prototype.findCollapsesFromExistingVertices = function (t) {
        for (var e = 0; e < this._edge.size() - 2; e++) {
            var n = this._edge.getCoordinate(e), r = this._edge.getCoordinate(e + 2);
            n.equals2D(r) && t.add(new wa(e + 1))
        }
    }, _h.prototype.addEdgeCoordinates = function (t, e, n) {
        var r = this._edge.getCoordinate(e.segmentIndex), i = e.isInterior() || !e.coord.equals2D(r);
        n.add(new pa(t.coord), !1);
        for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) n.add(this._edge.getCoordinate(o));
        i && n.add(new pa(e.coord))
    }, _h.prototype.iterator = function () {
        return this._nodeMap.values().iterator()
    }, _h.prototype.addSplitEdges = function (t) {
        this.addEndpoints(), this.addCollapsedNodes();
        for (var e = this.iterator(), n = e.next(); e.hasNext();) {
            var r = e.next(), i = this.createSplitEdge(n, r);
            t.add(i), n = r
        }
    }, _h.prototype.findCollapseIndex = function (t, e, n) {
        if (!t.coord.equals2D(e.coord)) return !1;
        var r = e.segmentIndex - t.segmentIndex;
        return e.isInterior() || r--, 1 === r && (n[0] = t.segmentIndex + 1, !0)
    }, _h.prototype.findCollapsesFromInsertedNodes = function (t) {
        for (var e = new Array(1).fill(null), n = this.iterator(), r = n.next(); n.hasNext();) {
            var i = n.next();
            this.findCollapseIndex(r, i, e) && t.add(new wa(e[0])), r = i
        }
    }, _h.prototype.getEdge = function () {
        return this._edge
    }, _h.prototype.addEndpoints = function () {
        var t = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t)
    }, _h.prototype.createSplitEdge = function (t, e) {
        var n = e.segmentIndex - t.segmentIndex + 2, r = this._edge.getCoordinate(e.segmentIndex),
            i = e.isInterior() || !e.coord.equals2D(r);
        i || n--;
        var o = new Array(n).fill(null), s = 0;
        o[s++] = new pa(t.coord);
        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this._edge.getCoordinate(a);
        return i && (o[s] = new pa(e.coord)), new Eh(o, this._edge.getData())
    }, _h.prototype.add = function (t, e) {
        var n = new yh(this._edge, t, e, this._edge.getSegmentOctant(e)), r = this._nodeMap.get(n);
        return null !== r ? (Xa.isTrue(r.coord.equals2D(t), "Found equal nodes with different coordinates"), r) : (this._nodeMap.put(n, n), n)
    }, _h.prototype.checkSplitEdgesCorrectness = function (t) {
        var e = this._edge.getCoordinates(), n = t.get(0).getCoordinate(0);
        if (!n.equals2D(e[0])) throw new za("bad split edge start point at " + n);
        var r = t.get(t.size() - 1).getCoordinates(), i = r[r.length - 1];
        if (!i.equals2D(e[e.length - 1])) throw new za("bad split edge end point at " + i)
    }, _h.prototype.interfaces_ = function () {
        return []
    }, _h.prototype.getClass = function () {
        return _h
    };
    var mh = function () {
    };
    mh.prototype.interfaces_ = function () {
        return []
    }, mh.prototype.getClass = function () {
        return mh
    }, mh.octant = function () {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t = arguments[0], e = arguments[1];
            if (0 === t && 0 === e) throw new oa("Cannot compute the octant for point ( " + t + ", " + e + " )");
            var n = Math.abs(t), r = Math.abs(e);
            return 0 <= t ? 0 <= e ? r <= n ? 0 : 1 : r <= n ? 7 : 6 : 0 <= e ? r <= n ? 3 : 2 : r <= n ? 4 : 5
        }
        if (arguments[0] instanceof pa && arguments[1] instanceof pa) {
            var i = arguments[0], o = arguments[1], s = o.x - i.x, a = o.y - i.y;
            if (0 === s && 0 === a) throw new oa("Cannot compute the octant for two identical points " + i);
            return mh.octant(s, a)
        }
    };
    var vh = function () {
    };
    vh.prototype.getCoordinates = function () {
    }, vh.prototype.size = function () {
    }, vh.prototype.getCoordinate = function (t) {
    }, vh.prototype.isClosed = function () {
    }, vh.prototype.setData = function (t) {
    }, vh.prototype.getData = function () {
    }, vh.prototype.interfaces_ = function () {
        return []
    }, vh.prototype.getClass = function () {
        return vh
    };
    var xh = function () {
    };
    xh.prototype.addIntersection = function (t, e) {
    }, xh.prototype.interfaces_ = function () {
        return [vh]
    }, xh.prototype.getClass = function () {
        return xh
    };
    var Eh = function () {
        this._nodeList = new _h(this), this._pts = null, this._data = null;
        var t = arguments[0], e = arguments[1];
        this._pts = t, this._data = e
    };
    Eh.prototype.getCoordinates = function () {
        return this._pts
    }, Eh.prototype.size = function () {
        return this._pts.length
    }, Eh.prototype.getCoordinate = function (t) {
        return this._pts[t]
    }, Eh.prototype.isClosed = function () {
        return this._pts[0].equals(this._pts[this._pts.length - 1])
    }, Eh.prototype.getSegmentOctant = function (t) {
        return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
    }, Eh.prototype.setData = function (t) {
        this._data = t
    }, Eh.prototype.safeOctant = function (t, e) {
        return t.equals2D(e) ? 0 : mh.octant(t, e)
    }, Eh.prototype.getData = function () {
        return this._data
    }, Eh.prototype.addIntersection = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            this.addIntersectionNode(t, e)
        } else if (4 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[3], o = new pa(n.getIntersection(i));
            this.addIntersection(o, r)
        }
    }, Eh.prototype.toString = function () {
        return ka.toLineString(new gc(this._pts))
    }, Eh.prototype.getNodeList = function () {
        return this._nodeList
    }, Eh.prototype.addIntersectionNode = function (t, e) {
        var n = e, r = n + 1;
        if (r < this._pts.length) {
            var i = this._pts[r];
            t.equals2D(i) && (n = r)
        }
        return this._nodeList.add(t, n)
    }, Eh.prototype.addIntersections = function (t, e, n) {
        for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r)
    }, Eh.prototype.interfaces_ = function () {
        return [xh]
    }, Eh.prototype.getClass = function () {
        return Eh
    }, Eh.getNodedSubstrings = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = new fu;
            return Eh.getNodedSubstrings(t, e), e
        }
        if (2 === arguments.length) for (var n = arguments[0], r = arguments[1], i = n.iterator(); i.hasNext();) i.next().getNodeList().addSplitEdges(r)
    };
    var wh = function () {
        if (this.p0 = null, this.p1 = null, 0 === arguments.length) this.p0 = new pa, this.p1 = new pa; else if (1 === arguments.length) {
            var t = arguments[0];
            this.p0 = new pa(t.p0), this.p1 = new pa(t.p1)
        } else if (2 === arguments.length) this.p0 = arguments[0], this.p1 = arguments[1]; else if (4 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = arguments[2], i = arguments[3];
            this.p0 = new pa(e, n), this.p1 = new pa(r, i)
        }
    }, bh = {serialVersionUID: {configurable: !0}};
    wh.prototype.minX = function () {
        return Math.min(this.p0.x, this.p1.x)
    }, wh.prototype.orientationIndex = function () {
        if (arguments[0] instanceof wh) {
            var t = arguments[0], e = Ja.orientationIndex(this.p0, this.p1, t.p0),
                n = Ja.orientationIndex(this.p0, this.p1, t.p1);
            return 0 <= e && 0 <= n ? Math.max(e, n) : e <= 0 && n <= 0 ? Math.max(e, n) : 0
        }
        if (arguments[0] instanceof pa) {
            var r = arguments[0];
            return Ja.orientationIndex(this.p0, this.p1, r)
        }
    }, wh.prototype.toGeometry = function (t) {
        return t.createLineString([this.p0, this.p1])
    }, wh.prototype.isVertical = function () {
        return this.p0.x === this.p1.x
    }, wh.prototype.equals = function (t) {
        if (!(t instanceof wh)) return !1;
        var e = t;
        return this.p0.equals(e.p0) && this.p1.equals(e.p1)
    }, wh.prototype.intersection = function (t) {
        var e = new Va;
        return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null
    }, wh.prototype.project = function () {
        if (arguments[0] instanceof pa) {
            var t = arguments[0];
            if (t.equals(this.p0) || t.equals(this.p1)) return new pa(t);
            var e = this.projectionFactor(t), n = new pa;
            return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n
        }
        if (arguments[0] instanceof wh) {
            var r = arguments[0], i = this.projectionFactor(r.p0), o = this.projectionFactor(r.p1);
            if (1 <= i && 1 <= o) return null;
            if (i <= 0 && o <= 0) return null;
            var s = this.project(r.p0);
            i < 0 && (s = this.p0), 1 < i && (s = this.p1);
            var a = this.project(r.p1);
            return o < 0 && (a = this.p0), 1 < o && (a = this.p1), new wh(s, a)
        }
    }, wh.prototype.normalize = function () {
        this.p1.compareTo(this.p0) < 0 && this.reverse()
    }, wh.prototype.angle = function () {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
    }, wh.prototype.getCoordinate = function (t) {
        return 0 === t ? this.p0 : this.p1
    }, wh.prototype.distancePerpendicular = function (t) {
        return Ja.distancePointLinePerpendicular(t, this.p0, this.p1)
    }, wh.prototype.minY = function () {
        return Math.min(this.p0.y, this.p1.y)
    }, wh.prototype.midPoint = function () {
        return wh.midPoint(this.p0, this.p1)
    }, wh.prototype.projectionFactor = function (t) {
        if (t.equals(this.p0)) return 0;
        if (t.equals(this.p1)) return 1;
        var e = this.p1.x - this.p0.x, n = this.p1.y - this.p0.y, r = e * e + n * n;
        return r <= 0 ? sa.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r
    }, wh.prototype.closestPoints = function (t) {
        var e = this.intersection(t);
        if (null !== e) return [e, e];
        var n = new Array(2).fill(null), r = sa.MAX_VALUE, i = null, o = this.closestPoint(t.p0);
        r = o.distance(t.p0), n[0] = o, n[1] = t.p0;
        var s = this.closestPoint(t.p1);
        (i = s.distance(t.p1)) < r && (r = i, n[0] = s, n[1] = t.p1);
        var a = t.closestPoint(this.p0);
        (i = a.distance(this.p0)) < r && (r = i, n[0] = this.p0, n[1] = a);
        var u = t.closestPoint(this.p1);
        return (i = u.distance(this.p1)) < r && (r = i, n[0] = this.p1, n[1] = u), n
    }, wh.prototype.closestPoint = function (t) {
        var e = this.projectionFactor(t);
        return 0 < e && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1
    }, wh.prototype.maxX = function () {
        return Math.max(this.p0.x, this.p1.x)
    }, wh.prototype.getLength = function () {
        return this.p0.distance(this.p1)
    }, wh.prototype.compareTo = function (t) {
        var e = t, n = this.p0.compareTo(e.p0);
        return 0 !== n ? n : this.p1.compareTo(e.p1)
    }, wh.prototype.reverse = function () {
        var t = this.p0;
        this.p0 = this.p1, this.p1 = t
    }, wh.prototype.equalsTopo = function (t) {
        return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0)
    }, wh.prototype.lineIntersection = function (t) {
        try {
            return Ta.intersection(this.p0, this.p1, t.p0, t.p1)
        } catch (t) {
            if (!(t instanceof Oa)) throw t
        }
        return null
    }, wh.prototype.maxY = function () {
        return Math.max(this.p0.y, this.p1.y)
    }, wh.prototype.pointAlongOffset = function (t, e) {
        var n = this.p0.x + t * (this.p1.x - this.p0.x), r = this.p0.y + t * (this.p1.y - this.p0.y),
            i = this.p1.x - this.p0.x, o = this.p1.y - this.p0.y, s = Math.sqrt(i * i + o * o), a = 0, u = 0;
        if (0 !== e) {
            if (s <= 0) throw new Error("Cannot compute offset from zero-length line segment");
            a = e * i / s, u = e * o / s
        }
        return new pa(n - u, r + a)
    }, wh.prototype.setCoordinates = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.setCoordinates(t.p0, t.p1)
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y
        }
    }, wh.prototype.segmentFraction = function (t) {
        var e = this.projectionFactor(t);
        return e < 0 ? e = 0 : (1 < e || sa.isNaN(e)) && (e = 1), e
    }, wh.prototype.toString = function () {
        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
    }, wh.prototype.isHorizontal = function () {
        return this.p0.y === this.p1.y
    }, wh.prototype.distance = function () {
        if (arguments[0] instanceof wh) {
            var t = arguments[0];
            return Ja.distanceLineLine(this.p0, this.p1, t.p0, t.p1)
        }
        if (arguments[0] instanceof pa) {
            var e = arguments[0];
            return Ja.distancePointLine(e, this.p0, this.p1)
        }
    }, wh.prototype.pointAlong = function (t) {
        var e = new pa;
        return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e
    }, wh.prototype.hashCode = function () {
        var t = sa.doubleToLongBits(this.p0.x);
        t ^= 31 * sa.doubleToLongBits(this.p0.y);
        var e = Math.trunc(t) ^ Math.trunc(t >> 32), n = sa.doubleToLongBits(this.p1.x);
        return n ^= 31 * sa.doubleToLongBits(this.p1.y), e ^ Math.trunc(n) ^ Math.trunc(n >> 32)
    }, wh.prototype.interfaces_ = function () {
        return [ua, la]
    }, wh.prototype.getClass = function () {
        return wh
    }, wh.midPoint = function (t, e) {
        return new pa((t.x + e.x) / 2, (t.y + e.y) / 2)
    }, bh.serialVersionUID.get = function () {
        return 0x2d2172135f411c00
    }, Object.defineProperties(wh, bh);
    var Ih = function () {
        this.tempEnv1 = new Aa, this.tempEnv2 = new Aa, this._overlapSeg1 = new wh, this._overlapSeg2 = new wh
    };
    Ih.prototype.overlap = function () {
        if (2 === arguments.length) ; else if (4 === arguments.length) {
            var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3];
            t.getLineSegment(e, this._overlapSeg1), n.getLineSegment(r, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2)
        }
    }, Ih.prototype.interfaces_ = function () {
        return []
    }, Ih.prototype.getClass = function () {
        return Ih
    };
    var Nh = function () {
        this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
        var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3];
        this._pts = t, this._start = e, this._end = n, this._context = r
    };
    Nh.prototype.getLineSegment = function (t, e) {
        e.p0 = this._pts[t], e.p1 = this._pts[t + 1]
    }, Nh.prototype.computeSelect = function (t, e, n, r) {
        var i = this._pts[e], o = this._pts[n];
        if (r.tempEnv1.init(i, o), n - e == 1) return r.select(this, e), null;
        if (!t.intersects(r.tempEnv1)) return null;
        var s = Math.trunc((e + n) / 2);
        e < s && this.computeSelect(t, e, s, r), s < n && this.computeSelect(t, s, n, r)
    }, Nh.prototype.getCoordinates = function () {
        for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];
        return t
    }, Nh.prototype.computeOverlaps = function (t, e) {
        this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e)
    }, Nh.prototype.setId = function (t) {
        this._id = t
    }, Nh.prototype.select = function (t, e) {
        this.computeSelect(t, this._start, this._end, e)
    }, Nh.prototype.getEnvelope = function () {
        if (null === this._env) {
            var t = this._pts[this._start], e = this._pts[this._end];
            this._env = new Aa(t, e)
        }
        return this._env
    }, Nh.prototype.getEndIndex = function () {
        return this._end
    }, Nh.prototype.getStartIndex = function () {
        return this._start
    }, Nh.prototype.getContext = function () {
        return this._context
    }, Nh.prototype.getId = function () {
        return this._id
    }, Nh.prototype.computeOverlapsInternal = function (t, e, n, r, i, o) {
        var s = this._pts[t], a = this._pts[e], u = n._pts[r], c = n._pts[i];
        if (e - t == 1 && i - r == 1) return o.overlap(this, t, n, r), null;
        if (o.tempEnv1.init(s, a), o.tempEnv2.init(u, c), !o.tempEnv1.intersects(o.tempEnv2)) return null;
        var h = Math.trunc((t + e) / 2), l = Math.trunc((r + i) / 2);
        t < h && (r < l && this.computeOverlapsInternal(t, h, n, r, l, o), l < i && this.computeOverlapsInternal(t, h, n, l, i, o)), h < e && (r < l && this.computeOverlapsInternal(h, e, n, r, l, o), l < i && this.computeOverlapsInternal(h, e, n, l, i, o))
    }, Nh.prototype.interfaces_ = function () {
        return []
    }, Nh.prototype.getClass = function () {
        return Nh
    };
    var Ch = function () {
    };
    Ch.prototype.interfaces_ = function () {
        return []
    }, Ch.prototype.getClass = function () {
        return Ch
    }, Ch.getChainStartIndices = function (t) {
        var e = 0, n = new fu;
        n.add(new wa(e));
        do {
            var r = Ch.findChainEnd(t, e);
            n.add(new wa(r)), e = r
        } while (e < t.length - 1);
        return Ch.toIntArray(n)
    }, Ch.findChainEnd = function (t, e) {
        for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;
        if (n >= t.length - 1) return t.length - 1;
        for (var r = Hc.quadrant(t[n], t[n + 1]), i = e + 1; i < t.length && (t[i - 1].equals2D(t[i]) || Hc.quadrant(t[i - 1], t[i]) === r);) i++;
        return i - 1
    }, Ch.getChains = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return Ch.getChains(t, null)
        }
        if (2 === arguments.length) {
            for (var e = arguments[0], n = arguments[1], r = new fu, i = Ch.getChainStartIndices(e), o = 0; o < i.length - 1; o++) {
                var s = new Nh(e, i[o], i[o + 1], n);
                r.add(s)
            }
            return r
        }
    }, Ch.toIntArray = function (t) {
        for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();
        return e
    };
    var Sh = function () {
    };
    Sh.prototype.computeNodes = function (t) {
    }, Sh.prototype.getNodedSubstrings = function () {
    }, Sh.prototype.interfaces_ = function () {
        return []
    }, Sh.prototype.getClass = function () {
        return Sh
    };
    var Mh = function () {
        if (this._segInt = null, 0 === arguments.length) ; else if (1 === arguments.length) {
            var t = arguments[0];
            this.setSegmentIntersector(t)
        }
    };
    Mh.prototype.setSegmentIntersector = function (t) {
        this._segInt = t
    }, Mh.prototype.interfaces_ = function () {
        return [Sh]
    }, Mh.prototype.getClass = function () {
        return Mh
    };
    var Lh = function (e) {
        function t(t) {
            t ? e.call(this, t) : e.call(this), this._monoChains = new fu, this._index = new fh, this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0
        }

        e && (t.__proto__ = e);
        var n = {SegmentOverlapAction: {configurable: !0}};
        return ((t.prototype = Object.create(e && e.prototype)).constructor = t).prototype.getMonotoneChains = function () {
            return this._monoChains
        }, t.prototype.getNodedSubstrings = function () {
            return Eh.getNodedSubstrings(this._nodedSegStrings)
        }, t.prototype.getIndex = function () {
            return this._index
        }, t.prototype.add = function (t) {
            for (var e = Ch.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {
                var n = e.next();
                n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n)
            }
        }, t.prototype.computeNodes = function (t) {
            for (var e = (this._nodedSegStrings = t).iterator(); e.hasNext();) this.add(e.next());
            this.intersectChains()
        }, t.prototype.intersectChains = function () {
            for (var t = new Ph(this._segInt), e = this._monoChains.iterator(); e.hasNext();) for (var n = e.next(), r = this._index.query(n.getEnvelope()).iterator(); r.hasNext();) {
                var i = r.next();
                if (i.getId() > n.getId() && (n.computeOverlaps(i, t), this._nOverlaps++), this._segInt.isDone()) return null
            }
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, n.SegmentOverlapAction.get = function () {
            return Ph
        }, Object.defineProperties(t, n), t
    }(Mh), Ph = function (s) {
        function t() {
            s.call(this), this._si = null;
            var t = arguments[0];
            this._si = t
        }

        return s && (t.__proto__ = s), ((t.prototype = Object.create(s && s.prototype)).constructor = t).prototype.overlap = function () {
            if (4 !== arguments.length) return s.prototype.overlap.apply(this, arguments);
            var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3], i = t.getContext(),
                o = n.getContext();
            this._si.processIntersections(i, e, o, r)
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(Ih), Oh = function t() {
        if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ; else if (1 === arguments.length) {
            var e = arguments[0];
            this.setQuadrantSegments(e)
        } else if (2 === arguments.length) {
            var n = arguments[0], r = arguments[1];
            this.setQuadrantSegments(n), this.setEndCapStyle(r)
        } else if (4 === arguments.length) {
            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3];
            this.setQuadrantSegments(i), this.setEndCapStyle(o), this.setJoinStyle(s), this.setMitreLimit(a)
        }
    }, Rh = {
        CAP_ROUND: {configurable: !0},
        CAP_FLAT: {configurable: !0},
        CAP_SQUARE: {configurable: !0},
        JOIN_ROUND: {configurable: !0},
        JOIN_MITRE: {configurable: !0},
        JOIN_BEVEL: {configurable: !0},
        DEFAULT_QUADRANT_SEGMENTS: {configurable: !0},
        DEFAULT_MITRE_LIMIT: {configurable: !0},
        DEFAULT_SIMPLIFY_FACTOR: {configurable: !0}
    };
    Oh.prototype.getEndCapStyle = function () {
        return this._endCapStyle
    }, Oh.prototype.isSingleSided = function () {
        return this._isSingleSided
    }, Oh.prototype.setQuadrantSegments = function (t) {
        this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = Oh.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Oh.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Oh.JOIN_ROUND && (this._quadrantSegments = Oh.DEFAULT_QUADRANT_SEGMENTS)
    }, Oh.prototype.getJoinStyle = function () {
        return this._joinStyle
    }, Oh.prototype.setJoinStyle = function (t) {
        this._joinStyle = t
    }, Oh.prototype.setSimplifyFactor = function (t) {
        this._simplifyFactor = t < 0 ? 0 : t
    }, Oh.prototype.getSimplifyFactor = function () {
        return this._simplifyFactor
    }, Oh.prototype.getQuadrantSegments = function () {
        return this._quadrantSegments
    }, Oh.prototype.setEndCapStyle = function (t) {
        this._endCapStyle = t
    }, Oh.prototype.getMitreLimit = function () {
        return this._mitreLimit
    }, Oh.prototype.setMitreLimit = function (t) {
        this._mitreLimit = t
    }, Oh.prototype.setSingleSided = function (t) {
        this._isSingleSided = t
    }, Oh.prototype.interfaces_ = function () {
        return []
    }, Oh.prototype.getClass = function () {
        return Oh
    }, Oh.bufferDistanceError = function (t) {
        var e = Math.PI / 2 / t;
        return 1 - Math.cos(e / 2)
    }, Rh.CAP_ROUND.get = function () {
        return 1
    }, Rh.CAP_FLAT.get = function () {
        return 2
    }, Rh.CAP_SQUARE.get = function () {
        return 3
    }, Rh.JOIN_ROUND.get = function () {
        return 1
    }, Rh.JOIN_MITRE.get = function () {
        return 2
    }, Rh.JOIN_BEVEL.get = function () {
        return 3
    }, Rh.DEFAULT_QUADRANT_SEGMENTS.get = function () {
        return 8
    }, Rh.DEFAULT_MITRE_LIMIT.get = function () {
        return 5
    }, Rh.DEFAULT_SIMPLIFY_FACTOR.get = function () {
        return .01
    }, Object.defineProperties(Oh, Rh);
    var Th = function (t) {
        this._distanceTol = null, this._isDeleted = null, this._angleOrientation = Ja.COUNTERCLOCKWISE, this._inputLine = t || null
    }, Ah = {
        INIT: {configurable: !0},
        DELETE: {configurable: !0},
        KEEP: {configurable: !0},
        NUM_PTS_TO_CHECK: {configurable: !0}
    };
    Th.prototype.isDeletable = function (t, e, n, r) {
        var i = this._inputLine[t], o = this._inputLine[e], s = this._inputLine[n];
        return !!this.isConcave(i, o, s) && !!this.isShallow(i, o, s, r) && this.isShallowSampled(i, o, t, n, r)
    }, Th.prototype.deleteShallowConcavities = function () {
        for (var t = 1, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e), r = !1; n < this._inputLine.length;) {
            var i = !1;
            this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = Th.DELETE, r = i = !0), t = i ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e)
        }
        return r
    }, Th.prototype.isShallowConcavity = function (t, e, n, r) {
        return Ja.computeOrientation(t, e, n) === this._angleOrientation && Ja.distancePointLine(e, t, n) < r
    }, Th.prototype.isShallowSampled = function (t, e, n, r, i) {
        var o = Math.trunc((r - n) / Th.NUM_PTS_TO_CHECK);
        o <= 0 && (o = 1);
        for (var s = n; s < r; s += o) if (!this.isShallow(t, e, this._inputLine[s], i)) return !1;
        return !0
    }, Th.prototype.isConcave = function (t, e, n) {
        return Ja.computeOrientation(t, e, n) === this._angleOrientation
    }, Th.prototype.simplify = function (t) {
        for (this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = Ja.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null); this.deleteShallowConcavities();) ;
        return this.collapseLine()
    }, Th.prototype.findNextNonDeletedIndex = function (t) {
        for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === Th.DELETE;) e++;
        return e
    }, Th.prototype.isShallow = function (t, e, n, r) {
        return Ja.distancePointLine(e, t, n) < r
    }, Th.prototype.collapseLine = function () {
        for (var t = new du, e = 0; e < this._inputLine.length; e++) this._isDeleted[e] !== Th.DELETE && t.add(this._inputLine[e]);
        return t.toCoordinateArray()
    }, Th.prototype.interfaces_ = function () {
        return []
    }, Th.prototype.getClass = function () {
        return Th
    }, Th.simplify = function (t, e) {
        return new Th(t).simplify(e)
    }, Ah.INIT.get = function () {
        return 0
    }, Ah.DELETE.get = function () {
        return 1
    }, Ah.KEEP.get = function () {
        return 1
    }, Ah.NUM_PTS_TO_CHECK.get = function () {
        return 10
    }, Object.defineProperties(Th, Ah);
    var Dh = function () {
        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new fu
    }, Fh = {COORDINATE_ARRAY_TYPE: {configurable: !0}};
    Dh.prototype.getCoordinates = function () {
        return this._ptList.toArray(Dh.COORDINATE_ARRAY_TYPE)
    }, Dh.prototype.setPrecisionModel = function (t) {
        this._precisionModel = t
    }, Dh.prototype.addPt = function (t) {
        var e = new pa(t);
        if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;
        this._ptList.add(e)
    }, Dh.prototype.revere = function () {
    }, Dh.prototype.addPts = function (t, e) {
        if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]); else for (var r = t.length - 1; 0 <= r; r--) this.addPt(t[r])
    }, Dh.prototype.isRedundant = function (t) {
        if (this._ptList.size() < 1) return !1;
        var e = this._ptList.get(this._ptList.size() - 1);
        return t.distance(e) < this._minimimVertexDistance
    }, Dh.prototype.toString = function () {
        return (new bc).createLineString(this.getCoordinates()).toString()
    }, Dh.prototype.closeRing = function () {
        if (this._ptList.size() < 1) return null;
        var t = new pa(this._ptList.get(0)), e = this._ptList.get(this._ptList.size() - 1);
        if (t.equals(e)) return null;
        this._ptList.add(t)
    }, Dh.prototype.setMinimumVertexDistance = function (t) {
        this._minimimVertexDistance = t
    }, Dh.prototype.interfaces_ = function () {
        return []
    }, Dh.prototype.getClass = function () {
        return Dh
    }, Fh.COORDINATE_ARRAY_TYPE.get = function () {
        return new Array(0).fill(null)
    }, Object.defineProperties(Dh, Fh);
    var qh = function () {
    }, Gh = {
        PI_TIMES_2: {configurable: !0},
        PI_OVER_2: {configurable: !0},
        PI_OVER_4: {configurable: !0},
        COUNTERCLOCKWISE: {configurable: !0},
        CLOCKWISE: {configurable: !0},
        NONE: {configurable: !0}
    };
    qh.prototype.interfaces_ = function () {
        return []
    }, qh.prototype.getClass = function () {
        return qh
    }, qh.toDegrees = function (t) {
        return 180 * t / Math.PI
    }, qh.normalize = function (t) {
        for (; t > Math.PI;) t -= qh.PI_TIMES_2;
        for (; t <= -Math.PI;) t += qh.PI_TIMES_2;
        return t
    }, qh.angle = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return Math.atan2(t.y, t.x)
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = n.x - e.x, i = n.y - e.y;
            return Math.atan2(i, r)
        }
    }, qh.isAcute = function (t, e, n) {
        var r = t.x - e.x, i = t.y - e.y;
        return 0 < r * (n.x - e.x) + i * (n.y - e.y)
    }, qh.isObtuse = function (t, e, n) {
        var r = t.x - e.x, i = t.y - e.y;
        return r * (n.x - e.x) + i * (n.y - e.y) < 0
    }, qh.interiorAngle = function (t, e, n) {
        var r = qh.angle(e, t), i = qh.angle(e, n);
        return Math.abs(i - r)
    }, qh.normalizePositive = function (t) {
        if (t < 0) {
            for (; t < 0;) t += qh.PI_TIMES_2;
            qh.PI_TIMES_2 <= t && (t = 0)
        } else {
            for (; qh.PI_TIMES_2 <= t;) t -= qh.PI_TIMES_2;
            t < 0 && (t = 0)
        }
        return t
    }, qh.angleBetween = function (t, e, n) {
        var r = qh.angle(e, t), i = qh.angle(e, n);
        return qh.diff(r, i)
    }, qh.diff = function (t, e) {
        var n = null;
        return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n
    }, qh.toRadians = function (t) {
        return t * Math.PI / 180
    }, qh.getTurn = function (t, e) {
        var n = Math.sin(e - t);
        return 0 < n ? qh.COUNTERCLOCKWISE : n < 0 ? qh.CLOCKWISE : qh.NONE
    }, qh.angleBetweenOriented = function (t, e, n) {
        var r = qh.angle(e, t), i = qh.angle(e, n) - r;
        return i <= -Math.PI ? i + qh.PI_TIMES_2 : i > Math.PI ? i - qh.PI_TIMES_2 : i
    }, Gh.PI_TIMES_2.get = function () {
        return 2 * Math.PI
    }, Gh.PI_OVER_2.get = function () {
        return Math.PI / 2
    }, Gh.PI_OVER_4.get = function () {
        return Math.PI / 4
    }, Gh.COUNTERCLOCKWISE.get = function () {
        return Ja.COUNTERCLOCKWISE
    }, Gh.CLOCKWISE.get = function () {
        return Ja.CLOCKWISE
    }, Gh.NONE.get = function () {
        return Ja.COLLINEAR
    }, Object.defineProperties(qh, Gh);
    var Bh = function t() {
        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new wh, this._seg1 = new wh, this._offset0 = new wh, this._offset1 = new wh, this._side = 0, this._hasNarrowConcaveAngle = !1;
        var e = arguments[0], n = arguments[1], r = arguments[2];
        this._precisionModel = e, this._bufParams = n, this._li = new Va, this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), 8 <= n.getQuadrantSegments() && n.getJoinStyle() === Oh.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(r)
    }, kh = {
        OFFSET_SEGMENT_SEPARATION_FACTOR: {configurable: !0},
        INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {configurable: !0},
        CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {configurable: !0},
        MAX_CLOSING_SEG_LEN_FACTOR: {configurable: !0}
    };
    Bh.prototype.addNextSegment = function (t, e) {
        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
        var n = Ja.computeOrientation(this._s0, this._s1, this._s2),
            r = n === Ja.CLOCKWISE && this._side === Oc.LEFT || n === Ja.COUNTERCLOCKWISE && this._side === Oc.RIGHT;
        0 === n ? this.addCollinear(e) : r ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
    }, Bh.prototype.addLineEndCap = function (t, e) {
        var n = new wh(t, e), r = new wh;
        this.computeOffsetSegment(n, Oc.LEFT, this._distance, r);
        var i = new wh;
        this.computeOffsetSegment(n, Oc.RIGHT, this._distance, i);
        var o = e.x - t.x, s = e.y - t.y, a = Math.atan2(s, o);
        switch (this._bufParams.getEndCapStyle()) {
            case Oh.CAP_ROUND:
                this._segList.addPt(r.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, Ja.CLOCKWISE, this._distance), this._segList.addPt(i.p1);
                break;
            case Oh.CAP_FLAT:
                this._segList.addPt(r.p1), this._segList.addPt(i.p1);
                break;
            case Oh.CAP_SQUARE:
                var u = new pa;
                u.x = Math.abs(this._distance) * Math.cos(a), u.y = Math.abs(this._distance) * Math.sin(a);
                var c = new pa(r.p1.x + u.x, r.p1.y + u.y), h = new pa(i.p1.x + u.x, i.p1.y + u.y);
                this._segList.addPt(c), this._segList.addPt(h)
        }
    }, Bh.prototype.getCoordinates = function () {
        return this._segList.getCoordinates()
    }, Bh.prototype.addMitreJoin = function (t, e, n, r) {
        var i = !0, o = null;
        try {
            o = Ta.intersection(e.p0, e.p1, n.p0, n.p1), (r <= 0 ? 1 : o.distance(t) / Math.abs(r)) > this._bufParams.getMitreLimit() && (i = !1)
        } catch (t) {
            if (!(t instanceof Oa)) throw t;
            o = new pa(0, 0), i = !1
        }
        i ? this._segList.addPt(o) : this.addLimitedMitreJoin(e, n, r, this._bufParams.getMitreLimit())
    }, Bh.prototype.addFilletCorner = function (t, e, n, r, i) {
        var o = e.x - t.x, s = e.y - t.y, a = Math.atan2(s, o), u = n.x - t.x, c = n.y - t.y, h = Math.atan2(c, u);
        r === Ja.CLOCKWISE ? a <= h && (a += 2 * Math.PI) : h <= a && (a -= 2 * Math.PI), this._segList.addPt(e), this.addFilletArc(t, a, h, r, i), this._segList.addPt(n)
    }, Bh.prototype.addOutsideTurn = function (t, e) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Bh.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
        this._bufParams.getJoinStyle() === Oh.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Oh.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0))
    }, Bh.prototype.createSquare = function (t) {
        this._segList.addPt(new pa(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new pa(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new pa(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new pa(t.x - this._distance, t.y + this._distance)), this._segList.closeRing()
    }, Bh.prototype.addSegments = function (t, e) {
        this._segList.addPts(t, e)
    }, Bh.prototype.addFirstSegment = function () {
        this._segList.addPt(this._offset1.p0)
    }, Bh.prototype.addLastSegment = function () {
        this._segList.addPt(this._offset1.p1)
    }, Bh.prototype.initSideSegments = function (t, e, n) {
        this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1)
    }, Bh.prototype.addLimitedMitreJoin = function (t, e, n, r) {
        var i = this._seg0.p1, o = qh.angle(i, this._seg0.p0),
            s = qh.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2, a = qh.normalize(o + s),
            u = qh.normalize(a + Math.PI), c = r * n, h = n - c * Math.abs(Math.sin(s)), l = i.x + c * Math.cos(u),
            p = i.y + c * Math.sin(u), f = new pa(l, p), g = new wh(i, f), d = g.pointAlongOffset(1, h),
            y = g.pointAlongOffset(1, -h);
        this._side === Oc.LEFT ? (this._segList.addPt(d), this._segList.addPt(y)) : (this._segList.addPt(y), this._segList.addPt(d))
    }, Bh.prototype.computeOffsetSegment = function (t, e, n, r) {
        var i = e === Oc.LEFT ? 1 : -1, o = t.p1.x - t.p0.x, s = t.p1.y - t.p0.y, a = Math.sqrt(o * o + s * s),
            u = i * n * o / a, c = i * n * s / a;
        r.p0.x = t.p0.x - c, r.p0.y = t.p0.y + u, r.p1.x = t.p1.x - c, r.p1.y = t.p1.y + u
    }, Bh.prototype.addFilletArc = function (t, e, n, r, i) {
        var o = r === Ja.CLOCKWISE ? -1 : 1, s = Math.abs(e - n), a = Math.trunc(s / this._filletAngleQuantum + .5);
        if (a < 1) return null;
        for (var u = s / a, c = 0, h = new pa; c < s;) {
            var l = e + o * c;
            h.x = t.x + i * Math.cos(l), h.y = t.y + i * Math.sin(l), this._segList.addPt(h), c += u
        }
    }, Bh.prototype.addInsideTurn = function (t, e) {
        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0)); else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * Bh.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1); else {
            if (this._segList.addPt(this._offset0.p1), 0 < this._closingSegLengthFactor) {
                var n = new pa((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                this._segList.addPt(n);
                var r = new pa((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                this._segList.addPt(r)
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0)
        }
    }, Bh.prototype.createCircle = function (t) {
        var e = new pa(t.x + this._distance, t.y);
        this._segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing()
    }, Bh.prototype.addBevelJoin = function (t, e) {
        this._segList.addPt(t.p1), this._segList.addPt(e.p0)
    }, Bh.prototype.init = function (t) {
        this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Dh, this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * Bh.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
    }, Bh.prototype.addCollinear = function (t) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), 2 <= this._li.getIntersectionNum() && (this._bufParams.getJoinStyle() === Oh.JOIN_BEVEL || this._bufParams.getJoinStyle() === Oh.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, Ja.CLOCKWISE, this._distance))
    }, Bh.prototype.closeRing = function () {
        this._segList.closeRing()
    }, Bh.prototype.hasNarrowConcaveAngle = function () {
        return this._hasNarrowConcaveAngle
    }, Bh.prototype.interfaces_ = function () {
        return []
    }, Bh.prototype.getClass = function () {
        return Bh
    }, kh.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () {
        return .001
    }, kh.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {
        return .001
    }, kh.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {
        return 1e-6
    }, kh.MAX_CLOSING_SEG_LEN_FACTOR.get = function () {
        return 80
    }, Object.defineProperties(Bh, kh);
    var zh = function () {
        this._distance = 0, this._precisionModel = null, this._bufParams = null;
        var t = arguments[0], e = arguments[1];
        this._precisionModel = t, this._bufParams = e
    };
    zh.prototype.getOffsetCurve = function (t, e) {
        if (0 === (this._distance = e)) return null;
        var n = e < 0, r = Math.abs(e), i = this.getSegGen(r);
        t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i);
        var o = i.getCoordinates();
        return n && yu.reverse(o), o
    }, zh.prototype.computeSingleSidedBufferCurve = function (t, e, n) {
        var r = this.simplifyTolerance(this._distance);
        if (e) {
            n.addSegments(t, !0);
            var i = Th.simplify(t, -r), o = i.length - 1;
            n.initSideSegments(i[o], i[o - 1], Oc.LEFT), n.addFirstSegment();
            for (var s = o - 2; 0 <= s; s--) n.addNextSegment(i[s], !0)
        } else {
            n.addSegments(t, !1);
            var a = Th.simplify(t, r), u = a.length - 1;
            n.initSideSegments(a[0], a[1], Oc.LEFT), n.addFirstSegment();
            for (var c = 2; c <= u; c++) n.addNextSegment(a[c], !0)
        }
        n.addLastSegment(), n.closeRing()
    }, zh.prototype.computeRingBufferCurve = function (t, e, n) {
        var r = this.simplifyTolerance(this._distance);
        e === Oc.RIGHT && (r = -r);
        var i = Th.simplify(t, r), o = i.length - 1;
        n.initSideSegments(i[o - 1], i[0], e);
        for (var s = 1; s <= o; s++) {
            var a = 1 !== s;
            n.addNextSegment(i[s], a)
        }
        n.closeRing()
    }, zh.prototype.computeLineBufferCurve = function (t, e) {
        var n = this.simplifyTolerance(this._distance), r = Th.simplify(t, n), i = r.length - 1;
        e.initSideSegments(r[0], r[1], Oc.LEFT);
        for (var o = 2; o <= i; o++) e.addNextSegment(r[o], !0);
        e.addLastSegment(), e.addLineEndCap(r[i - 1], r[i]);
        var s = Th.simplify(t, -n), a = s.length - 1;
        e.initSideSegments(s[a], s[a - 1], Oc.LEFT);
        for (var u = a - 2; 0 <= u; u--) e.addNextSegment(s[u], !0);
        e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing()
    }, zh.prototype.computePointCurve = function (t, e) {
        switch (this._bufParams.getEndCapStyle()) {
            case Oh.CAP_ROUND:
                e.createCircle(t);
                break;
            case Oh.CAP_SQUARE:
                e.createSquare(t)
        }
    }, zh.prototype.getLineCurve = function (t, e) {
        if ((this._distance = e) < 0 && !this._bufParams.isSingleSided()) return null;
        if (0 === e) return null;
        var n = Math.abs(e), r = this.getSegGen(n);
        if (t.length <= 1) this.computePointCurve(t[0], r); else if (this._bufParams.isSingleSided()) {
            var i = e < 0;
            this.computeSingleSidedBufferCurve(t, i, r)
        } else this.computeLineBufferCurve(t, r);
        return r.getCoordinates()
    }, zh.prototype.getBufferParameters = function () {
        return this._bufParams
    }, zh.prototype.simplifyTolerance = function (t) {
        return t * this._bufParams.getSimplifyFactor()
    }, zh.prototype.getRingCurve = function (t, e, n) {
        if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n);
        if (0 === n) return zh.copyCoordinates(t);
        var r = this.getSegGen(n);
        return this.computeRingBufferCurve(t, e, r), r.getCoordinates()
    }, zh.prototype.computeOffsetCurve = function (t, e, n) {
        var r = this.simplifyTolerance(this._distance);
        if (e) {
            var i = Th.simplify(t, -r), o = i.length - 1;
            n.initSideSegments(i[o], i[o - 1], Oc.LEFT), n.addFirstSegment();
            for (var s = o - 2; 0 <= s; s--) n.addNextSegment(i[s], !0)
        } else {
            var a = Th.simplify(t, r), u = a.length - 1;
            n.initSideSegments(a[0], a[1], Oc.LEFT), n.addFirstSegment();
            for (var c = 2; c <= u; c++) n.addNextSegment(a[c], !0)
        }
        n.addLastSegment()
    }, zh.prototype.getSegGen = function (t) {
        return new Bh(this._precisionModel, this._bufParams, t)
    }, zh.prototype.interfaces_ = function () {
        return []
    }, zh.prototype.getClass = function () {
        return zh
    }, zh.copyCoordinates = function (t) {
        for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new pa(t[n]);
        return e
    };
    var jh = function () {
        this._subgraphs = null, this._seg = new wh, this._cga = new Ja;
        var t = arguments[0];
        this._subgraphs = t
    }, Xh = {DepthSegment: {configurable: !0}};
    jh.prototype.findStabbedSegments = function () {
        var t = this;
        if (1 === arguments.length) {
            for (var e = arguments[0], n = new fu, r = this._subgraphs.iterator(); r.hasNext();) {
                var i = r.next(), o = i.getEnvelope();
                e.y < o.getMinY() || e.y > o.getMaxY() || t.findStabbedSegments(e, i.getDirectedEdges(), n)
            }
            return n
        }
        if (3 === arguments.length) if (ma(arguments[2], lu) && arguments[0] instanceof pa && arguments[1] instanceof Zc) {
            for (var s = arguments[0], a = arguments[1], u = arguments[2], c = a.getEdge().getCoordinates(), h = 0; h < c.length - 1; h++) if (t._seg.p0 = c[h], t._seg.p1 = c[h + 1], t._seg.p0.y > t._seg.p1.y && t._seg.reverse(), !(Math.max(t._seg.p0.x, t._seg.p1.x) < s.x || t._seg.isHorizontal() || s.y < t._seg.p0.y || s.y > t._seg.p1.y || Ja.computeOrientation(t._seg.p0, t._seg.p1, s) === Ja.RIGHT)) {
                var l = a.getDepth(Oc.LEFT);
                t._seg.p0.equals(c[h]) || (l = a.getDepth(Oc.RIGHT));
                var p = new Uh(t._seg, l);
                u.add(p)
            }
        } else if (ma(arguments[2], lu) && arguments[0] instanceof pa && ma(arguments[1], lu)) for (var f = arguments[0], g = arguments[1], d = arguments[2], y = g.iterator(); y.hasNext();) {
            var _ = y.next();
            _.isForward() && t.findStabbedSegments(f, _, d)
        }
    }, jh.prototype.getDepth = function (t) {
        var e = this.findStabbedSegments(t);
        return 0 === e.size() ? 0 : ah.min(e)._leftDepth
    }, jh.prototype.interfaces_ = function () {
        return []
    }, jh.prototype.getClass = function () {
        return jh
    }, Xh.DepthSegment.get = function () {
        return Uh
    }, Object.defineProperties(jh, Xh);
    var Uh = function () {
        this._upwardSeg = null, this._leftDepth = null;
        var t = arguments[0], e = arguments[1];
        this._upwardSeg = new wh(t), this._leftDepth = e
    };
    Uh.prototype.compareTo = function (t) {
        var e = t;
        if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
        if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;
        var n = this._upwardSeg.orientationIndex(e._upwardSeg);
        return 0 !== n ? n : 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg)
    }, Uh.prototype.compareX = function (t, e) {
        var n = t.p0.compareTo(e.p0);
        return 0 !== n ? n : t.p1.compareTo(e.p1)
    }, Uh.prototype.toString = function () {
        return this._upwardSeg.toString()
    }, Uh.prototype.interfaces_ = function () {
        return [ua]
    }, Uh.prototype.getClass = function () {
        return Uh
    };
    var Yh = function (t, e, n) {
        this.p0 = t || null, this.p1 = e || null, this.p2 = n || null
    };
    Yh.prototype.area = function () {
        return Yh.area(this.p0, this.p1, this.p2)
    }, Yh.prototype.signedArea = function () {
        return Yh.signedArea(this.p0, this.p1, this.p2)
    }, Yh.prototype.interpolateZ = function (t) {
        if (null === t) throw new oa("Supplied point is null.");
        return Yh.interpolateZ(t, this.p0, this.p1, this.p2)
    }, Yh.prototype.longestSideLength = function () {
        return Yh.longestSideLength(this.p0, this.p1, this.p2)
    }, Yh.prototype.isAcute = function () {
        return Yh.isAcute(this.p0, this.p1, this.p2)
    }, Yh.prototype.circumcentre = function () {
        return Yh.circumcentre(this.p0, this.p1, this.p2)
    }, Yh.prototype.area3D = function () {
        return Yh.area3D(this.p0, this.p1, this.p2)
    }, Yh.prototype.centroid = function () {
        return Yh.centroid(this.p0, this.p1, this.p2)
    }, Yh.prototype.inCentre = function () {
        return Yh.inCentre(this.p0, this.p1, this.p2)
    }, Yh.prototype.interfaces_ = function () {
        return []
    }, Yh.prototype.getClass = function () {
        return Yh
    }, Yh.area = function (t, e, n) {
        return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
    }, Yh.signedArea = function (t, e, n) {
        return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
    }, Yh.det = function (t, e, n, r) {
        return t * r - e * n
    }, Yh.interpolateZ = function (t, e, n, r) {
        var i = e.x, o = e.y, s = n.x - i, a = r.x - i, u = n.y - o, c = r.y - o, h = s * c - a * u, l = t.x - i,
            p = t.y - o, f = (c * l - a * p) / h, g = (-u * l + s * p) / h;
        return e.z + f * (n.z - e.z) + g * (r.z - e.z)
    }, Yh.longestSideLength = function (t, e, n) {
        var r = t.distance(e), i = e.distance(n), o = n.distance(t), s = r;
        return s < i && (s = i), s < o && (s = o), s
    }, Yh.isAcute = function (t, e, n) {
        return !!qh.isAcute(t, e, n) && !!qh.isAcute(e, n, t) && !!qh.isAcute(n, t, e)
    }, Yh.circumcentre = function (t, e, n) {
        var r = n.x, i = n.y, o = t.x - r, s = t.y - i, a = e.x - r, u = e.y - i, c = 2 * Yh.det(o, s, a, u),
            h = Yh.det(s, o * o + s * s, u, a * a + u * u), l = Yh.det(o, o * o + s * s, a, a * a + u * u);
        return new pa(r - h / c, i + l / c)
    }, Yh.perpendicularBisector = function (t, e) {
        var n = e.x - t.x, r = e.y - t.y, i = new Ta(t.x + n / 2, t.y + r / 2, 1),
            o = new Ta(t.x - r + n / 2, t.y + n + r / 2, 1);
        return new Ta(i, o)
    }, Yh.angleBisector = function (t, e, n) {
        var r = e.distance(t), i = r / (r + e.distance(n)), o = n.x - t.x, s = n.y - t.y;
        return new pa(t.x + i * o, t.y + i * s)
    }, Yh.area3D = function (t, e, n) {
        var r = e.x - t.x, i = e.y - t.y, o = e.z - t.z, s = n.x - t.x, a = n.y - t.y, u = n.z - t.z, c = i * u - o * a,
            h = o * s - r * u, l = r * a - i * s, p = c * c + h * h + l * l;
        return Math.sqrt(p) / 2
    }, Yh.centroid = function (t, e, n) {
        var r = (t.x + e.x + n.x) / 3, i = (t.y + e.y + n.y) / 3;
        return new pa(r, i)
    }, Yh.inCentre = function (t, e, n) {
        var r = e.distance(n), i = t.distance(n), o = t.distance(e), s = r + i + o,
            a = (r * t.x + i * e.x + o * n.x) / s, u = (r * t.y + i * e.y + o * n.y) / s;
        return new pa(a, u)
    };
    var Vh = function () {
        this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new fu;
        var t = arguments[0], e = arguments[1], n = arguments[2];
        this._inputGeom = t, this._distance = e, this._curveBuilder = n
    };
    Vh.prototype.addPoint = function (t) {
        if (this._distance <= 0) return null;
        var e = t.getCoordinates(), n = this._curveBuilder.getLineCurve(e, this._distance);
        this.addCurve(n, ya.EXTERIOR, ya.INTERIOR)
    }, Vh.prototype.addPolygon = function (t) {
        var e = this._distance, n = Oc.LEFT;
        this._distance < 0 && (e = -this._distance, n = Oc.RIGHT);
        var r = t.getExteriorRing(), i = yu.removeRepeatedPoints(r.getCoordinates());
        if (this._distance < 0 && this.isErodedCompletely(r, this._distance)) return null;
        if (this._distance <= 0 && i.length < 3) return null;
        this.addPolygonRing(i, e, n, ya.EXTERIOR, ya.INTERIOR);
        for (var o = 0; o < t.getNumInteriorRing(); o++) {
            var s = t.getInteriorRingN(o), a = yu.removeRepeatedPoints(s.getCoordinates());
            0 < this._distance && this.isErodedCompletely(s, -this._distance) || this.addPolygonRing(a, e, Oc.opposite(n), ya.INTERIOR, ya.EXTERIOR)
        }
    }, Vh.prototype.isTriangleErodedCompletely = function (t, e) {
        var n = new Yh(t[0], t[1], t[2]), r = n.inCentre();
        return Ja.distancePointLine(r, n.p0, n.p1) < Math.abs(e)
    }, Vh.prototype.addLineString = function (t) {
        if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;
        var e = yu.removeRepeatedPoints(t.getCoordinates()), n = this._curveBuilder.getLineCurve(e, this._distance);
        this.addCurve(n, ya.EXTERIOR, ya.INTERIOR)
    }, Vh.prototype.addCurve = function (t, e, n) {
        if (null === t || t.length < 2) return null;
        var r = new Eh(t, new kc(0, ya.BOUNDARY, e, n));
        this._curveList.add(r)
    }, Vh.prototype.getCurves = function () {
        return this.add(this._inputGeom), this._curveList
    }, Vh.prototype.addPolygonRing = function (t, e, n, r, i) {
        if (0 === e && t.length < ac.MINIMUM_VALID_SIZE) return null;
        var o = r, s = i;
        t.length >= ac.MINIMUM_VALID_SIZE && Ja.isCCW(t) && (o = i, s = r, n = Oc.opposite(n));
        var a = this._curveBuilder.getRingCurve(t, n, e);
        this.addCurve(a, o, s)
    }, Vh.prototype.add = function (t) {
        if (t.isEmpty()) return null;
        t instanceof oc ? this.addPolygon(t) : t instanceof ec ? this.addLineString(t) : t instanceof rc ? this.addPoint(t) : t instanceof sc ? this.addCollection(t) : t instanceof Xu ? this.addCollection(t) : t instanceof uc ? this.addCollection(t) : t instanceof ju && this.addCollection(t)
    }, Vh.prototype.isErodedCompletely = function (t, e) {
        var n = t.getCoordinates();
        if (n.length < 4) return e < 0;
        if (4 === n.length) return this.isTriangleErodedCompletely(n, e);
        var r = t.getEnvelopeInternal(), i = Math.min(r.getHeight(), r.getWidth());
        return e < 0 && 2 * Math.abs(e) > i
    }, Vh.prototype.addCollection = function (t) {
        for (var e = 0; e < t.getNumGeometries(); e++) {
            var n = t.getGeometryN(e);
            this.add(n)
        }
    }, Vh.prototype.interfaces_ = function () {
        return []
    }, Vh.prototype.getClass = function () {
        return Vh
    };
    var Hh = function () {
    };
    Hh.prototype.locate = function (t) {
    }, Hh.prototype.interfaces_ = function () {
        return []
    }, Hh.prototype.getClass = function () {
        return Hh
    };
    var Wh = function () {
        this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
        var t = arguments[0];
        this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries()
    };
    Wh.prototype.next = function () {
        if (this._atStart) return this._atStart = !1, Wh.isAtomic(this._parent) && this._index++, this._parent;
        if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null
        }
        if (this._index >= this._max) throw new pu;
        var t = this._parent.getGeometryN(this._index++);
        return t instanceof ju ? (this._subcollectionIterator = new Wh(t), this._subcollectionIterator.next()) : t
    }, Wh.prototype.remove = function () {
        throw new Error(this.getClass().getName())
    }, Wh.prototype.hasNext = function () {
        if (this._atStart) return !0;
        if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext()) return !0;
            this._subcollectionIterator = null
        }
        return !(this._index >= this._max)
    }, Wh.prototype.interfaces_ = function () {
        return [hu]
    }, Wh.prototype.getClass = function () {
        return Wh
    }, Wh.isAtomic = function (t) {
        return !(t instanceof ju)
    };
    var Jh = function () {
        this._geom = null;
        var t = arguments[0];
        this._geom = t
    };
    Jh.prototype.locate = function (t) {
        return Jh.locate(t, this._geom)
    }, Jh.prototype.interfaces_ = function () {
        return [Hh]
    }, Jh.prototype.getClass = function () {
        return Jh
    }, Jh.isPointInRing = function (t, e) {
        return !!e.getEnvelopeInternal().intersects(t) && Ja.isPointInRing(t, e.getCoordinates())
    }, Jh.containsPointInPolygon = function (t, e) {
        if (e.isEmpty()) return !1;
        var n = e.getExteriorRing();
        if (!Jh.isPointInRing(t, n)) return !1;
        for (var r = 0; r < e.getNumInteriorRing(); r++) {
            var i = e.getInteriorRingN(r);
            if (Jh.isPointInRing(t, i)) return !1
        }
        return !0
    }, Jh.containsPoint = function (t, e) {
        if (e instanceof oc) return Jh.containsPointInPolygon(t, e);
        if (e instanceof ju) for (var n = new Wh(e); n.hasNext();) {
            var r = n.next();
            if (r !== e && Jh.containsPoint(t, r)) return !0
        }
        return !1
    }, Jh.locate = function (t, e) {
        return e.isEmpty() ? ya.EXTERIOR : Jh.containsPoint(t, e) ? ya.INTERIOR : ya.EXTERIOR
    };
    var Zh = function () {
        this._edgeMap = new Ru, this._edgeList = null, this._ptInAreaLocation = [ya.NONE, ya.NONE]
    };
    Zh.prototype.getNextCW = function (t) {
        this.getEdges();
        var e = this._edgeList.indexOf(t), n = e - 1;
        return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n)
    }, Zh.prototype.propagateSideLabels = function (t) {
        for (var e = ya.NONE, n = this.iterator(); n.hasNext();) {
            var r = n.next().getLabel();
            r.isArea(t) && r.getLocation(t, Oc.LEFT) !== ya.NONE && (e = r.getLocation(t, Oc.LEFT))
        }
        if (e === ya.NONE) return null;
        for (var i = e, o = this.iterator(); o.hasNext();) {
            var s = o.next(), a = s.getLabel();
            if (a.getLocation(t, Oc.ON) === ya.NONE && a.setLocation(t, Oc.ON, i), a.isArea(t)) {
                var u = a.getLocation(t, Oc.LEFT), c = a.getLocation(t, Oc.RIGHT);
                if (c !== ya.NONE) {
                    if (c !== i) throw new Fc("side location conflict", s.getCoordinate());
                    u === ya.NONE && Xa.shouldNeverReachHere("found single null side (at " + s.getCoordinate() + ")"), i = u
                } else Xa.isTrue(a.getLocation(t, Oc.LEFT) === ya.NONE, "found single null side"), a.setLocation(t, Oc.RIGHT, i), a.setLocation(t, Oc.LEFT, i)
            }
        }
    }, Zh.prototype.getCoordinate = function () {
        var t = this.iterator();
        return t.hasNext() ? t.next().getCoordinate() : null
    }, Zh.prototype.print = function (t) {
        Ra.out.println("EdgeEndStar:   " + this.getCoordinate());
        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
    }, Zh.prototype.isAreaLabelsConsistent = function (t) {
        return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
    }, Zh.prototype.checkAreaLabelsConsistent = function (t) {
        var e = this.getEdges();
        if (e.size() <= 0) return !0;
        var n = e.size() - 1, r = e.get(n).getLabel().getLocation(t, Oc.LEFT);
        Xa.isTrue(r !== ya.NONE, "Found unlabelled area edge");
        for (var i = r, o = this.iterator(); o.hasNext();) {
            var s = o.next().getLabel();
            Xa.isTrue(s.isArea(t), "Found non-area edge");
            var a = s.getLocation(t, Oc.LEFT), u = s.getLocation(t, Oc.RIGHT);
            if (a === u) return !1;
            if (u !== i) return !1;
            i = a
        }
        return !0
    }, Zh.prototype.findIndex = function (t) {
        this.iterator();
        for (var e = 0; e < this._edgeList.size(); e++) if (this._edgeList.get(e) === t) return e;
        return -1
    }, Zh.prototype.iterator = function () {
        return this.getEdges().iterator()
    }, Zh.prototype.getEdges = function () {
        return null === this._edgeList && (this._edgeList = new fu(this._edgeMap.values())), this._edgeList
    }, Zh.prototype.getLocation = function (t, e, n) {
        return this._ptInAreaLocation[t] === ya.NONE && (this._ptInAreaLocation[t] = Jh.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t]
    }, Zh.prototype.toString = function () {
        var t = new Ea;
        t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");
        for (var e = this.iterator(); e.hasNext();) {
            var n = e.next();
            t.append(n), t.append("\n")
        }
        return t.toString()
    }, Zh.prototype.computeEdgeEndLabels = function (t) {
        for (var e = this.iterator(); e.hasNext();) e.next().computeLabel(t)
    }, Zh.prototype.computeLabelling = function (t) {
        this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
        for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var r = n.next().getLabel(), i = 0; i < 2; i++) r.isLine(i) && r.getLocation(i) === ya.BOUNDARY && (e[i] = !0);
        for (var o = this.iterator(); o.hasNext();) for (var s = o.next(), a = s.getLabel(), u = 0; u < 2; u++) if (a.isAnyNull(u)) {
            var c = ya.NONE;
            if (e[u]) c = ya.EXTERIOR; else {
                var h = s.getCoordinate();
                c = this.getLocation(u, h, t)
            }
            a.setAllLocationsIfNull(u, c)
        }
    }, Zh.prototype.getDegree = function () {
        return this._edgeMap.size()
    }, Zh.prototype.insertEdgeEnd = function (t, e) {
        this._edgeMap.put(t, e), this._edgeList = null
    }, Zh.prototype.interfaces_ = function () {
        return []
    }, Zh.prototype.getClass = function () {
        return Zh
    };
    var Kh = function (o) {
        function t() {
            o.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2
        }

        return o && (t.__proto__ = o), ((t.prototype = Object.create(o && o.prototype)).constructor = t).prototype.linkResultDirectedEdges = function () {
            this.getResultAreaEdges();
            for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, r = 0; r < this._resultAreaEdgeList.size(); r++) {
                var i = this._resultAreaEdgeList.get(r), o = i.getSym();
                if (i.getLabel().isArea()) switch (null === t && i.isInResult() && (t = i), n) {
                    case this._SCANNING_FOR_INCOMING:
                        if (!o.isInResult()) continue;
                        e = o, n = this._LINKING_TO_OUTGOING;
                        break;
                    case this._LINKING_TO_OUTGOING:
                        if (!i.isInResult()) continue;
                        e.setNext(i), n = this._SCANNING_FOR_INCOMING
                }
            }
            if (n === this._LINKING_TO_OUTGOING) {
                if (null === t) throw new Fc("no outgoing dirEdge found", this.getCoordinate());
                Xa.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t)
            }
        }, t.prototype.insert = function (t) {
            var e = t;
            this.insertEdgeEnd(e, e)
        }, t.prototype.getRightmostEdge = function () {
            var t = this.getEdges(), e = t.size();
            if (e < 1) return null;
            var n = t.get(0);
            if (1 === e) return n;
            var r = t.get(e - 1), i = n.getQuadrant(), o = r.getQuadrant();
            return Hc.isNorthern(i) && Hc.isNorthern(o) ? n : Hc.isNorthern(i) || Hc.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== r.getDy() ? r : (Xa.shouldNeverReachHere("found two horizontal edges incident on node"), null) : r
        }, t.prototype.print = function (t) {
            Ra.out.println("DirectedEdgeStar: " + this.getCoordinate());
            for (var e = this.iterator(); e.hasNext();) {
                var n = e.next();
                t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println()
            }
        }, t.prototype.getResultAreaEdges = function () {
            if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
            this._resultAreaEdgeList = new fu;
            for (var t = this.iterator(); t.hasNext();) {
                var e = t.next();
                (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e)
            }
            return this._resultAreaEdgeList
        }, t.prototype.updateLabelling = function (t) {
            for (var e = this.iterator(); e.hasNext();) {
                var n = e.next().getLabel();
                n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1))
            }
        }, t.prototype.linkAllDirectedEdges = function () {
            this.getEdges();
            for (var t = null, e = null, n = this._edgeList.size() - 1; 0 <= n; n--) {
                var r = this._edgeList.get(n), i = r.getSym();
                null === e && (e = i), null !== t && i.setNext(t), t = r
            }
            e.setNext(t)
        }, t.prototype.computeDepths = function () {
            if (1 === arguments.length) {
                var t = arguments[0], e = this.findIndex(t), n = t.getDepth(Oc.LEFT), r = t.getDepth(Oc.RIGHT),
                    i = this.computeDepths(e + 1, this._edgeList.size(), n);
                if (this.computeDepths(0, e, i) !== r) throw new Fc("depth mismatch at " + t.getCoordinate())
            } else if (3 === arguments.length) {
                for (var o = arguments[0], s = arguments[1], a = arguments[2], u = o; u < s; u++) {
                    var c = this._edgeList.get(u);
                    c.setEdgeDepths(Oc.RIGHT, a), a = c.getDepth(Oc.LEFT)
                }
                return a
            }
        }, t.prototype.mergeSymLabels = function () {
            for (var t = this.iterator(); t.hasNext();) {
                var e = t.next();
                e.getLabel().merge(e.getSym().getLabel())
            }
        }, t.prototype.linkMinimalDirectedEdges = function (t) {
            for (var e = null, n = null, r = this._SCANNING_FOR_INCOMING, i = this._resultAreaEdgeList.size() - 1; 0 <= i; i--) {
                var o = this._resultAreaEdgeList.get(i), s = o.getSym();
                switch (null === e && o.getEdgeRing() === t && (e = o), r) {
                    case this._SCANNING_FOR_INCOMING:
                        if (s.getEdgeRing() !== t) continue;
                        n = s, r = this._LINKING_TO_OUTGOING;
                        break;
                    case this._LINKING_TO_OUTGOING:
                        if (o.getEdgeRing() !== t) continue;
                        n.setNextMin(o), r = this._SCANNING_FOR_INCOMING
                }
            }
            r === this._LINKING_TO_OUTGOING && (Xa.isTrue(null !== e, "found null for first outgoing dirEdge"), Xa.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e))
        }, t.prototype.getOutgoingDegree = function () {
            if (0 === arguments.length) {
                for (var t = 0, e = this.iterator(); e.hasNext();) e.next().isInResult() && t++;
                return t
            }
            if (1 === arguments.length) {
                for (var n = arguments[0], r = 0, i = this.iterator(); i.hasNext();) i.next().getEdgeRing() === n && r++;
                return r
            }
        }, t.prototype.getLabel = function () {
            return this._label
        }, t.prototype.findCoveredLineEdges = function () {
            for (var t = ya.NONE, e = this.iterator(); e.hasNext();) {
                var n = e.next(), r = n.getSym();
                if (!n.isLineEdge()) {
                    if (n.isInResult()) {
                        t = ya.INTERIOR;
                        break
                    }
                    if (r.isInResult()) {
                        t = ya.EXTERIOR;
                        break
                    }
                }
            }
            if (t === ya.NONE) return null;
            for (var i = t, o = this.iterator(); o.hasNext();) {
                var s = o.next(), a = s.getSym();
                s.isLineEdge() ? s.getEdge().setCovered(i === ya.INTERIOR) : (s.isInResult() && (i = ya.EXTERIOR), a.isInResult() && (i = ya.INTERIOR))
            }
        }, t.prototype.computeLabelling = function (t) {
            o.prototype.computeLabelling.call(this, t), this._label = new kc(ya.NONE);
            for (var e = this.iterator(); e.hasNext();) for (var n = e.next().getEdge().getLabel(), r = 0; r < 2; r++) {
                var i = n.getLocation(r);
                i !== ya.INTERIOR && i !== ya.BOUNDARY || this._label.setLocation(r, ya.INTERIOR)
            }
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(Zh), Qh = function (t) {
        function e() {
            t.apply(this, arguments)
        }

        return t && (e.__proto__ = t), ((e.prototype = Object.create(t && t.prototype)).constructor = e).prototype.createNode = function (t) {
            return new Yc(t, new Kh)
        }, e.prototype.interfaces_ = function () {
            return []
        }, e.prototype.getClass = function () {
            return e
        }, e
    }(Kc), $h = function t() {
        this._pts = null, this._orientation = null;
        var e = arguments[0];
        this._pts = e, this._orientation = t.orientation(e)
    };
    $h.prototype.compareTo = function (t) {
        var e = t;
        return $h.compareOriented(this._pts, this._orientation, e._pts, e._orientation)
    }, $h.prototype.interfaces_ = function () {
        return [ua]
    }, $h.prototype.getClass = function () {
        return $h
    }, $h.orientation = function (t) {
        return 1 === yu.increasingDirection(t)
    }, $h.compareOriented = function (t, e, n, r) {
        for (var i = e ? 1 : -1, o = r ? 1 : -1, s = e ? t.length : -1, a = r ? n.length : -1, u = e ? 0 : t.length - 1, c = r ? 0 : n.length - 1; ;) {
            var h = t[u].compareTo(n[c]);
            if (0 !== h) return h;
            var l = (u += i) === s, p = (c += o) === a;
            if (l && !p) return -1;
            if (!l && p) return 1;
            if (l && p) return 0
        }
    };
    var tl = function () {
        this._edges = new fu, this._ocaMap = new Ru
    };
    tl.prototype.print = function (t) {
        t.print("MULTILINESTRING ( ");
        for (var e = 0; e < this._edges.size(); e++) {
            var n = this._edges.get(e);
            0 < e && t.print(","), t.print("(");
            for (var r = n.getCoordinates(), i = 0; i < r.length; i++) 0 < i && t.print(","), t.print(r[i].x + " " + r[i].y);
            t.println(")")
        }
        t.print(")  ")
    }, tl.prototype.addAll = function (t) {
        for (var e = t.iterator(); e.hasNext();) this.add(e.next())
    }, tl.prototype.findEdgeIndex = function (t) {
        for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;
        return -1
    }, tl.prototype.iterator = function () {
        return this._edges.iterator()
    }, tl.prototype.getEdges = function () {
        return this._edges
    }, tl.prototype.get = function (t) {
        return this._edges.get(t)
    }, tl.prototype.findEqualEdge = function (t) {
        var e = new $h(t.getCoordinates());
        return this._ocaMap.get(e)
    }, tl.prototype.add = function (t) {
        this._edges.add(t);
        var e = new $h(t.getCoordinates());
        this._ocaMap.put(e, t)
    }, tl.prototype.interfaces_ = function () {
        return []
    }, tl.prototype.getClass = function () {
        return tl
    };
    var el = function () {
    };
    el.prototype.processIntersections = function (t, e, n, r) {
    }, el.prototype.isDone = function () {
    }, el.prototype.interfaces_ = function () {
        return []
    }, el.prototype.getClass = function () {
        return el
    };
    var nl = function () {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0;
        var t = arguments[this.numTests = 0];
        this._li = t
    };
    nl.prototype.isTrivialIntersection = function (t, e, n, r) {
        if (t === n && 1 === this._li.getIntersectionNum()) {
            if (nl.isAdjacentSegments(e, r)) return !0;
            if (t.isClosed()) {
                var i = t.size() - 1;
                if (0 === e && r === i || 0 === r && e === i) return !0
            }
        }
        return !1
    }, nl.prototype.getProperIntersectionPoint = function () {
        return this._properIntersectionPoint
    }, nl.prototype.hasProperInteriorIntersection = function () {
        return this._hasProperInterior
    }, nl.prototype.getLineIntersector = function () {
        return this._li
    }, nl.prototype.hasProperIntersection = function () {
        return this._hasProper
    }, nl.prototype.processIntersections = function (t, e, n, r) {
        if (t === n && e === r) return null;
        this.numTests++;
        var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], s = n.getCoordinates()[r],
            a = n.getCoordinates()[r + 1];
        this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)))
    }, nl.prototype.hasIntersection = function () {
        return this._hasIntersection
    }, nl.prototype.isDone = function () {
        return !1
    }, nl.prototype.hasInteriorIntersection = function () {
        return this._hasInterior
    }, nl.prototype.interfaces_ = function () {
        return [el]
    }, nl.prototype.getClass = function () {
        return nl
    }, nl.isAdjacentSegments = function (t, e) {
        return 1 === Math.abs(t - e)
    };
    var rl = function () {
        this.coord = null, this.segmentIndex = null, this.dist = null;
        var t = arguments[0], e = arguments[1], n = arguments[2];
        this.coord = new pa(t), this.segmentIndex = e, this.dist = n
    };
    rl.prototype.getSegmentIndex = function () {
        return this.segmentIndex
    }, rl.prototype.getCoordinate = function () {
        return this.coord
    }, rl.prototype.print = function (t) {
        t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist)
    }, rl.prototype.compareTo = function (t) {
        var e = t;
        return this.compare(e.segmentIndex, e.dist)
    }, rl.prototype.isEndPoint = function (t) {
        return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t
    }, rl.prototype.toString = function () {
        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
    }, rl.prototype.getDistance = function () {
        return this.dist
    }, rl.prototype.compare = function (t, e) {
        return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
    }, rl.prototype.interfaces_ = function () {
        return [ua]
    }, rl.prototype.getClass = function () {
        return rl
    };
    var il = function () {
        this._nodeMap = new Ru, this.edge = null;
        var t = arguments[0];
        this.edge = t
    };
    il.prototype.print = function (t) {
        t.println("Intersections:");
        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
    }, il.prototype.iterator = function () {
        return this._nodeMap.values().iterator()
    }, il.prototype.addSplitEdges = function (t) {
        this.addEndpoints();
        for (var e = this.iterator(), n = e.next(); e.hasNext();) {
            var r = e.next(), i = this.createSplitEdge(n, r);
            t.add(i), n = r
        }
    }, il.prototype.addEndpoints = function () {
        var t = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
    }, il.prototype.createSplitEdge = function (t, e) {
        var n = e.segmentIndex - t.segmentIndex + 2, r = this.edge.pts[e.segmentIndex],
            i = 0 < e.dist || !e.coord.equals2D(r);
        i || n--;
        var o = new Array(n).fill(null), s = 0;
        o[s++] = new pa(t.coord);
        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.pts[a];
        return i && (o[s] = e.coord), new cl(o, new kc(this.edge._label))
    }, il.prototype.add = function (t, e, n) {
        var r = new rl(t, e, n), i = this._nodeMap.get(r);
        return null !== i ? i : (this._nodeMap.put(r, r), r)
    }, il.prototype.isIntersection = function (t) {
        for (var e = this.iterator(); e.hasNext();) if (e.next().coord.equals(t)) return !0;
        return !1
    }, il.prototype.interfaces_ = function () {
        return []
    }, il.prototype.getClass = function () {
        return il
    };
    var ol = function () {
    };
    ol.prototype.getChainStartIndices = function (t) {
        var e = 0, n = new fu;
        n.add(new wa(e));
        do {
            var r = this.findChainEnd(t, e);
            n.add(new wa(r)), e = r
        } while (e < t.length - 1);
        return ol.toIntArray(n)
    }, ol.prototype.findChainEnd = function (t, e) {
        for (var n = Hc.quadrant(t[e], t[e + 1]), r = e + 1; r < t.length && Hc.quadrant(t[r - 1], t[r]) === n;) r++;
        return r - 1
    }, ol.prototype.interfaces_ = function () {
        return []
    }, ol.prototype.getClass = function () {
        return ol
    }, ol.toIntArray = function (t) {
        for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();
        return e
    };
    var sl = function () {
        this.e = null, this.pts = null, this.startIndex = null, this.env1 = new Aa, this.env2 = new Aa;
        var t = arguments[0];
        this.e = t, this.pts = t.getCoordinates();
        var e = new ol;
        this.startIndex = e.getChainStartIndices(this.pts)
    };
    sl.prototype.getCoordinates = function () {
        return this.pts
    }, sl.prototype.getMaxX = function (t) {
        var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
        return n < e ? e : n
    }, sl.prototype.getMinX = function (t) {
        var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
        return e < n ? e : n
    }, sl.prototype.computeIntersectsForChain = function () {
        if (4 === arguments.length) {
            var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], r)
        } else if (6 === arguments.length) {
            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3], u = arguments[4],
                c = arguments[5], h = this.pts[i], l = this.pts[o], p = s.pts[a], f = s.pts[u];
            if (o - i == 1 && u - a == 1) return c.addIntersections(this.e, i, s.e, a), null;
            if (this.env1.init(h, l), this.env2.init(p, f), !this.env1.intersects(this.env2)) return null;
            var g = Math.trunc((i + o) / 2), d = Math.trunc((a + u) / 2);
            i < g && (a < d && this.computeIntersectsForChain(i, g, s, a, d, c), d < u && this.computeIntersectsForChain(i, g, s, d, u, c)), g < o && (a < d && this.computeIntersectsForChain(g, o, s, a, d, c), d < u && this.computeIntersectsForChain(g, o, s, d, u, c))
        }
    }, sl.prototype.getStartIndexes = function () {
        return this.startIndex
    }, sl.prototype.computeIntersects = function (t, e) {
        for (var n = 0; n < this.startIndex.length - 1; n++) for (var r = 0; r < t.startIndex.length - 1; r++) this.computeIntersectsForChain(n, t, r, e)
    }, sl.prototype.interfaces_ = function () {
        return []
    }, sl.prototype.getClass = function () {
        return sl
    };
    var al = function t() {
        this._depth = Array(2).fill().map(function () {
            return Array(3)
        });
        for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE
    }, ul = {NULL_VALUE: {configurable: !0}};
    al.prototype.getDepth = function (t, e) {
        return this._depth[t][e]
    }, al.prototype.setDepth = function (t, e, n) {
        this._depth[t][e] = n
    }, al.prototype.isNull = function () {
        if (0 === arguments.length) {
            for (var t = 0; t < 2; t++) for (var e = 0; e < 3; e++) if (this._depth[t][e] !== al.NULL_VALUE) return !1;
            return !0
        }
        if (1 === arguments.length) {
            var n = arguments[0];
            return this._depth[n][1] === al.NULL_VALUE
        }
        if (2 === arguments.length) {
            var r = arguments[0], i = arguments[1];
            return this._depth[r][i] === al.NULL_VALUE
        }
    }, al.prototype.normalize = function () {
        for (var t = 0; t < 2; t++) if (!this.isNull(t)) {
            var e = this._depth[t][1];
            this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);
            for (var n = 1; n < 3; n++) {
                var r = 0;
                this._depth[t][n] > e && (r = 1), this._depth[t][n] = r
            }
        }
    }, al.prototype.getDelta = function (t) {
        return this._depth[t][Oc.RIGHT] - this._depth[t][Oc.LEFT]
    }, al.prototype.getLocation = function (t, e) {
        return this._depth[t][e] <= 0 ? ya.EXTERIOR : ya.INTERIOR
    }, al.prototype.toString = function () {
        return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2]
    }, al.prototype.add = function () {
        if (1 === arguments.length) for (var t = arguments[0], e = 0; e < 2; e++) for (var n = 1; n < 3; n++) {
            var r = t.getLocation(e, n);
            r !== ya.EXTERIOR && r !== ya.INTERIOR || (this.isNull(e, n) ? this._depth[e][n] = al.depthAtLocation(r) : this._depth[e][n] += al.depthAtLocation(r))
        } else if (3 === arguments.length) {
            var i = arguments[0], o = arguments[1];
            arguments[2] === ya.INTERIOR && this._depth[i][o]++
        }
    }, al.prototype.interfaces_ = function () {
        return []
    }, al.prototype.getClass = function () {
        return al
    }, al.depthAtLocation = function (t) {
        return t === ya.EXTERIOR ? 0 : t === ya.INTERIOR ? 1 : al.NULL_VALUE
    }, ul.NULL_VALUE.get = function () {
        return -1
    }, Object.defineProperties(al, ul);
    var cl = function (r) {
        function s() {
            if (r.call(this), this.pts = null, this._env = null, this.eiList = new il(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new al, this._depthDelta = 0, 1 === arguments.length) {
                var t = arguments[0];
                s.call(this, t, null)
            } else if (2 === arguments.length) {
                var e = arguments[0], n = arguments[1];
                this.pts = e, this._label = n
            }
        }

        return r && (s.__proto__ = r), ((s.prototype = Object.create(r && r.prototype)).constructor = s).prototype.getDepth = function () {
            return this._depth
        }, s.prototype.getCollapsedEdge = function () {
            var t = new Array(2).fill(null);
            return t[0] = this.pts[0], t[1] = this.pts[1], new s(t, kc.toLineLabel(this._label))
        }, s.prototype.isIsolated = function () {
            return this._isIsolated
        }, s.prototype.getCoordinates = function () {
            return this.pts
        }, s.prototype.setIsolated = function (t) {
            this._isIsolated = t
        }, s.prototype.setName = function (t) {
            this._name = t
        }, s.prototype.equals = function (t) {
            if (!(t instanceof s)) return !1;
            var e = t;
            if (this.pts.length !== e.pts.length) return !1;
            for (var n = !0, r = !0, i = this.pts.length, o = 0; o < this.pts.length; o++) if (this.pts[o].equals2D(e.pts[o]) || (n = !1), this.pts[o].equals2D(e.pts[--i]) || (r = !1), !n && !r) return !1;
            return !0
        }, s.prototype.getCoordinate = function () {
            if (0 === arguments.length) return 0 < this.pts.length ? this.pts[0] : null;
            if (1 === arguments.length) {
                var t = arguments[0];
                return this.pts[t]
            }
        }, s.prototype.print = function (t) {
            t.print("edge " + this._name + ": "), t.print("LINESTRING (");
            for (var e = 0; e < this.pts.length; e++) 0 < e && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
            t.print(")  " + this._label + " " + this._depthDelta)
        }, s.prototype.computeIM = function (t) {
            s.updateIM(this._label, t)
        }, s.prototype.isCollapsed = function () {
            return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2])
        }, s.prototype.isClosed = function () {
            return this.pts[0].equals(this.pts[this.pts.length - 1])
        }, s.prototype.getMaximumSegmentIndex = function () {
            return this.pts.length - 1
        }, s.prototype.getDepthDelta = function () {
            return this._depthDelta
        }, s.prototype.getNumPoints = function () {
            return this.pts.length
        }, s.prototype.printReverse = function (t) {
            t.print("edge " + this._name + ": ");
            for (var e = this.pts.length - 1; 0 <= e; e--) t.print(this.pts[e] + " ");
            t.println("")
        }, s.prototype.getMonotoneChainEdge = function () {
            return null === this._mce && (this._mce = new sl(this)), this._mce
        }, s.prototype.getEnvelope = function () {
            if (null === this._env) {
                this._env = new Aa;
                for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t])
            }
            return this._env
        }, s.prototype.addIntersection = function (t, e, n, r) {
            var i = new pa(t.getIntersection(r)), o = e, s = t.getEdgeDistance(n, r), a = o + 1;
            if (a < this.pts.length) {
                var u = this.pts[a];
                i.equals2D(u) && (o = a, s = 0)
            }
            this.eiList.add(i, o, s)
        }, s.prototype.toString = function () {
            var t = new Ea;
            t.append("edge " + this._name + ": "), t.append("LINESTRING (");
            for (var e = 0; e < this.pts.length; e++) 0 < e && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
            return t.append(")  " + this._label + " " + this._depthDelta), t.toString()
        }, s.prototype.isPointwiseEqual = function (t) {
            if (this.pts.length !== t.pts.length) return !1;
            for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;
            return !0
        }, s.prototype.setDepthDelta = function (t) {
            this._depthDelta = t
        }, s.prototype.getEdgeIntersectionList = function () {
            return this.eiList
        }, s.prototype.addIntersections = function (t, e, n) {
            for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r)
        }, s.prototype.interfaces_ = function () {
            return []
        }, s.prototype.getClass = function () {
            return s
        }, s.updateIM = function () {
            if (2 !== arguments.length) return r.prototype.updateIM.apply(this, arguments);
            var t = arguments[0], e = arguments[1];
            e.setAtLeastIfValid(t.getLocation(0, Oc.ON), t.getLocation(1, Oc.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, Oc.LEFT), t.getLocation(1, Oc.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, Oc.RIGHT), t.getLocation(1, Oc.RIGHT), 2))
        }, s
    }(Uc), hl = function (t) {
        this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new tl, this._bufParams = t || null
    };
    hl.prototype.setWorkingPrecisionModel = function (t) {
        this._workingPrecisionModel = t
    }, hl.prototype.insertUniqueEdge = function (t) {
        var e = this._edgeList.findEqualEdge(t);
        if (null !== e) {
            var n = e.getLabel(), r = t.getLabel();
            e.isPointwiseEqual(t) || (r = new kc(t.getLabel())).flip(), n.merge(r);
            var i = hl.depthDelta(r), o = e.getDepthDelta() + i;
            e.setDepthDelta(o)
        } else this._edgeList.add(t), t.setDepthDelta(hl.depthDelta(t.getLabel()))
    }, hl.prototype.buildSubgraphs = function (t, e) {
        for (var n = new fu, r = t.iterator(); r.hasNext();) {
            var i = r.next(), o = i.getRightmostCoordinate(), s = new jh(n).getDepth(o);
            i.computeDepth(s), i.findResultEdges(), n.add(i), e.add(i.getDirectedEdges(), i.getNodes())
        }
    }, hl.prototype.createSubgraphs = function (t) {
        for (var e = new fu, n = t.getNodes().iterator(); n.hasNext();) {
            var r = n.next();
            if (!r.isVisited()) {
                var i = new Gc;
                i.create(r), e.add(i)
            }
        }
        return ah.sort(e, ah.reverseOrder()), e
    }, hl.prototype.createEmptyResultGeometry = function () {
        return this._geomFact.createPolygon()
    }, hl.prototype.getNoder = function (t) {
        if (null !== this._workingNoder) return this._workingNoder;
        var e = new Lh, n = new Va;
        return n.setPrecisionModel(t), e.setSegmentIntersector(new nl(n)), e
    }, hl.prototype.buffer = function (t, e) {
        var n = this._workingPrecisionModel;
        null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();
        var r = new zh(n, this._bufParams), i = new Vh(t, e, r).getCurves();
        if (i.size() <= 0) return this.createEmptyResultGeometry();
        this.computeNodedEdges(i, n), this._graph = new Qc(new Qh), this._graph.addEdges(this._edgeList.getEdges());
        var o = this.createSubgraphs(this._graph), s = new $c(this._geomFact);
        this.buildSubgraphs(o, s);
        var a = s.getPolygons();
        return a.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(a)
    }, hl.prototype.computeNodedEdges = function (t, e) {
        var n = this.getNoder(e);
        n.computeNodes(t);
        for (var r = n.getNodedSubstrings().iterator(); r.hasNext();) {
            var i = r.next(), o = i.getCoordinates();
            if (2 !== o.length || !o[0].equals2D(o[1])) {
                var s = i.getData(), a = new cl(i.getCoordinates(), new kc(s));
                this.insertUniqueEdge(a)
            }
        }
    }, hl.prototype.setNoder = function (t) {
        this._workingNoder = t
    }, hl.prototype.interfaces_ = function () {
        return []
    }, hl.prototype.getClass = function () {
        return hl
    }, hl.depthDelta = function (t) {
        var e = t.getLocation(0, Oc.LEFT), n = t.getLocation(0, Oc.RIGHT);
        return e === ya.INTERIOR && n === ya.EXTERIOR ? 1 : e === ya.EXTERIOR && n === ya.INTERIOR ? -1 : 0
    }, hl.convertSegStrings = function (t) {
        for (var e = new bc, n = new fu; t.hasNext();) {
            var r = t.next(), i = e.createLineString(r.getCoordinates());
            n.add(i)
        }
        return e.buildGeometry(n)
    };
    var ll = function () {
        if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            this._noder = t, this._scaleFactor = e, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision()
        } else if (4 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2], o = arguments[3];
            this._noder = n, this._scaleFactor = r, this._offsetX = i, this._offsetY = o, this._isScaled = !this.isIntegerPrecision()
        }
    };
    ll.prototype.rescale = function () {
        if (ma(arguments[0], uu)) for (var t = arguments[0].iterator(); t.hasNext();) {
            var e = t.next();
            this.rescale(e.getCoordinates())
        } else if (arguments[0] instanceof Array) {
            for (var n = arguments[0], r = 0; r < n.length; r++) n[r].x = n[r].x / this._scaleFactor + this._offsetX, n[r].y = n[r].y / this._scaleFactor + this._offsetY;
            2 === n.length && n[0].equals2D(n[1]) && Ra.out.println(n)
        }
    }, ll.prototype.scale = function () {
        if (ma(arguments[0], uu)) {
            for (var t = arguments[0], e = new fu, n = t.iterator(); n.hasNext();) {
                var r = n.next();
                e.add(new Eh(this.scale(r.getCoordinates()), r.getData()))
            }
            return e
        }
        if (arguments[0] instanceof Array) {
            for (var i = arguments[0], o = new Array(i.length).fill(null), s = 0; s < i.length; s++) o[s] = new pa(Math.round((i[s].x - this._offsetX) * this._scaleFactor), Math.round((i[s].y - this._offsetY) * this._scaleFactor), i[s].z);
            return yu.removeRepeatedPoints(o)
        }
    }, ll.prototype.isIntegerPrecision = function () {
        return 1 === this._scaleFactor
    }, ll.prototype.getNodedSubstrings = function () {
        var t = this._noder.getNodedSubstrings();
        return this._isScaled && this.rescale(t), t
    }, ll.prototype.computeNodes = function (t) {
        var e = t;
        this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e)
    }, ll.prototype.interfaces_ = function () {
        return [Sh]
    }, ll.prototype.getClass = function () {
        return ll
    };
    var pl = function () {
        this._li = new Va, this._segStrings = null;
        var t = arguments[0];
        this._segStrings = t
    }, fl = {fact: {configurable: !0}};
    pl.prototype.checkEndPtVertexIntersections = function () {
        if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {
            var e = t.next().getCoordinates();
            this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings)
        } else if (2 === arguments.length) for (var n = arguments[0], r = arguments[1].iterator(); r.hasNext();) for (var i = r.next().getCoordinates(), o = 1; o < i.length - 1; o++) if (i[o].equals(n)) throw new za("found endpt/interior pt intersection at index " + o + " :pt " + n)
    }, pl.prototype.checkInteriorIntersections = function () {
        if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) {
            var r = n.next();
            this.checkInteriorIntersections(e, r)
        } else if (2 === arguments.length) for (var i = arguments[0], o = arguments[1], s = i.getCoordinates(), a = o.getCoordinates(), u = 0; u < s.length - 1; u++) for (var c = 0; c < a.length - 1; c++) this.checkInteriorIntersections(i, u, o, c); else if (4 === arguments.length) {
            var h = arguments[0], l = arguments[1], p = arguments[2], f = arguments[3];
            if (h === p && l === f) return null;
            var g = h.getCoordinates()[l], d = h.getCoordinates()[l + 1], y = p.getCoordinates()[f],
                _ = p.getCoordinates()[f + 1];
            if (this._li.computeIntersection(g, d, y, _), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g, d) || this.hasInteriorIntersection(this._li, y, _))) throw new za("found non-noded intersection at " + g + "-" + d + " and " + y + "-" + _)
        }
    }, pl.prototype.checkValid = function () {
        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses()
    }, pl.prototype.checkCollapses = function () {
        if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {
            var e = t.next();
            this.checkCollapses(e)
        } else if (1 === arguments.length) for (var n = arguments[0].getCoordinates(), r = 0; r < n.length - 2; r++) this.checkCollapse(n[r], n[r + 1], n[r + 2])
    }, pl.prototype.hasInteriorIntersection = function (t, e, n) {
        for (var r = 0; r < t.getIntersectionNum(); r++) {
            var i = t.getIntersection(r);
            if (!i.equals(e) && !i.equals(n)) return !0
        }
        return !1
    }, pl.prototype.checkCollapse = function (t, e, n) {
        if (t.equals(n)) throw new za("found non-noded collapse at " + pl.fact.createLineString([t, e, n]))
    }, pl.prototype.interfaces_ = function () {
        return []
    }, pl.prototype.getClass = function () {
        return pl
    }, fl.fact.get = function () {
        return new bc
    }, Object.defineProperties(pl, fl);
    var gl = function () {
        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
        var t = arguments[0], e = arguments[1], n = arguments[2];
        if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new oa("Scale factor must be non-zero");
        1 !== e && (this._pt = new pa(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new pa, this._p1Scaled = new pa), this.initCorners(this._pt)
    }, dl = {SAFE_ENV_EXPANSION_FACTOR: {configurable: !0}};
    gl.prototype.intersectsScaled = function (t, e) {
        var n = Math.min(t.x, e.x), r = Math.max(t.x, e.x), i = Math.min(t.y, e.y), o = Math.max(t.y, e.y),
            s = this._maxx < n || this._minx > r || this._maxy < i || this._miny > o;
        if (s) return !1;
        var a = this.intersectsToleranceSquare(t, e);
        return Xa.isTrue(!(s && a), "Found bad envelope test"), a
    }, gl.prototype.initCorners = function (t) {
        this._minx = t.x - .5, this._maxx = t.x + .5, this._miny = t.y - .5, this._maxy = t.y + .5, this._corner[0] = new pa(this._maxx, this._maxy), this._corner[1] = new pa(this._minx, this._maxy), this._corner[2] = new pa(this._minx, this._miny), this._corner[3] = new pa(this._maxx, this._miny)
    }, gl.prototype.intersects = function (t, e) {
        return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled))
    }, gl.prototype.scale = function (t) {
        return Math.round(t * this._scaleFactor)
    }, gl.prototype.getCoordinate = function () {
        return this._originalPt
    }, gl.prototype.copyScaled = function (t, e) {
        e.x = this.scale(t.x), e.y = this.scale(t.y)
    }, gl.prototype.getSafeEnvelope = function () {
        if (null === this._safeEnv) {
            var t = gl.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new Aa(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t)
        }
        return this._safeEnv
    }, gl.prototype.intersectsPixelClosure = function (t, e) {
        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection()))))
    }, gl.prototype.intersectsToleranceSquare = function (t, e) {
        var n = !1, r = !1;
        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper() || (this._li.hasIntersection() && (r = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper() || n && r || t.equals(this._pt) || e.equals(this._pt)))))
    }, gl.prototype.addSnappedNode = function (t, e) {
        var n = t.getCoordinate(e), r = t.getCoordinate(e + 1);
        return !!this.intersects(n, r) && (t.addIntersection(this.getCoordinate(), e), !0)
    }, gl.prototype.interfaces_ = function () {
        return []
    }, gl.prototype.getClass = function () {
        return gl
    }, dl.SAFE_ENV_EXPANSION_FACTOR.get = function () {
        return .75
    }, Object.defineProperties(gl, dl);
    var yl = function () {
        this.tempEnv1 = new Aa, this.selectedSegment = new wh
    };
    yl.prototype.select = function () {
        if (1 === arguments.length) ; else if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment)
        }
    }, yl.prototype.interfaces_ = function () {
        return []
    }, yl.prototype.getClass = function () {
        return yl
    };
    var _l = function () {
        this._index = null;
        var t = arguments[0];
        this._index = t
    }, ml = {HotPixelSnapAction: {configurable: !0}};
    _l.prototype.snap = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return this.snap(t, null, -1)
        }
        if (3 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = arguments[2], i = e.getSafeEnvelope(), o = new vl(e, n, r);
            return this._index.query(i, {
                interfaces_: function () {
                    return [rh]
                }, visitItem: function (t) {
                    t.select(i, o)
                }
            }), o.isNodeAdded()
        }
    }, _l.prototype.interfaces_ = function () {
        return []
    }, _l.prototype.getClass = function () {
        return _l
    }, ml.HotPixelSnapAction.get = function () {
        return vl
    }, Object.defineProperties(_l, ml);
    var vl = function (r) {
        function t() {
            r.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
            var t = arguments[0], e = arguments[1], n = arguments[2];
            this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n
        }

        return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.isNodeAdded = function () {
            return this._isNodeAdded
        }, t.prototype.select = function () {
            if (2 !== arguments.length) return r.prototype.select.apply(this, arguments);
            var t = arguments[0], e = arguments[1], n = t.getContext();
            if (null !== this._parentEdge && n === this._parentEdge && e === this._hotPixelVertexIndex) return null;
            this._isNodeAdded = this._hotPixel.addSnappedNode(n, e)
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(yl), xl = function () {
        this._li = null, this._interiorIntersections = null;
        var t = arguments[0];
        this._li = t, this._interiorIntersections = new fu
    };
    xl.prototype.processIntersections = function (t, e, n, r) {
        if (t === n && e === r) return null;
        var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], s = n.getCoordinates()[r],
            a = n.getCoordinates()[r + 1];
        if (this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u));
            t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1)
        }
    }, xl.prototype.isDone = function () {
        return !1
    }, xl.prototype.getInteriorIntersections = function () {
        return this._interiorIntersections
    }, xl.prototype.interfaces_ = function () {
        return [el]
    }, xl.prototype.getClass = function () {
        return xl
    };
    var El = function () {
        this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
        var t = arguments[0];
        this._pm = t, this._li = new Va, this._li.setPrecisionModel(t), this._scaleFactor = t.getScale()
    };
    El.prototype.checkCorrectness = function (t) {
        var e = Eh.getNodedSubstrings(t), n = new pl(e);
        try {
            n.checkValid()
        } catch (t) {
            if (!(t instanceof Pa)) throw t;
            t.printStackTrace()
        }
    }, El.prototype.getNodedSubstrings = function () {
        return Eh.getNodedSubstrings(this._nodedSegStrings)
    }, El.prototype.snapRound = function (t, e) {
        var n = this.findInteriorIntersections(t, e);
        this.computeIntersectionSnaps(n), this.computeVertexSnaps(t)
    }, El.prototype.findInteriorIntersections = function (t, e) {
        var n = new xl(e);
        return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections()
    }, El.prototype.computeVertexSnaps = function () {
        if (ma(arguments[0], uu)) for (var t = arguments[0].iterator(); t.hasNext();) {
            var e = t.next();
            this.computeVertexSnaps(e)
        } else if (arguments[0] instanceof Eh) for (var n = arguments[0], r = n.getCoordinates(), i = 0; i < r.length; i++) {
            var o = new gl(r[i], this._scaleFactor, this._li);
            this._pointSnapper.snap(o, n, i) && n.addIntersection(r[i], i)
        }
    }, El.prototype.computeNodes = function (t) {
        this._nodedSegStrings = t, this._noder = new Lh, this._pointSnapper = new _l(this._noder.getIndex()), this.snapRound(t, this._li)
    }, El.prototype.computeIntersectionSnaps = function (t) {
        for (var e = t.iterator(); e.hasNext();) {
            var n = e.next(), r = new gl(n, this._scaleFactor, this._li);
            this._pointSnapper.snap(r)
        }
    }, El.prototype.interfaces_ = function () {
        return [Sh]
    }, El.prototype.getClass = function () {
        return El
    };
    var wl = function () {
        if (this._argGeom = null, this._distance = null, this._bufParams = new Oh, this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
            var t = arguments[0];
            this._argGeom = t
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            this._argGeom = e, this._bufParams = n
        }
    }, bl = {
        CAP_ROUND: {configurable: !0},
        CAP_BUTT: {configurable: !0},
        CAP_FLAT: {configurable: !0},
        CAP_SQUARE: {configurable: !0},
        MAX_PRECISION_DIGITS: {configurable: !0}
    };
    wl.prototype.bufferFixedPrecision = function (t) {
        var e = new ll(new El(new vc(1)), t.getScale()), n = new hl(this._bufParams);
        n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance)
    }, wl.prototype.bufferReducedPrecision = function () {
        var t = this;
        if (0 === arguments.length) {
            for (var e = wl.MAX_PRECISION_DIGITS; 0 <= e; e--) {
                try {
                    t.bufferReducedPrecision(e)
                } catch (e) {
                    if (!(e instanceof Fc)) throw e;
                    t._saveException = e
                }
                if (null !== t._resultGeometry) return null
            }
            throw this._saveException
        }
        if (1 === arguments.length) {
            var n = arguments[0], r = wl.precisionScaleFactor(this._argGeom, this._distance, n), i = new vc(r);
            this.bufferFixedPrecision(i)
        }
    }, wl.prototype.computeGeometry = function () {
        if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;
        var t = this._argGeom.getFactory().getPrecisionModel();
        t.getType() === vc.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
    }, wl.prototype.setQuadrantSegments = function (t) {
        this._bufParams.setQuadrantSegments(t)
    }, wl.prototype.bufferOriginalPrecision = function () {
        try {
            var t = new hl(this._bufParams);
            this._resultGeometry = t.buffer(this._argGeom, this._distance)
        } catch (t) {
            if (!(t instanceof za)) throw t;
            this._saveException = t
        }
    }, wl.prototype.getResultGeometry = function (t) {
        return this._distance = t, this.computeGeometry(), this._resultGeometry
    }, wl.prototype.setEndCapStyle = function (t) {
        this._bufParams.setEndCapStyle(t)
    }, wl.prototype.interfaces_ = function () {
        return []
    }, wl.prototype.getClass = function () {
        return wl
    }, wl.bufferOp = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            return new wl(t).getResultGeometry(e)
        }
        if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Qa && "number" == typeof arguments[1]) {
                var n = arguments[0], r = arguments[1], i = arguments[2], o = new wl(n);
                return o.setQuadrantSegments(i), o.getResultGeometry(r)
            }
            if (arguments[2] instanceof Oh && arguments[0] instanceof Qa && "number" == typeof arguments[1]) {
                var s = arguments[0], a = arguments[1], u = arguments[2];
                return new wl(s, u).getResultGeometry(a)
            }
        } else if (4 === arguments.length) {
            var c = arguments[0], h = arguments[1], l = arguments[2], p = arguments[3], f = new wl(c);
            return f.setQuadrantSegments(l), f.setEndCapStyle(p), f.getResultGeometry(h)
        }
    }, wl.precisionScaleFactor = function (t, e, n) {
        var r = t.getEnvelopeInternal(),
            i = va.max(Math.abs(r.getMaxX()), Math.abs(r.getMaxY()), Math.abs(r.getMinX()), Math.abs(r.getMinY())) + 2 * (0 < e ? e : 0),
            o = n - Math.trunc(Math.log(i) / Math.log(10) + 1);
        return Math.pow(10, o)
    }, bl.CAP_ROUND.get = function () {
        return Oh.CAP_ROUND
    }, bl.CAP_BUTT.get = function () {
        return Oh.CAP_FLAT
    }, bl.CAP_FLAT.get = function () {
        return Oh.CAP_FLAT
    }, bl.CAP_SQUARE.get = function () {
        return Oh.CAP_SQUARE
    }, bl.MAX_PRECISION_DIGITS.get = function () {
        return 12
    }, Object.defineProperties(wl, bl);
    var Il = function () {
        this._pt = [new pa, new pa], this._distance = sa.NaN, this._isNull = !0
    };
    Il.prototype.getCoordinates = function () {
        return this._pt
    }, Il.prototype.getCoordinate = function (t) {
        return this._pt[t]
    }, Il.prototype.setMinimum = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.setMinimum(t._pt[0], t._pt[1])
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            if (this._isNull) return this.initialize(e, n), null;
            var r = e.distance(n);
            r < this._distance && this.initialize(e, n, r)
        }
    }, Il.prototype.initialize = function () {
        if (0 === arguments.length) this._isNull = !0; else if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1
        } else if (3 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2];
            this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(r), this._distance = i, this._isNull = !1
        }
    }, Il.prototype.getDistance = function () {
        return this._distance
    }, Il.prototype.setMaximum = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.setMaximum(t._pt[0], t._pt[1])
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            if (this._isNull) return this.initialize(e, n), null;
            var r = e.distance(n);
            r > this._distance && this.initialize(e, n, r)
        }
    }, Il.prototype.interfaces_ = function () {
        return []
    }, Il.prototype.getClass = function () {
        return Il
    };
    var Nl = function () {
    };
    Nl.prototype.interfaces_ = function () {
        return []
    }, Nl.prototype.getClass = function () {
        return Nl
    }, Nl.computeDistance = function () {
        if (arguments[2] instanceof Il && arguments[0] instanceof ec && arguments[1] instanceof pa) for (var t = arguments[0], e = arguments[1], n = arguments[2], r = t.getCoordinates(), i = new wh, o = 0; o < r.length - 1; o++) {
            i.setCoordinates(r[o], r[o + 1]);
            var s = i.closestPoint(e);
            n.setMinimum(s, e)
        } else if (arguments[2] instanceof Il && arguments[0] instanceof oc && arguments[1] instanceof pa) {
            var a = arguments[0], u = arguments[1], c = arguments[2];
            Nl.computeDistance(a.getExteriorRing(), u, c);
            for (var h = 0; h < a.getNumInteriorRing(); h++) Nl.computeDistance(a.getInteriorRingN(h), u, c)
        } else if (arguments[2] instanceof Il && arguments[0] instanceof Qa && arguments[1] instanceof pa) {
            var l = arguments[0], p = arguments[1], f = arguments[2];
            if (l instanceof ec) Nl.computeDistance(l, p, f); else if (l instanceof oc) Nl.computeDistance(l, p, f); else if (l instanceof ju) for (var g = l, d = 0; d < g.getNumGeometries(); d++) {
                var y = g.getGeometryN(d);
                Nl.computeDistance(y, p, f)
            } else f.setMinimum(l.getCoordinate(), p)
        } else if (arguments[2] instanceof Il && arguments[0] instanceof wh && arguments[1] instanceof pa) {
            var _ = arguments[0], m = arguments[1], v = arguments[2], x = _.closestPoint(m);
            v.setMinimum(x, m)
        }
    };
    var Cl = function (t) {
        this._maxPtDist = new Il, this._inputGeom = t || null
    }, Sl = {MaxPointDistanceFilter: {configurable: !0}, MaxMidpointDistanceFilter: {configurable: !0}};
    Cl.prototype.computeMaxMidpointDistance = function (t) {
        var e = new Ll(this._inputGeom);
        t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance())
    }, Cl.prototype.computeMaxVertexDistance = function (t) {
        var e = new Ml(this._inputGeom);
        t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance())
    }, Cl.prototype.findDistance = function (t) {
        return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance()
    }, Cl.prototype.getDistancePoints = function () {
        return this._maxPtDist
    }, Cl.prototype.interfaces_ = function () {
        return []
    }, Cl.prototype.getClass = function () {
        return Cl
    }, Sl.MaxPointDistanceFilter.get = function () {
        return Ml
    }, Sl.MaxMidpointDistanceFilter.get = function () {
        return Ll
    }, Object.defineProperties(Cl, Sl);
    var Ml = function (t) {
        this._maxPtDist = new Il, this._minPtDist = new Il, this._geom = t || null
    };
    Ml.prototype.filter = function (t) {
        this._minPtDist.initialize(), Nl.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
    }, Ml.prototype.getMaxPointDistance = function () {
        return this._maxPtDist
    }, Ml.prototype.interfaces_ = function () {
        return [eu]
    }, Ml.prototype.getClass = function () {
        return Ml
    };
    var Ll = function (t) {
        this._maxPtDist = new Il, this._minPtDist = new Il, this._geom = t || null
    };
    Ll.prototype.filter = function (t, e) {
        if (0 === e) return null;
        var n = t.getCoordinate(e - 1), r = t.getCoordinate(e), i = new pa((n.x + r.x) / 2, (n.y + r.y) / 2);
        this._minPtDist.initialize(), Nl.computeDistance(this._geom, i, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
    }, Ll.prototype.isDone = function () {
        return !1
    }, Ll.prototype.isGeometryChanged = function () {
        return !1
    }, Ll.prototype.getMaxPointDistance = function () {
        return this._maxPtDist
    }, Ll.prototype.interfaces_ = function () {
        return [zu]
    }, Ll.prototype.getClass = function () {
        return Ll
    };
    var Pl = function (t) {
        this._comps = t || null
    };
    Pl.prototype.filter = function (t) {
        t instanceof oc && this._comps.add(t)
    }, Pl.prototype.interfaces_ = function () {
        return [ku]
    }, Pl.prototype.getClass = function () {
        return Pl
    }, Pl.getPolygons = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return Pl.getPolygons(t, new fu)
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return e instanceof oc ? n.add(e) : e instanceof ju && e.apply(new Pl(n)), n
        }
    };
    var Ol = function () {
        if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) {
            var t = arguments[0];
            this._lines = t
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            this._lines = e, this._isForcedToLineString = n
        }
    };
    Ol.prototype.filter = function (t) {
        if (this._isForcedToLineString && t instanceof ac) {
            var e = t.getFactory().createLineString(t.getCoordinateSequence());
            return this._lines.add(e), null
        }
        t instanceof ec && this._lines.add(t)
    }, Ol.prototype.setForceToLineString = function (t) {
        this._isForcedToLineString = t
    }, Ol.prototype.interfaces_ = function () {
        return [Ka]
    }, Ol.prototype.getClass = function () {
        return Ol
    }, Ol.getGeometry = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return t.getFactory().buildGeometry(Ol.getLines(t))
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return e.getFactory().buildGeometry(Ol.getLines(e, n))
        }
    }, Ol.getLines = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return Ol.getLines(t, !1)
        }
        if (2 === arguments.length) {
            if (ma(arguments[0], uu) && ma(arguments[1], uu)) {
                for (var e = arguments[0], n = arguments[1], r = e.iterator(); r.hasNext();) {
                    var i = r.next();
                    Ol.getLines(i, n)
                }
                return n
            }
            if (arguments[0] instanceof Qa && "boolean" == typeof arguments[1]) {
                var o = arguments[0], s = arguments[1], a = new fu;
                return o.apply(new Ol(a, s)), a
            }
            if (arguments[0] instanceof Qa && ma(arguments[1], uu)) {
                var u = arguments[0], c = arguments[1];
                return u instanceof ec ? c.add(u) : u.apply(new Ol(c)), c
            }
        } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && ma(arguments[0], uu) && ma(arguments[1], uu)) {
                for (var h = arguments[0], l = arguments[1], p = arguments[2], f = h.iterator(); f.hasNext();) {
                    var g = f.next();
                    Ol.getLines(g, l, p)
                }
                return l
            }
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof Qa && ma(arguments[1], uu)) {
                var d = arguments[0], y = arguments[1], _ = arguments[2];
                return d.apply(new Ol(y, _)), y
            }
        }
    };
    var Rl = function () {
        if (this._boundaryRule = nu.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length) ; else if (1 === arguments.length) {
            var t = arguments[0];
            if (null === t) throw new oa("Rule must be non-null");
            this._boundaryRule = t
        }
    };
    Rl.prototype.locateInternal = function () {
        if (arguments[0] instanceof pa && arguments[1] instanceof oc) {
            var t = arguments[0], e = arguments[1];
            if (e.isEmpty()) return ya.EXTERIOR;
            var n = e.getExteriorRing(), r = this.locateInPolygonRing(t, n);
            if (r === ya.EXTERIOR) return ya.EXTERIOR;
            if (r === ya.BOUNDARY) return ya.BOUNDARY;
            for (var i = 0; i < e.getNumInteriorRing(); i++) {
                var o = e.getInteriorRingN(i), s = this.locateInPolygonRing(t, o);
                if (s === ya.INTERIOR) return ya.EXTERIOR;
                if (s === ya.BOUNDARY) return ya.BOUNDARY
            }
            return ya.INTERIOR
        }
        if (arguments[0] instanceof pa && arguments[1] instanceof ec) {
            var a = arguments[0], u = arguments[1];
            if (!u.getEnvelopeInternal().intersects(a)) return ya.EXTERIOR;
            var c = u.getCoordinates();
            return u.isClosed() || !a.equals(c[0]) && !a.equals(c[c.length - 1]) ? Ja.isOnLine(a, c) ? ya.INTERIOR : ya.EXTERIOR : ya.BOUNDARY
        }
        if (arguments[0] instanceof pa && arguments[1] instanceof rc) {
            var h = arguments[0];
            return arguments[1].getCoordinate().equals2D(h) ? ya.INTERIOR : ya.EXTERIOR
        }
    }, Rl.prototype.locateInPolygonRing = function (t, e) {
        return e.getEnvelopeInternal().intersects(t) ? Ja.locatePointInRing(t, e.getCoordinates()) : ya.EXTERIOR
    }, Rl.prototype.intersects = function (t, e) {
        return this.locate(t, e) !== ya.EXTERIOR
    }, Rl.prototype.updateLocationInfo = function (t) {
        t === ya.INTERIOR && (this._isIn = !0), t === ya.BOUNDARY && this._numBoundaries++
    }, Rl.prototype.computeLocation = function (t, e) {
        if (e instanceof rc && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof ec) this.updateLocationInfo(this.locateInternal(t, e)); else if (e instanceof oc) this.updateLocationInfo(this.locateInternal(t, e)); else if (e instanceof Xu) for (var n = e, r = 0; r < n.getNumGeometries(); r++) {
            var i = n.getGeometryN(r);
            this.updateLocationInfo(this.locateInternal(t, i))
        } else if (e instanceof uc) for (var o = e, s = 0; s < o.getNumGeometries(); s++) {
            var a = o.getGeometryN(s);
            this.updateLocationInfo(this.locateInternal(t, a))
        } else if (e instanceof ju) for (var u = new Wh(e); u.hasNext();) {
            var c = u.next();
            c !== e && this.computeLocation(t, c)
        }
    }, Rl.prototype.locate = function (t, e) {
        return e.isEmpty() ? ya.EXTERIOR : e instanceof ec ? this.locateInternal(t, e) : e instanceof oc ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? ya.BOUNDARY : 0 < this._numBoundaries || this._isIn ? ya.INTERIOR : ya.EXTERIOR)
    }, Rl.prototype.interfaces_ = function () {
        return []
    }, Rl.prototype.getClass = function () {
        return Rl
    };
    var Tl = function t() {
        if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            t.call(this, e, t.INSIDE_AREA, n)
        } else if (3 === arguments.length) {
            var r = arguments[0], i = arguments[1], o = arguments[2];
            this._component = r, this._segIndex = i, this._pt = o
        }
    }, Al = {INSIDE_AREA: {configurable: !0}};
    Tl.prototype.isInsideArea = function () {
        return this._segIndex === Tl.INSIDE_AREA
    }, Tl.prototype.getCoordinate = function () {
        return this._pt
    }, Tl.prototype.getGeometryComponent = function () {
        return this._component
    }, Tl.prototype.getSegmentIndex = function () {
        return this._segIndex
    }, Tl.prototype.interfaces_ = function () {
        return []
    }, Tl.prototype.getClass = function () {
        return Tl
    }, Al.INSIDE_AREA.get = function () {
        return -1
    }, Object.defineProperties(Tl, Al);
    var Dl = function (t) {
        this._pts = t || null
    };
    Dl.prototype.filter = function (t) {
        t instanceof rc && this._pts.add(t)
    }, Dl.prototype.interfaces_ = function () {
        return [ku]
    }, Dl.prototype.getClass = function () {
        return Dl
    }, Dl.getPoints = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return t instanceof rc ? ah.singletonList(t) : Dl.getPoints(t, new fu)
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return e instanceof rc ? n.add(e) : e instanceof ju && e.apply(new Dl(n)), n
        }
    };
    var Fl = function () {
        this._locations = null;
        var t = arguments[0];
        this._locations = t
    };
    Fl.prototype.filter = function (t) {
        (t instanceof rc || t instanceof ec || t instanceof oc) && this._locations.add(new Tl(t, 0, t.getCoordinate()))
    }, Fl.prototype.interfaces_ = function () {
        return [ku]
    }, Fl.prototype.getClass = function () {
        return Fl
    }, Fl.getLocations = function (t) {
        var e = new fu;
        return t.apply(new Fl(e)), e
    };
    var ql = function () {
        if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Rl, this._minDistanceLocation = null, this._minDistance = sa.MAX_VALUE, 2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            this._geom = [t, e], this._terminateDistance = 0
        } else if (3 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2];
            this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = r, this._terminateDistance = i
        }
    };
    ql.prototype.computeContainmentDistance = function () {
        if (0 === arguments.length) {
            var t = new Array(2).fill(null);
            if (this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance) return null;
            this.computeContainmentDistance(1, t)
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = 1 - e, i = Pl.getPolygons(this._geom[e]);
            if (0 < i.size()) {
                var o = Fl.getLocations(this._geom[r]);
                if (this.computeContainmentDistance(o, i, n), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[r] = n[0], this._minDistanceLocation[e] = n[1], null
            }
        } else if (3 === arguments.length) if (arguments[2] instanceof Array && ma(arguments[0], lu) && ma(arguments[1], lu)) {
            for (var s = arguments[0], a = arguments[1], u = arguments[2], c = 0; c < s.size(); c++) for (var h = s.get(c), l = 0; l < a.size(); l++) if (this.computeContainmentDistance(h, a.get(l), u), this._minDistance <= this._terminateDistance) return null
        } else if (arguments[2] instanceof Array && arguments[0] instanceof Tl && arguments[1] instanceof oc) {
            var p = arguments[0], f = arguments[1], g = arguments[2], d = p.getCoordinate();
            if (ya.EXTERIOR !== this._ptLocator.locate(d, f)) return g[this._minDistance = 0] = p, g[1] = new Tl(f, d), null
        }
    }, ql.prototype.computeMinDistanceLinesPoints = function (t, e, n) {
        for (var r = 0; r < t.size(); r++) for (var i = t.get(r), o = 0; o < e.size(); o++) {
            var s = e.get(o);
            if (this.computeMinDistance(i, s, n), this._minDistance <= this._terminateDistance) return null
        }
    }, ql.prototype.computeFacetDistance = function () {
        var t = new Array(2).fill(null), e = Ol.getLines(this._geom[0]), n = Ol.getLines(this._geom[1]),
            r = Dl.getPoints(this._geom[0]), i = Dl.getPoints(this._geom[1]);
        return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, i, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, r, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(r, i, t), void this.updateMinDistance(t, !1))))
    }, ql.prototype.nearestLocations = function () {
        return this.computeMinDistance(), this._minDistanceLocation
    }, ql.prototype.updateMinDistance = function (t, e) {
        if (null === t[0]) return null;
        this._minDistanceLocation[1] = e ? (this._minDistanceLocation[0] = t[1], t[0]) : (this._minDistanceLocation[0] = t[0], t[1])
    }, ql.prototype.nearestPoints = function () {
        return this.computeMinDistance(), [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()]
    }, ql.prototype.computeMinDistance = function () {
        if (0 === arguments.length) {
            if (null !== this._minDistanceLocation) return null;
            if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance) return null;
            this.computeFacetDistance()
        } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof ec && arguments[1] instanceof rc) {
            var t = arguments[0], e = arguments[1], n = arguments[2];
            if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance) return null;
            for (var r = t.getCoordinates(), i = e.getCoordinate(), o = 0; o < r.length - 1; o++) {
                var s = Ja.distancePointLine(i, r[o], r[o + 1]);
                if (s < this._minDistance) {
                    this._minDistance = s;
                    var a = new wh(r[o], r[o + 1]).closestPoint(i);
                    n[0] = new Tl(t, o, a), n[1] = new Tl(e, 0, i)
                }
                if (this._minDistance <= this._terminateDistance) return null
            }
        } else if (arguments[2] instanceof Array && arguments[0] instanceof ec && arguments[1] instanceof ec) {
            var u = arguments[0], c = arguments[1], h = arguments[2];
            if (u.getEnvelopeInternal().distance(c.getEnvelopeInternal()) > this._minDistance) return null;
            for (var l = u.getCoordinates(), p = c.getCoordinates(), f = 0; f < l.length - 1; f++) for (var g = 0; g < p.length - 1; g++) {
                var d = Ja.distanceLineLine(l[f], l[f + 1], p[g], p[g + 1]);
                if (d < this._minDistance) {
                    this._minDistance = d;
                    var y = new wh(l[f], l[f + 1]), _ = new wh(p[g], p[g + 1]), m = y.closestPoints(_);
                    h[0] = new Tl(u, f, m[0]), h[1] = new Tl(c, g, m[1])
                }
                if (this._minDistance <= this._terminateDistance) return null
            }
        }
    }, ql.prototype.computeMinDistancePoints = function (t, e, n) {
        for (var r = 0; r < t.size(); r++) for (var i = t.get(r), o = 0; o < e.size(); o++) {
            var s = e.get(o), a = i.getCoordinate().distance(s.getCoordinate());
            if (a < this._minDistance && (this._minDistance = a, n[0] = new Tl(i, 0, i.getCoordinate()), n[1] = new Tl(s, 0, s.getCoordinate())), this._minDistance <= this._terminateDistance) return null
        }
    }, ql.prototype.distance = function () {
        if (null === this._geom[0] || null === this._geom[1]) throw new oa("null geometries are not supported");
        return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance)
    }, ql.prototype.computeMinDistanceLines = function (t, e, n) {
        for (var r = 0; r < t.size(); r++) for (var i = t.get(r), o = 0; o < e.size(); o++) {
            var s = e.get(o);
            if (this.computeMinDistance(i, s, n), this._minDistance <= this._terminateDistance) return null
        }
    }, ql.prototype.interfaces_ = function () {
        return []
    }, ql.prototype.getClass = function () {
        return ql
    }, ql.distance = function (t, e) {
        return new ql(t, e).distance()
    }, ql.isWithinDistance = function (t, e, n) {
        return new ql(t, e, n).distance() <= n
    }, ql.nearestPoints = function (t, e) {
        return new ql(t, e).nearestPoints()
    };
    var Gl = function () {
        this._pt = [new pa, new pa], this._distance = sa.NaN, this._isNull = !0
    };
    Gl.prototype.getCoordinates = function () {
        return this._pt
    }, Gl.prototype.getCoordinate = function (t) {
        return this._pt[t]
    }, Gl.prototype.setMinimum = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.setMinimum(t._pt[0], t._pt[1])
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            if (this._isNull) return this.initialize(e, n), null;
            var r = e.distance(n);
            r < this._distance && this.initialize(e, n, r)
        }
    }, Gl.prototype.initialize = function () {
        if (0 === arguments.length) this._isNull = !0; else if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1
        } else if (3 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2];
            this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(r), this._distance = i, this._isNull = !1
        }
    }, Gl.prototype.toString = function () {
        return ka.toLineString(this._pt[0], this._pt[1])
    }, Gl.prototype.getDistance = function () {
        return this._distance
    }, Gl.prototype.setMaximum = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            this.setMaximum(t._pt[0], t._pt[1])
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            if (this._isNull) return this.initialize(e, n), null;
            var r = e.distance(n);
            r > this._distance && this.initialize(e, n, r)
        }
    }, Gl.prototype.interfaces_ = function () {
        return []
    }, Gl.prototype.getClass = function () {
        return Gl
    };
    var Bl = function () {
    };
    Bl.prototype.interfaces_ = function () {
        return []
    }, Bl.prototype.getClass = function () {
        return Bl
    }, Bl.computeDistance = function () {
        if (arguments[2] instanceof Gl && arguments[0] instanceof ec && arguments[1] instanceof pa) for (var t = arguments[0], e = arguments[1], n = arguments[2], r = new wh, i = t.getCoordinates(), o = 0; o < i.length - 1; o++) {
            r.setCoordinates(i[o], i[o + 1]);
            var s = r.closestPoint(e);
            n.setMinimum(s, e)
        } else if (arguments[2] instanceof Gl && arguments[0] instanceof oc && arguments[1] instanceof pa) {
            var a = arguments[0], u = arguments[1], c = arguments[2];
            Bl.computeDistance(a.getExteriorRing(), u, c);
            for (var h = 0; h < a.getNumInteriorRing(); h++) Bl.computeDistance(a.getInteriorRingN(h), u, c)
        } else if (arguments[2] instanceof Gl && arguments[0] instanceof Qa && arguments[1] instanceof pa) {
            var l = arguments[0], p = arguments[1], f = arguments[2];
            if (l instanceof ec) Bl.computeDistance(l, p, f); else if (l instanceof oc) Bl.computeDistance(l, p, f); else if (l instanceof ju) for (var g = l, d = 0; d < g.getNumGeometries(); d++) {
                var y = g.getGeometryN(d);
                Bl.computeDistance(y, p, f)
            } else f.setMinimum(l.getCoordinate(), p)
        } else if (arguments[2] instanceof Gl && arguments[0] instanceof wh && arguments[1] instanceof pa) {
            var _ = arguments[0], m = arguments[1], v = arguments[2], x = _.closestPoint(m);
            v.setMinimum(x, m)
        }
    };
    var kl = function () {
        this._g0 = null, this._g1 = null, this._ptDist = new Gl;
        var t = arguments[this._densifyFrac = 0], e = arguments[1];
        this._g0 = t, this._g1 = e
    }, zl = {MaxPointDistanceFilter: {configurable: !0}, MaxDensifiedByFractionDistanceFilter: {configurable: !0}};
    kl.prototype.getCoordinates = function () {
        return this._ptDist.getCoordinates()
    }, kl.prototype.setDensifyFraction = function (t) {
        if (1 < t || t <= 0) throw new oa("Fraction is not in range (0.0 - 1.0]");
        this._densifyFrac = t
    }, kl.prototype.compute = function (t, e) {
        this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist)
    }, kl.prototype.distance = function () {
        return this.compute(this._g0, this._g1), this._ptDist.getDistance()
    }, kl.prototype.computeOrientedDistance = function (t, e, n) {
        var r = new jl(e);
        if (t.apply(r), n.setMaximum(r.getMaxPointDistance()), 0 < this._densifyFrac) {
            var i = new Xl(e, this._densifyFrac);
            t.apply(i), n.setMaximum(i.getMaxPointDistance())
        }
    }, kl.prototype.orientedDistance = function () {
        return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance()
    }, kl.prototype.interfaces_ = function () {
        return []
    }, kl.prototype.getClass = function () {
        return kl
    }, kl.distance = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1];
            return new kl(t, e).distance()
        }
        if (3 === arguments.length) {
            var n = arguments[0], r = arguments[1], i = arguments[2], o = new kl(n, r);
            return o.setDensifyFraction(i), o.distance()
        }
    }, zl.MaxPointDistanceFilter.get = function () {
        return jl
    }, zl.MaxDensifiedByFractionDistanceFilter.get = function () {
        return Xl
    }, Object.defineProperties(kl, zl);
    var jl = function () {
        this._maxPtDist = new Gl, this._minPtDist = new Gl, this._euclideanDist = new Bl, this._geom = null;
        var t = arguments[0];
        this._geom = t
    };
    jl.prototype.filter = function (t) {
        this._minPtDist.initialize(), Bl.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
    }, jl.prototype.getMaxPointDistance = function () {
        return this._maxPtDist
    }, jl.prototype.interfaces_ = function () {
        return [eu]
    }, jl.prototype.getClass = function () {
        return jl
    };
    var Xl = function () {
        this._maxPtDist = new Gl, this._minPtDist = new Gl, this._geom = null;
        var t = arguments[this._numSubSegs = 0], e = arguments[1];
        this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e))
    };
    Xl.prototype.filter = function (t, e) {
        if (0 === e) return null;
        for (var n = t.getCoordinate(e - 1), r = t.getCoordinate(e), i = (r.x - n.x) / this._numSubSegs, o = (r.y - n.y) / this._numSubSegs, s = 0; s < this._numSubSegs; s++) {
            var a = n.x + s * i, u = n.y + s * o, c = new pa(a, u);
            this._minPtDist.initialize(), Bl.computeDistance(this._geom, c, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
        }
    }, Xl.prototype.isDone = function () {
        return !1
    }, Xl.prototype.isGeometryChanged = function () {
        return !1
    }, Xl.prototype.getMaxPointDistance = function () {
        return this._maxPtDist
    }, Xl.prototype.interfaces_ = function () {
        return [zu]
    }, Xl.prototype.getClass = function () {
        return Xl
    };
    var Ul = function (t, e, n) {
        this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._bufDistance = e || null, this._result = n || null
    }, Yl = {VERBOSE: {configurable: !0}, MAX_DISTANCE_DIFF_FRAC: {configurable: !0}};
    Ul.prototype.checkMaximumDistance = function (t, e, n) {
        var r = new kl(e, t);
        if (r.setDensifyFraction(.25), this._maxDistanceFound = r.orientedDistance(), this._maxDistanceFound > n) {
            this._isValid = !1;
            var i = r.getCoordinates();
            this._errorLocation = i[1], this._errorIndicator = t.getFactory().createLineString(i), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + ka.toLineString(i[0], i[1]) + ")"
        }
    }, Ul.prototype.isValid = function () {
        var t = Math.abs(this._bufDistance), e = Ul.MAX_DISTANCE_DIFF_FRAC * t;
        return this._minValidDistance = t - e, this._maxValidDistance = t + e, !(!this._input.isEmpty() && !this._result.isEmpty()) || (0 < this._bufDistance ? this.checkPositiveValid() : this.checkNegativeValid(), Ul.VERBOSE && Ra.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid)
    }, Ul.prototype.checkNegativeValid = function () {
        if (!(this._input instanceof oc || this._input instanceof uc || this._input instanceof ju)) return null;
        var t = this.getPolygonLines(this._input);
        if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid) return null;
        this.checkMaximumDistance(t, this._result, this._maxValidDistance)
    }, Ul.prototype.getErrorIndicator = function () {
        return this._errorIndicator
    }, Ul.prototype.checkMinimumDistance = function (t, e, n) {
        var r = new ql(t, e, n);
        if (this._minDistanceFound = r.distance(), this._minDistanceFound < n) {
            this._isValid = !1;
            var i = r.nearestPoints();
            this._errorLocation = r.nearestPoints()[1], this._errorIndicator = t.getFactory().createLineString(i), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + ka.toLineString(i[0], i[1]) + " )"
        }
    }, Ul.prototype.checkPositiveValid = function () {
        var t = this._result.getBoundary();
        if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid) return null;
        this.checkMaximumDistance(this._input, t, this._maxValidDistance)
    }, Ul.prototype.getErrorLocation = function () {
        return this._errorLocation
    }, Ul.prototype.getPolygonLines = function (t) {
        for (var e = new fu, n = new Ol(e), r = Pl.getPolygons(t).iterator(); r.hasNext();) r.next().apply(n);
        return t.getFactory().buildGeometry(e)
    }, Ul.prototype.getErrorMessage = function () {
        return this._errMsg
    }, Ul.prototype.interfaces_ = function () {
        return []
    }, Ul.prototype.getClass = function () {
        return Ul
    }, Yl.VERBOSE.get = function () {
        return !1
    }, Yl.MAX_DISTANCE_DIFF_FRAC.get = function () {
        return .012
    }, Object.defineProperties(Ul, Yl);
    var Vl = function (t, e, n) {
        this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._distance = e || null, this._result = n || null
    }, Hl = {VERBOSE: {configurable: !0}, MAX_ENV_DIFF_FRAC: {configurable: !0}};
    Vl.prototype.isValid = function () {
        return this.checkPolygonal(), this._isValid && (this.checkExpectedEmpty(), this._isValid && (this.checkEnvelope(), this._isValid && (this.checkArea(), this._isValid && this.checkDistance()))), this._isValid
    }, Vl.prototype.checkEnvelope = function () {
        if (this._distance < 0) return null;
        var t = this._distance * Vl.MAX_ENV_DIFF_FRAC;
        0 === t && (t = .001);
        var e = new Aa(this._input.getEnvelopeInternal());
        e.expandBy(this._distance);
        var n = new Aa(this._result.getEnvelopeInternal());
        n.expandBy(t), n.contains(e) || (this._isValid = !1, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report("Envelope")
    }, Vl.prototype.checkDistance = function () {
        var t = new Ul(this._input, this._distance, this._result);
        t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()), this.report("Distance")
    }, Vl.prototype.checkArea = function () {
        var t = this._input.getArea(), e = this._result.getArea();
        0 < this._distance && e < t && (this._isValid = !1, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area")
    }, Vl.prototype.checkPolygonal = function () {
        this._result instanceof oc || this._result instanceof uc || (this._isValid = !1), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal")
    }, Vl.prototype.getErrorIndicator = function () {
        return this._errorIndicator
    }, Vl.prototype.getErrorLocation = function () {
        return this._errorLocation
    }, Vl.prototype.checkExpectedEmpty = function () {
        return 2 <= this._input.getDimension() ? null : 0 < this._distance ? null : (this._result.isEmpty() || (this._isValid = !1, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"))
    }, Vl.prototype.report = function (t) {
        if (!Vl.VERBOSE) return null;
        Ra.out.println("Check " + t + ": " + (this._isValid ? "passed" : "FAILED"))
    }, Vl.prototype.getErrorMessage = function () {
        return this._errorMsg
    }, Vl.prototype.interfaces_ = function () {
        return []
    }, Vl.prototype.getClass = function () {
        return Vl
    }, Vl.isValidMsg = function (t, e, n) {
        var r = new Vl(t, e, n);
        return r.isValid() ? null : r.getErrorMessage()
    }, Vl.isValid = function (t, e, n) {
        return !!new Vl(t, e, n).isValid()
    }, Hl.VERBOSE.get = function () {
        return !1
    }, Hl.MAX_ENV_DIFF_FRAC.get = function () {
        return .012
    }, Object.defineProperties(Vl, Hl);
    var Wl = function () {
        this._pts = null, this._data = null;
        var t = arguments[0], e = arguments[1];
        this._pts = t, this._data = e
    };
    Wl.prototype.getCoordinates = function () {
        return this._pts
    }, Wl.prototype.size = function () {
        return this._pts.length
    }, Wl.prototype.getCoordinate = function (t) {
        return this._pts[t]
    }, Wl.prototype.isClosed = function () {
        return this._pts[0].equals(this._pts[this._pts.length - 1])
    }, Wl.prototype.getSegmentOctant = function (t) {
        return t === this._pts.length - 1 ? -1 : mh.octant(this.getCoordinate(t), this.getCoordinate(t + 1))
    }, Wl.prototype.setData = function (t) {
        this._data = t
    }, Wl.prototype.getData = function () {
        return this._data
    }, Wl.prototype.toString = function () {
        return ka.toLineString(new gc(this._pts))
    }, Wl.prototype.interfaces_ = function () {
        return [vh]
    }, Wl.prototype.getClass = function () {
        return Wl
    };
    var Jl = function () {
        this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new fu, this._intersectionCount = 0, this._keepIntersections = !0;
        var t = arguments[0];
        this._li = t, this._interiorIntersection = null
    };
    Jl.prototype.getInteriorIntersection = function () {
        return this._interiorIntersection
    }, Jl.prototype.setCheckEndSegmentsOnly = function (t) {
        this._isCheckEndSegmentsOnly = t
    }, Jl.prototype.getIntersectionSegments = function () {
        return this._intSegments
    }, Jl.prototype.count = function () {
        return this._intersectionCount
    }, Jl.prototype.getIntersections = function () {
        return this._intersections
    }, Jl.prototype.setFindAllIntersections = function (t) {
        this._findAllIntersections = t
    }, Jl.prototype.setKeepIntersections = function (t) {
        this._keepIntersections = t
    }, Jl.prototype.processIntersections = function (t, e, n, r) {
        if (!this._findAllIntersections && this.hasIntersection()) return null;
        if (t === n && e === r) return null;
        if (this._isCheckEndSegmentsOnly && !this.isEndSegment(t, e) && !this.isEndSegment(n, r)) return null;
        var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], s = n.getCoordinates()[r],
            a = n.getCoordinates()[r + 1];
        this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = i, this._intSegments[1] = o, this._intSegments[2] = s, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++)
    }, Jl.prototype.isEndSegment = function (t, e) {
        return 0 === e || e >= t.size() - 2
    }, Jl.prototype.hasIntersection = function () {
        return null !== this._interiorIntersection
    }, Jl.prototype.isDone = function () {
        return !this._findAllIntersections && null !== this._interiorIntersection
    }, Jl.prototype.interfaces_ = function () {
        return [el]
    }, Jl.prototype.getClass = function () {
        return Jl
    }, Jl.createAllIntersectionsFinder = function (t) {
        var e = new Jl(t);
        return e.setFindAllIntersections(!0), e
    }, Jl.createAnyIntersectionFinder = function (t) {
        return new Jl(t)
    }, Jl.createIntersectionCounter = function (t) {
        var e = new Jl(t);
        return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e
    };
    var Zl = function () {
        this._li = new Va, this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;
        var t = arguments[0];
        this._segStrings = t
    };
    Zl.prototype.execute = function () {
        if (null !== this._segInt) return null;
        this.checkInteriorIntersections()
    }, Zl.prototype.getIntersections = function () {
        return this._segInt.getIntersections()
    }, Zl.prototype.isValid = function () {
        return this.execute(), this._isValid
    }, Zl.prototype.setFindAllIntersections = function (t) {
        this._findAllIntersections = t
    }, Zl.prototype.checkInteriorIntersections = function () {
        this._isValid = !0, this._segInt = new Jl(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
        var t = new Lh;
        if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null
    }, Zl.prototype.checkValid = function () {
        if (this.execute(), !this._isValid) throw new Fc(this.getErrorMessage(), this._segInt.getInteriorIntersection())
    }, Zl.prototype.getErrorMessage = function () {
        if (this._isValid) return "no intersections found";
        var t = this._segInt.getIntersectionSegments();
        return "found non-noded intersection between " + ka.toLineString(t[0], t[1]) + " and " + ka.toLineString(t[2], t[3])
    }, Zl.prototype.interfaces_ = function () {
        return []
    }, Zl.prototype.getClass = function () {
        return Zl
    }, Zl.computeIntersections = function (t) {
        var e = new Zl(t);
        return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections()
    };
    var Kl = function t() {
        this._nv = null;
        var e = arguments[0];
        this._nv = new Zl(t.toSegmentStrings(e))
    };
    Kl.prototype.checkValid = function () {
        this._nv.checkValid()
    }, Kl.prototype.interfaces_ = function () {
        return []
    }, Kl.prototype.getClass = function () {
        return Kl
    }, Kl.toSegmentStrings = function (t) {
        for (var e = new fu, n = t.iterator(); n.hasNext();) {
            var r = n.next();
            e.add(new Wl(r.getCoordinates(), r))
        }
        return e
    }, Kl.checkValid = function (t) {
        new Kl(t).checkValid()
    };
    var Ql = function (t) {
        this._mapOp = t
    };
    Ql.prototype.map = function (t) {
        for (var e = new fu, n = 0; n < t.getNumGeometries(); n++) {
            var r = this._mapOp.map(t.getGeometryN(n));
            r.isEmpty() || e.add(r)
        }
        return t.getFactory().createGeometryCollection(bc.toGeometryArray(e))
    }, Ql.prototype.interfaces_ = function () {
        return []
    }, Ql.prototype.getClass = function () {
        return Ql
    }, Ql.map = function (t, e) {
        return new Ql(e).map(t)
    };
    var $l = function () {
        this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new fu, this._resultLineList = new fu;
        var t = arguments[0], e = arguments[1], n = arguments[2];
        this._op = t, this._geometryFactory = e, this._ptLocator = n
    };
    $l.prototype.collectLines = function (t) {
        for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
            var n = e.next();
            this.collectLineEdge(n, t, this._lineEdgesList), this.collectBoundaryTouchEdge(n, t, this._lineEdgesList)
        }
    }, $l.prototype.labelIsolatedLine = function (t, e) {
        var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));
        t.getLabel().setLocation(e, n)
    }, $l.prototype.build = function (t) {
        return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList
    }, $l.prototype.collectLineEdge = function (t, e, n) {
        var r = t.getLabel(), i = t.getEdge();
        t.isLineEdge() && (t.isVisited() || !Tp.isResultOfOp(r, e) || i.isCovered() || (n.add(i), t.setVisitedEdge(!0)))
    }, $l.prototype.findCoveredLineEdges = function () {
        for (var t = this._op.getGraph().getNodes().iterator(); t.hasNext();) t.next().getEdges().findCoveredLineEdges();
        for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
            var n = e.next(), r = n.getEdge();
            if (n.isLineEdge() && !r.isCoveredSet()) {
                var i = this._op.isCoveredByA(n.getCoordinate());
                r.setCovered(i)
            }
        }
    }, $l.prototype.labelIsolatedLines = function (t) {
        for (var e = t.iterator(); e.hasNext();) {
            var n = e.next(), r = n.getLabel();
            n.isIsolated() && (r.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1))
        }
    }, $l.prototype.buildLines = function (t) {
        for (var e = this._lineEdgesList.iterator(); e.hasNext();) {
            var n = e.next(), r = this._geometryFactory.createLineString(n.getCoordinates());
            this._resultLineList.add(r), n.setInResult(!0)
        }
    }, $l.prototype.collectBoundaryTouchEdge = function (t, e, n) {
        var r = t.getLabel();
        return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (Xa.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void(Tp.isResultOfOp(r, e) && e === Tp.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))))
    }, $l.prototype.interfaces_ = function () {
        return []
    }, $l.prototype.getClass = function () {
        return $l
    };
    var tp = function () {
        this._op = null, this._geometryFactory = null, this._resultPointList = new fu;
        var t = arguments[0], e = arguments[1];
        this._op = t, this._geometryFactory = e
    };
    tp.prototype.filterCoveredNodeToPoint = function (t) {
        var e = t.getCoordinate();
        if (!this._op.isCoveredByLA(e)) {
            var n = this._geometryFactory.createPoint(e);
            this._resultPointList.add(n)
        }
    }, tp.prototype.extractNonCoveredResultNodes = function (t) {
        for (var e = this._op.getGraph().getNodes().iterator(); e.hasNext();) {
            var n = e.next();
            if (!(n.isInResult() || n.isIncidentEdgeInResult() || 0 !== n.getEdges().getDegree() && t !== Tp.INTERSECTION)) {
                var r = n.getLabel();
                Tp.isResultOfOp(r, t) && this.filterCoveredNodeToPoint(n)
            }
        }
    }, tp.prototype.build = function (t) {
        return this.extractNonCoveredResultNodes(t), this._resultPointList
    }, tp.prototype.interfaces_ = function () {
        return []
    }, tp.prototype.getClass = function () {
        return tp
    };
    var ep = function () {
        this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1
    };
    ep.prototype.transformPoint = function (t, e) {
        return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
    }, ep.prototype.transformPolygon = function (t, e) {
        var n = !0, r = this.transformLinearRing(t.getExteriorRing(), t);
        null !== r && r instanceof ac && !r.isEmpty() || (n = !1);
        for (var i = new fu, o = 0; o < t.getNumInteriorRing(); o++) {
            var s = this.transformLinearRing(t.getInteriorRingN(o), t);
            null === s || s.isEmpty() || (s instanceof ac || (n = !1), i.add(s))
        }
        if (n) return this._factory.createPolygon(r, i.toArray([]));
        var a = new fu;
        return null !== r && a.add(r), a.addAll(i), this._factory.buildGeometry(a)
    }, ep.prototype.createCoordinateSequence = function (t) {
        return this._factory.getCoordinateSequenceFactory().create(t)
    }, ep.prototype.getInputGeometry = function () {
        return this._inputGeom
    }, ep.prototype.transformMultiLineString = function (t, e) {
        for (var n = new fu, r = 0; r < t.getNumGeometries(); r++) {
            var i = this.transformLineString(t.getGeometryN(r), t);
            null !== i && (i.isEmpty() || n.add(i))
        }
        return this._factory.buildGeometry(n)
    }, ep.prototype.transformCoordinates = function (t, e) {
        return this.copy(t)
    }, ep.prototype.transformLineString = function (t, e) {
        return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
    }, ep.prototype.transformMultiPoint = function (t, e) {
        for (var n = new fu, r = 0; r < t.getNumGeometries(); r++) {
            var i = this.transformPoint(t.getGeometryN(r), t);
            null !== i && (i.isEmpty() || n.add(i))
        }
        return this._factory.buildGeometry(n)
    }, ep.prototype.transformMultiPolygon = function (t, e) {
        for (var n = new fu, r = 0; r < t.getNumGeometries(); r++) {
            var i = this.transformPolygon(t.getGeometryN(r), t);
            null !== i && (i.isEmpty() || n.add(i))
        }
        return this._factory.buildGeometry(n)
    }, ep.prototype.copy = function (t) {
        return t.copy()
    }, ep.prototype.transformGeometryCollection = function (t, e) {
        for (var n = new fu, r = 0; r < t.getNumGeometries(); r++) {
            var i = this.transform(t.getGeometryN(r));
            null !== i && (this._pruneEmptyGeometry && i.isEmpty() || n.add(i))
        }
        return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(bc.toGeometryArray(n)) : this._factory.buildGeometry(n)
    }, ep.prototype.transform = function (t) {
        if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof rc) return this.transformPoint(t, null);
        if (t instanceof sc) return this.transformMultiPoint(t, null);
        if (t instanceof ac) return this.transformLinearRing(t, null);
        if (t instanceof ec) return this.transformLineString(t, null);
        if (t instanceof Xu) return this.transformMultiLineString(t, null);
        if (t instanceof oc) return this.transformPolygon(t, null);
        if (t instanceof uc) return this.transformMultiPolygon(t, null);
        if (t instanceof ju) return this.transformGeometryCollection(t, null);
        throw new oa("Unknown Geometry subtype: " + t.getClass().getName())
    }, ep.prototype.transformLinearRing = function (t, e) {
        var n = this.transformCoordinates(t.getCoordinateSequence(), t);
        if (null === n) return this._factory.createLinearRing(null);
        var r = n.size();
        return 0 < r && r < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n)
    }, ep.prototype.interfaces_ = function () {
        return []
    }, ep.prototype.getClass = function () {
        return ep
    };
    var np = function t() {
        if (this._snapTolerance = 0, this._srcPts = null, this._seg = new wh, this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof ec && "number" == typeof arguments[1]) {
            var e = arguments[0], n = arguments[1];
            t.call(this, e.getCoordinates(), n)
        } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
            var r = arguments[0], i = arguments[1];
            this._srcPts = r, this._isClosed = t.isClosed(r), this._snapTolerance = i
        }
    };
    np.prototype.snapVertices = function (t, e) {
        for (var n = this._isClosed ? t.size() - 1 : t.size(), r = 0; r < n; r++) {
            var i = t.get(r), o = this.findSnapForVertex(i, e);
            null !== o && (t.set(r, new pa(o)), 0 === r && this._isClosed && t.set(t.size() - 1, new pa(o)))
        }
    }, np.prototype.findSnapForVertex = function (t, e) {
        for (var n = 0; n < e.length; n++) {
            if (t.equals2D(e[n])) return null;
            if (t.distance(e[n]) < this._snapTolerance) return e[n]
        }
        return null
    }, np.prototype.snapTo = function (t) {
        var e = new du(this._srcPts);
        return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray()
    }, np.prototype.snapSegments = function (t, e) {
        if (0 === e.length) return null;
        var n = e.length;
        e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);
        for (var r = 0; r < n; r++) {
            var i = e[r], o = this.findSegmentIndexToSnap(i, t);
            0 <= o && t.add(o + 1, new pa(i), !1)
        }
    }, np.prototype.findSegmentIndexToSnap = function (t, e) {
        for (var n = sa.MAX_VALUE, r = -1, i = 0; i < e.size() - 1; i++) {
            if (this._seg.p0 = e.get(i), this._seg.p1 = e.get(i + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) {
                if (this._allowSnappingToSourceVertices) continue;
                return -1
            }
            var o = this._seg.distance(t);
            o < this._snapTolerance && o < n && (n = o, r = i)
        }
        return r
    }, np.prototype.setAllowSnappingToSourceVertices = function (t) {
        this._allowSnappingToSourceVertices = t
    }, np.prototype.interfaces_ = function () {
        return []
    }, np.prototype.getClass = function () {
        return np
    }, np.isClosed = function (t) {
        return !(t.length <= 1) && t[0].equals2D(t[t.length - 1])
    };
    var rp = function (t) {
        this._srcGeom = t || null
    }, ip = {SNAP_PRECISION_FACTOR: {configurable: !0}};
    rp.prototype.snapTo = function (t, e) {
        var n = this.extractTargetCoordinates(t);
        return new op(e, n).transform(this._srcGeom)
    }, rp.prototype.snapToSelf = function (t, e) {
        var n = this.extractTargetCoordinates(this._srcGeom), r = new op(t, n, !0).transform(this._srcGeom), i = r;
        return e && ma(i, ic) && (i = r.buffer(0)), i
    }, rp.prototype.computeSnapTolerance = function (t) {
        return this.computeMinimumSegmentLength(t) / 10
    }, rp.prototype.extractTargetCoordinates = function (t) {
        for (var e = new Du, n = t.getCoordinates(), r = 0; r < n.length; r++) e.add(n[r]);
        return e.toArray(new Array(0).fill(null))
    }, rp.prototype.computeMinimumSegmentLength = function (t) {
        for (var e = sa.MAX_VALUE, n = 0; n < t.length - 1; n++) {
            var r = t[n].distance(t[n + 1]);
            r < e && (e = r)
        }
        return e
    }, rp.prototype.interfaces_ = function () {
        return []
    }, rp.prototype.getClass = function () {
        return rp
    }, rp.snap = function (t, e, n) {
        var r = new Array(2).fill(null), i = new rp(t);
        r[0] = i.snapTo(e, n);
        var o = new rp(e);
        return r[1] = o.snapTo(r[0], n), r
    }, rp.computeOverlaySnapTolerance = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = rp.computeSizeBasedSnapTolerance(t), n = t.getPrecisionModel();
            if (n.getType() === vc.FIXED) {
                var r = 1 / n.getScale() * 2 / 1.415;
                e < r && (e = r)
            }
            return e
        }
        if (2 === arguments.length) {
            var i = arguments[0], o = arguments[1];
            return Math.min(rp.computeOverlaySnapTolerance(i), rp.computeOverlaySnapTolerance(o))
        }
    }, rp.computeSizeBasedSnapTolerance = function (t) {
        var e = t.getEnvelopeInternal();
        return Math.min(e.getHeight(), e.getWidth()) * rp.SNAP_PRECISION_FACTOR
    }, rp.snapToSelf = function (t, e, n) {
        return new rp(t).snapToSelf(e, n)
    }, ip.SNAP_PRECISION_FACTOR.get = function () {
        return 1e-9
    }, Object.defineProperties(rp, ip);
    var op = function (r) {
        function t(t, e, n) {
            r.call(this), this._snapTolerance = t || null, this._snapPts = e || null, this._isSelfSnap = void 0 !== n && n
        }

        return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.snapLine = function (t, e) {
            var n = new np(t, this._snapTolerance);
            return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e)
        }, t.prototype.transformCoordinates = function (t, e) {
            var n = t.toCoordinateArray(), r = this.snapLine(n, this._snapPts);
            return this._factory.getCoordinateSequenceFactory().create(r)
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(ep), sp = function () {
        this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null
    };
    sp.prototype.getCommon = function () {
        return sa.longBitsToDouble(this._commonBits)
    }, sp.prototype.add = function (t) {
        var e = sa.doubleToLongBits(t);
        return this._isFirst ? (this._commonBits = e, this._commonSignExp = sp.signExpBits(this._commonBits), this._isFirst = !1, null) : sp.signExpBits(e) !== this._commonSignExp ? (this._commonBits = 0, null) : (this._commonMantissaBitsCount = sp.numCommonMostSigMantissaBits(this._commonBits, e), void(this._commonBits = sp.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount))))
    }, sp.prototype.toString = function () {
        if (1 === arguments.length) {
            var t = arguments[0], e = sa.longBitsToDouble(t),
                n = "0000000000000000000000000000000000000000000000000000000000000000" + sa.toBinaryString(t),
                r = n.substring(n.length - 64);
            return r.substring(0, 1) + "  " + r.substring(1, 12) + "(exp) " + r.substring(12) + " [ " + e + " ]"
        }
    }, sp.prototype.interfaces_ = function () {
        return []
    }, sp.prototype.getClass = function () {
        return sp
    }, sp.getBit = function (t, e) {
        return 0 != (t & 1 << e) ? 1 : 0
    }, sp.signExpBits = function (t) {
        return t >> 52
    }, sp.zeroLowerBits = function (t, e) {
        return t & ~((1 << e) - 1)
    }, sp.numCommonMostSigMantissaBits = function (t, e) {
        for (var n = 0, r = 52; 0 <= r; r--) {
            if (sp.getBit(t, r) !== sp.getBit(e, r)) return n;
            n++
        }
        return 52
    };
    var ap = function () {
        this._commonCoord = null, this._ccFilter = new cp
    }, up = {CommonCoordinateFilter: {configurable: !0}, Translater: {configurable: !0}};
    ap.prototype.addCommonBits = function (t) {
        var e = new hp(this._commonCoord);
        t.apply(e), t.geometryChanged()
    }, ap.prototype.removeCommonBits = function (t) {
        if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t;
        var e = new pa(this._commonCoord);
        e.x = -e.x, e.y = -e.y;
        var n = new hp(e);
        return t.apply(n), t.geometryChanged(), t
    }, ap.prototype.getCommonCoordinate = function () {
        return this._commonCoord
    }, ap.prototype.add = function (t) {
        t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate()
    }, ap.prototype.interfaces_ = function () {
        return []
    }, ap.prototype.getClass = function () {
        return ap
    }, up.CommonCoordinateFilter.get = function () {
        return cp
    }, up.Translater.get = function () {
        return hp
    }, Object.defineProperties(ap, up);
    var cp = function () {
        this._commonBitsX = new sp, this._commonBitsY = new sp
    };
    cp.prototype.filter = function (t) {
        this._commonBitsX.add(t.x), this._commonBitsY.add(t.y)
    }, cp.prototype.getCommonCoordinate = function () {
        return new pa(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
    }, cp.prototype.interfaces_ = function () {
        return [eu]
    }, cp.prototype.getClass = function () {
        return cp
    };
    var hp = function () {
        this.trans = null;
        var t = arguments[0];
        this.trans = t
    };
    hp.prototype.filter = function (t, e) {
        var n = t.getOrdinate(e, 0) + this.trans.x, r = t.getOrdinate(e, 1) + this.trans.y;
        t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, r)
    }, hp.prototype.isDone = function () {
        return !1
    }, hp.prototype.isGeometryChanged = function () {
        return !0
    }, hp.prototype.interfaces_ = function () {
        return [zu]
    }, hp.prototype.getClass = function () {
        return hp
    };
    var lp = function (t, e) {
        this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance()
    };
    lp.prototype.selfSnap = function (t) {
        return new rp(t).snapTo(t, this._snapTolerance)
    }, lp.prototype.removeCommonBits = function (t) {
        this._cbr = new ap, this._cbr.add(t[0]), this._cbr.add(t[1]);
        var e = new Array(2).fill(null);
        return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e
    }, lp.prototype.prepareResult = function (t) {
        return this._cbr.addCommonBits(t), t
    }, lp.prototype.getResultGeometry = function (t) {
        var e = this.snap(this._geom), n = Tp.overlayOp(e[0], e[1], t);
        return this.prepareResult(n)
    }, lp.prototype.checkValid = function (t) {
        t.isValid() || Ra.out.println("Snapped geometry is invalid")
    }, lp.prototype.computeSnapTolerance = function () {
        this._snapTolerance = rp.computeOverlaySnapTolerance(this._geom[0], this._geom[1])
    }, lp.prototype.snap = function (t) {
        var e = this.removeCommonBits(t);
        return rp.snap(e[0], e[1], this._snapTolerance)
    }, lp.prototype.interfaces_ = function () {
        return []
    }, lp.prototype.getClass = function () {
        return lp
    }, lp.overlayOp = function (t, e, n) {
        return new lp(t, e).getResultGeometry(n)
    }, lp.union = function (t, e) {
        return lp.overlayOp(t, e, Tp.UNION)
    }, lp.intersection = function (t, e) {
        return lp.overlayOp(t, e, Tp.INTERSECTION)
    }, lp.symDifference = function (t, e) {
        return lp.overlayOp(t, e, Tp.SYMDIFFERENCE)
    }, lp.difference = function (t, e) {
        return lp.overlayOp(t, e, Tp.DIFFERENCE)
    };
    var pp = function (t, e) {
        this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e
    };
    pp.prototype.getResultGeometry = function (t) {
        var e = null, n = !1, r = null;
        try {
            e = Tp.overlayOp(this._geom[0], this._geom[1], t), n = !0
        } catch (t) {
            if (!(t instanceof za)) throw t;
            r = t
        }
        if (!n) try {
            e = lp.overlayOp(this._geom[0], this._geom[1], t)
        } catch (t) {
            throw t instanceof za ? r : t
        }
        return e
    }, pp.prototype.interfaces_ = function () {
        return []
    }, pp.prototype.getClass = function () {
        return pp
    }, pp.overlayOp = function (t, e, n) {
        return new pp(t, e).getResultGeometry(n)
    }, pp.union = function (t, e) {
        return pp.overlayOp(t, e, Tp.UNION)
    }, pp.intersection = function (t, e) {
        return pp.overlayOp(t, e, Tp.INTERSECTION)
    }, pp.symDifference = function (t, e) {
        return pp.overlayOp(t, e, Tp.SYMDIFFERENCE)
    }, pp.difference = function (t, e) {
        return pp.overlayOp(t, e, Tp.DIFFERENCE)
    };
    var fp = function () {
        this.mce = null, this.chainIndex = null;
        var t = arguments[0], e = arguments[1];
        this.mce = t, this.chainIndex = e
    };
    fp.prototype.computeIntersections = function (t, e) {
        this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
    }, fp.prototype.interfaces_ = function () {
        return []
    }, fp.prototype.getClass = function () {
        return fp
    };
    var gp = function t() {
        if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            this._eventType = t.DELETE, this._xValue = e, this._insertEvent = n
        } else if (3 === arguments.length) {
            var r = arguments[0], i = arguments[1], o = arguments[2];
            this._eventType = t.INSERT, this._label = r, this._xValue = i, this._obj = o
        }
    }, dp = {INSERT: {configurable: !0}, DELETE: {configurable: !0}};
    gp.prototype.isDelete = function () {
        return this._eventType === gp.DELETE
    }, gp.prototype.setDeleteEventIndex = function (t) {
        this._deleteEventIndex = t
    }, gp.prototype.getObject = function () {
        return this._obj
    }, gp.prototype.compareTo = function (t) {
        var e = t;
        return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0
    }, gp.prototype.getInsertEvent = function () {
        return this._insertEvent
    }, gp.prototype.isInsert = function () {
        return this._eventType === gp.INSERT
    }, gp.prototype.isSameLabel = function (t) {
        return null !== this._label && this._label === t._label
    }, gp.prototype.getDeleteEventIndex = function () {
        return this._deleteEventIndex
    }, gp.prototype.interfaces_ = function () {
        return [ua]
    }, gp.prototype.getClass = function () {
        return gp
    }, dp.INSERT.get = function () {
        return 1
    }, dp.DELETE.get = function () {
        return 2
    }, Object.defineProperties(gp, dp);
    var yp = function () {
    };
    yp.prototype.interfaces_ = function () {
        return []
    }, yp.prototype.getClass = function () {
        return yp
    };
    var _p = function () {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;
        var t = arguments[0], e = arguments[1], n = arguments[2];
        this._li = t, this._includeProper = e, this._recordIsolated = n
    };
    _p.prototype.isTrivialIntersection = function (t, e, n, r) {
        if (t === n && 1 === this._li.getIntersectionNum()) {
            if (_p.isAdjacentSegments(e, r)) return !0;
            if (t.isClosed()) {
                var i = t.getNumPoints() - 1;
                if (0 === e && r === i || 0 === r && e === i) return !0
            }
        }
        return !1
    }, _p.prototype.getProperIntersectionPoint = function () {
        return this._properIntersectionPoint
    }, _p.prototype.setIsDoneIfProperInt = function (t) {
        this._isDoneWhenProperInt = t
    }, _p.prototype.hasProperInteriorIntersection = function () {
        return this._hasProperInterior
    }, _p.prototype.isBoundaryPointInternal = function (t, e) {
        for (var n = e.iterator(); n.hasNext();) {
            var r = n.next().getCoordinate();
            if (t.isIntersection(r)) return !0
        }
        return !1
    }, _p.prototype.hasProperIntersection = function () {
        return this._hasProper
    }, _p.prototype.hasIntersection = function () {
        return this._hasIntersection
    }, _p.prototype.isDone = function () {
        return this._isDone
    }, _p.prototype.isBoundaryPoint = function (t, e) {
        return !(null === e || !this.isBoundaryPointInternal(t, e[0]) && !this.isBoundaryPointInternal(t, e[1]))
    }, _p.prototype.setBoundaryNodes = function (t, e) {
        this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e
    }, _p.prototype.addIntersections = function (t, e, n, r) {
        if (t === n && e === r) return null;
        this.numTests++;
        var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], s = n.getCoordinates()[r],
            a = n.getCoordinates()[r + 1];
        this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))))
    }, _p.prototype.interfaces_ = function () {
        return []
    }, _p.prototype.getClass = function () {
        return _p
    }, _p.isAdjacentSegments = function (t, e) {
        return 1 === Math.abs(t - e)
    };
    var mp = function (t) {
        function e() {
            t.call(this), this.events = new fu, this.nOverlaps = null
        }

        return t && (e.__proto__ = t), ((e.prototype = Object.create(t && t.prototype)).constructor = e).prototype.prepareEvents = function () {
            ah.sort(this.events);
            for (var t = 0; t < this.events.size(); t++) {
                var e = this.events.get(t);
                e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
            }
        }, e.prototype.computeIntersections = function () {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.nOverlaps = 0, this.prepareEvents();
                for (var e = 0; e < this.events.size(); e++) {
                    var n = this.events.get(e);
                    if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break
                }
            } else if (3 === arguments.length) if (arguments[2] instanceof _p && ma(arguments[0], lu) && ma(arguments[1], lu)) {
                var r = arguments[0], i = arguments[1], o = arguments[2];
                this.addEdges(r, r), this.addEdges(i, i), this.computeIntersections(o)
            } else if ("boolean" == typeof arguments[2] && ma(arguments[0], lu) && arguments[1] instanceof _p) {
                var s = arguments[0], a = arguments[1];
                arguments[2] ? this.addEdges(s, null) : this.addEdges(s), this.computeIntersections(a)
            }
        }, e.prototype.addEdge = function (t, e) {
            for (var n = t.getMonotoneChainEdge(), r = n.getStartIndexes(), i = 0; i < r.length - 1; i++) {
                var o = new fp(n, i), s = new gp(e, n.getMinX(i), o);
                this.events.add(s), this.events.add(new gp(n.getMaxX(i), s))
            }
        }, e.prototype.processOverlaps = function (t, e, n, r) {
            for (var i = n.getObject(), o = t; o < e; o++) {
                var s = this.events.get(o);
                if (s.isInsert()) {
                    var a = s.getObject();
                    n.isSameLabel(s) || (i.computeIntersections(a, r), this.nOverlaps++)
                }
            }
        }, e.prototype.addEdges = function () {
            if (1 === arguments.length) for (var t = arguments[0].iterator(); t.hasNext();) {
                var e = t.next();
                this.addEdge(e, e)
            } else if (2 === arguments.length) for (var n = arguments[0], r = arguments[1], i = n.iterator(); i.hasNext();) {
                var o = i.next();
                this.addEdge(o, r)
            }
        }, e.prototype.interfaces_ = function () {
            return []
        }, e.prototype.getClass = function () {
            return e
        }, e
    }(yp), vp = function () {
        this._min = sa.POSITIVE_INFINITY, this._max = sa.NEGATIVE_INFINITY
    }, xp = {NodeComparator: {configurable: !0}};
    vp.prototype.getMin = function () {
        return this._min
    }, vp.prototype.intersects = function (t, e) {
        return !(this._min > e || this._max < t)
    }, vp.prototype.getMax = function () {
        return this._max
    }, vp.prototype.toString = function () {
        return ka.toLineString(new pa(this._min, 0), new pa(this._max, 0))
    }, vp.prototype.interfaces_ = function () {
        return []
    }, vp.prototype.getClass = function () {
        return vp
    }, xp.NodeComparator.get = function () {
        return Ep
    }, Object.defineProperties(vp, xp);
    var Ep = function () {
    };
    Ep.prototype.compare = function (t, e) {
        var n = t, r = e, i = (n._min + n._max) / 2, o = (r._min + r._max) / 2;
        return i < o ? -1 : o < i ? 1 : 0
    }, Ep.prototype.interfaces_ = function () {
        return [ha]
    }, Ep.prototype.getClass = function () {
        return Ep
    };
    var wp = function (r) {
        function t() {
            r.call(this), this._item = null;
            var t = arguments[0], e = arguments[1], n = arguments[2];
            this._min = t, this._max = e, this._item = n
        }

        return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.query = function (t, e, n) {
            if (!this.intersects(t, e)) return null;
            n.visitItem(this._item)
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(vp), bp = function (n) {
        function t() {
            n.call(this), this._node1 = null, this._node2 = null;
            var t = arguments[0], e = arguments[1];
            this._node1 = t, this._node2 = e, this.buildExtent(this._node1, this._node2)
        }

        return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.buildExtent = function (t, e) {
            this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max)
        }, t.prototype.query = function (t, e, n) {
            if (!this.intersects(t, e)) return null;
            null !== this._node1 && this._node1.query(t, e, n), null !== this._node2 && this._node2.query(t, e, n)
        }, t.prototype.interfaces_ = function () {
            return []
        }, t.prototype.getClass = function () {
            return t
        }, t
    }(vp), Ip = function () {
        this._leaves = new fu, this._root = null, this._level = 0
    };
    Ip.prototype.buildTree = function () {
        ah.sort(this._leaves, new vp.NodeComparator);
        for (var t = this._leaves, e = null, n = new fu; ;) {
            if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);
            e = t, t = n, n = e
        }
    }, Ip.prototype.insert = function (t, e, n) {
        if (null !== this._root) throw new Error("Index cannot be added to once it has been queried");
        this._leaves.add(new wp(t, e, n))
    }, Ip.prototype.query = function (t, e, n) {
        this.init(), this._root.query(t, e, n)
    }, Ip.prototype.buildRoot = function () {
        if (null !== this._root) return null;
        this._root = this.buildTree()
    }, Ip.prototype.printNode = function (t) {
        Ra.out.println(ka.toLineString(new pa(t._min, this._level), new pa(t._max, this._level)))
    }, Ip.prototype.init = function () {
        if (null !== this._root) return null;
        this.buildRoot()
    }, Ip.prototype.buildLevel = function (t, e) {
        this._level++, e.clear();
        for (var n = 0; n < t.size(); n += 2) {
            var r = t.get(n);
            if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(r); else {
                var i = new bp(t.get(n), t.get(n + 1));
                e.add(i)
            }
        }
    }, Ip.prototype.interfaces_ = function () {
        return []
    }, Ip.prototype.getClass = function () {
        return Ip
    };
    var Np = function () {
        this._items = new fu
    };
    Np.prototype.visitItem = function (t) {
        this._items.add(t)
    }, Np.prototype.getItems = function () {
        return this._items
    }, Np.prototype.interfaces_ = function () {
        return [rh]
    }, Np.prototype.getClass = function () {
        return Np
    };
    var Cp = function () {
        this._index = null;
        var t = arguments[0];
        if (!ma(t, ic)) throw new oa("Argument must be Polygonal");
        this._index = new Lp(t)
    }, Sp = {SegmentVisitor: {configurable: !0}, IntervalIndexedGeometry: {configurable: !0}};
    Cp.prototype.locate = function (t) {
        var e = new Wa(t), n = new Mp(e);
        return this._index.query(t.y, t.y, n), e.getLocation()
    }, Cp.prototype.interfaces_ = function () {
        return [Hh]
    }, Cp.prototype.getClass = function () {
        return Cp
    }, Sp.SegmentVisitor.get = function () {
        return Mp
    }, Sp.IntervalIndexedGeometry.get = function () {
        return Lp
    }, Object.defineProperties(Cp, Sp);
    var Mp = function () {
        this._counter = null;
        var t = arguments[0];
        this._counter = t
    };
    Mp.prototype.visitItem = function (t) {
        var e = t;
        this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
    }, Mp.prototype.interfaces_ = function () {
        return [rh]
    }, Mp.prototype.getClass = function () {
        return Mp
    };
    var Lp = function () {
        this._index = new Ip;
        var t = arguments[0];
        this.init(t)
    };
    Lp.prototype.init = function (t) {
        for (var e = Ol.getLines(t).iterator(); e.hasNext();) {
            var n = e.next().getCoordinates();
            this.addLine(n)
        }
    }, Lp.prototype.addLine = function (t) {
        for (var e = 1; e < t.length; e++) {
            var n = new wh(t[e - 1], t[e]), r = Math.min(n.p0.y, n.p1.y), i = Math.max(n.p0.y, n.p1.y);
            this._index.insert(r, i, n)
        }
    }, Lp.prototype.query = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1], n = new Np;
            return this._index.query(t, e, n), n.getItems()
        }
        if (3 === arguments.length) {
            var r = arguments[0], i = arguments[1], o = arguments[2];
            this._index.query(r, i, o)
        }
    }, Lp.prototype.interfaces_ = function () {
        return []
    }, Lp.prototype.getClass = function () {
        return Lp
    };
    var Pp = function (s) {
        function o() {
            if (s.call(this), this._parentGeom = null, this._lineEdgeMap = new mc, this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Rl, 2 === arguments.length) {
                var t = arguments[0], e = arguments[1], n = nu.OGC_SFS_BOUNDARY_RULE;
                this._argIndex = t, this._parentGeom = e, this._boundaryNodeRule = n, null !== e && this.add(e)
            } else if (3 === arguments.length) {
                var r = arguments[0], i = arguments[1], o = arguments[2];
                this._argIndex = r, this._parentGeom = i, this._boundaryNodeRule = o, null !== i && this.add(i)
            }
        }

        return s && (o.__proto__ = s), ((o.prototype = Object.create(s && s.prototype)).constructor = o).prototype.insertBoundaryPoint = function (t, e) {
            var n = this._nodes.addNode(e).getLabel(), r = 1;
            n.getLocation(t, Oc.ON) === ya.BOUNDARY && r++;
            var i = o.determineBoundary(this._boundaryNodeRule, r);
            n.setLocation(t, i)
        }, o.prototype.computeSelfNodes = function () {
            if (2 === arguments.length) {
                var t = arguments[0], e = arguments[1];
                return this.computeSelfNodes(t, e, !1)
            }
            if (3 === arguments.length) {
                var n = arguments[0], r = arguments[1], i = arguments[2], o = new _p(n, !0, !1);
                o.setIsDoneIfProperInt(i);
                var s = this.createEdgeSetIntersector(),
                    a = this._parentGeom instanceof ac || this._parentGeom instanceof oc || this._parentGeom instanceof uc,
                    u = r || !a;
                return s.computeIntersections(this._edges, o, u), this.addSelfIntersectionNodes(this._argIndex), o
            }
        }, o.prototype.computeSplitEdges = function (t) {
            for (var e = this._edges.iterator(); e.hasNext();) e.next().eiList.addSplitEdges(t)
        }, o.prototype.computeEdgeIntersections = function (t, e, n) {
            var r = new _p(e, n, !0);
            return r.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, r), r
        }, o.prototype.getGeometry = function () {
            return this._parentGeom
        }, o.prototype.getBoundaryNodeRule = function () {
            return this._boundaryNodeRule
        }, o.prototype.hasTooFewPoints = function () {
            return this._hasTooFewPoints
        }, o.prototype.addPoint = function () {
            if (arguments[0] instanceof rc) {
                var t = arguments[0].getCoordinate();
                this.insertPoint(this._argIndex, t, ya.INTERIOR)
            } else if (arguments[0] instanceof pa) {
                var e = arguments[0];
                this.insertPoint(this._argIndex, e, ya.INTERIOR)
            }
        }, o.prototype.addPolygon = function (t) {
            this.addPolygonRing(t.getExteriorRing(), ya.EXTERIOR, ya.INTERIOR);
            for (var e = 0; e < t.getNumInteriorRing(); e++) {
                var n = t.getInteriorRingN(e);
                this.addPolygonRing(n, ya.INTERIOR, ya.EXTERIOR)
            }
        }, o.prototype.addEdge = function (t) {
            this.insertEdge(t);
            var e = t.getCoordinates();
            this.insertPoint(this._argIndex, e[0], ya.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], ya.BOUNDARY)
        }, o.prototype.addLineString = function (t) {
            var e = yu.removeRepeatedPoints(t.getCoordinates());
            if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;
            var n = new cl(e, new kc(this._argIndex, ya.INTERIOR));
            this._lineEdgeMap.put(t, n), this.insertEdge(n), Xa.isTrue(2 <= e.length, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1])
        }, o.prototype.getInvalidPoint = function () {
            return this._invalidPoint
        }, o.prototype.getBoundaryPoints = function () {
            for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, r = t.iterator(); r.hasNext();) {
                var i = r.next();
                e[n++] = i.getCoordinate().copy()
            }
            return e
        }, o.prototype.getBoundaryNodes = function () {
            return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes
        }, o.prototype.addSelfIntersectionNode = function (t, e, n) {
            if (this.isBoundaryNode(t, e)) return null;
            n === ya.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n)
        }, o.prototype.addPolygonRing = function (t, e, n) {
            if (t.isEmpty()) return null;
            var r = yu.removeRepeatedPoints(t.getCoordinates());
            if (r.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = r[0], null;
            var i = e, o = n;
            Ja.isCCW(r) && (i = n, o = e);
            var s = new cl(r, new kc(this._argIndex, ya.BOUNDARY, i, o));
            this._lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this._argIndex, r[0], ya.BOUNDARY)
        }, o.prototype.insertPoint = function (t, e, n) {
            var r = this._nodes.addNode(e), i = r.getLabel();
            null === i ? r._label = new kc(t, n) : i.setLocation(t, n)
        }, o.prototype.createEdgeSetIntersector = function () {
            return new mp
        }, o.prototype.addSelfIntersectionNodes = function (t) {
            for (var e = this._edges.iterator(); e.hasNext();) for (var n = e.next(), r = n.getLabel().getLocation(t), i = n.eiList.iterator(); i.hasNext();) {
                var o = i.next();
                this.addSelfIntersectionNode(t, o.coord, r)
            }
        }, o.prototype.add = function () {
            if (1 !== arguments.length) return s.prototype.add.apply(this, arguments);
            var t = arguments[0];
            if (t.isEmpty()) return null;
            if (t instanceof uc && (this._useBoundaryDeterminationRule = !1), t instanceof oc) this.addPolygon(t); else if (t instanceof ec) this.addLineString(t); else if (t instanceof rc) this.addPoint(t); else if (t instanceof sc) this.addCollection(t); else if (t instanceof Xu) this.addCollection(t); else if (t instanceof uc) this.addCollection(t); else {
                if (!(t instanceof ju)) throw new Error(t.getClass().getName());
                this.addCollection(t)
            }
        }, o.prototype.addCollection = function (t) {
            for (var e = 0; e < t.getNumGeometries(); e++) {
                var n = t.getGeometryN(e);
                this.add(n)
            }
        }, o.prototype.locate = function (t) {
            return ma(this._parentGeom, ic) && 50 < this._parentGeom.getNumGeometries() ? (null === this._areaPtLocator && (this._areaPtLocator = new Cp(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom)
        }, o.prototype.findEdge = function () {
            if (1 !== arguments.length) return s.prototype.findEdge.apply(this, arguments);
            var t = arguments[0];
            return this._lineEdgeMap.get(t)
        }, o.prototype.interfaces_ = function () {
            return []
        }, o.prototype.getClass = function () {
            return o
        }, o.determineBoundary = function (t, e) {
            return t.isInBoundary(e) ? ya.BOUNDARY : ya.INTERIOR
        }, o
    }(Qc), Op = function () {
        if (this._li = new Va, this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
            var t = arguments[0];
            this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Pp(0, t)
        } else if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = nu.OGC_SFS_BOUNDARY_RULE;
            0 <= e.getPrecisionModel().compareTo(n.getPrecisionModel()) ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Pp(0, e, r), this._arg[1] = new Pp(1, n, r)
        } else if (3 === arguments.length) {
            var i = arguments[0], o = arguments[1], s = arguments[2];
            0 <= i.getPrecisionModel().compareTo(o.getPrecisionModel()) ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Pp(0, i, s), this._arg[1] = new Pp(1, o, s)
        }
    };
    Op.prototype.getArgGeometry = function (t) {
        return this._arg[t].getGeometry()
    }, Op.prototype.setComputationPrecision = function (t) {
        this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel)
    }, Op.prototype.interfaces_ = function () {
        return []
    }, Op.prototype.getClass = function () {
        return Op
    };
    var Rp = function () {
    };
    Rp.prototype.interfaces_ = function () {
        return []
    }, Rp.prototype.getClass = function () {
        return Rp
    }, Rp.map = function () {
        if (arguments[0] instanceof Qa && ma(arguments[1], Rp.MapOp)) {
            for (var t = arguments[0], e = arguments[1], n = new fu, r = 0; r < t.getNumGeometries(); r++) {
                var i = e.map(t.getGeometryN(r));
                null !== i && n.add(i)
            }
            return t.getFactory().buildGeometry(n)
        }
        if (ma(arguments[0], uu) && ma(arguments[1], Rp.MapOp)) {
            for (var o = arguments[0], s = arguments[1], a = new fu, u = o.iterator(); u.hasNext();) {
                var c = u.next(), h = s.map(c);
                null !== h && a.add(h)
            }
            return a
        }
    }, Rp.MapOp = function () {
    };
    var Tp = function (n) {
        function o() {
            var t = arguments[0], e = arguments[1];
            n.call(this, t, e), this._ptLocator = new Rl, this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new tl, this._resultPolyList = new fu, this._resultLineList = new fu, this._resultPointList = new fu, this._graph = new Qc(new Qh), this._geomFact = t.getFactory()
        }

        return n && (o.__proto__ = n), ((o.prototype = Object.create(n && n.prototype)).constructor = o).prototype.insertUniqueEdge = function (t) {
            var e = this._edgeList.findEqualEdge(t);
            if (null !== e) {
                var n = e.getLabel(), r = t.getLabel();
                e.isPointwiseEqual(t) || (r = new kc(t.getLabel())).flip();
                var i = e.getDepth();
                i.isNull() && i.add(n), i.add(r), n.merge(r)
            } else this._edgeList.add(t)
        }, o.prototype.getGraph = function () {
            return this._graph
        }, o.prototype.cancelDuplicateResultEdges = function () {
            for (var t = this._graph.getEdgeEnds().iterator(); t.hasNext();) {
                var e = t.next(), n = e.getSym();
                e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1))
            }
        }, o.prototype.isCoveredByLA = function (t) {
            return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList)
        }, o.prototype.computeGeometry = function (t, e, n, r) {
            var i = new fu;
            return i.addAll(t), i.addAll(e), i.addAll(n), i.isEmpty() ? o.createEmptyResult(r, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(i)
        }, o.prototype.mergeSymLabels = function () {
            for (var t = this._graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().mergeSymLabels()
        }, o.prototype.isCovered = function (t, e) {
            for (var n = e.iterator(); n.hasNext();) {
                var r = n.next();
                if (this._ptLocator.locate(t, r) !== ya.EXTERIOR) return !0
            }
            return !1
        }, o.prototype.replaceCollapsedEdges = function () {
            for (var t = new fu, e = this._edgeList.iterator(); e.hasNext();) {
                var n = e.next();
                n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()))
            }
            this._edgeList.addAll(t)
        }, o.prototype.updateNodeLabelling = function () {
            for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
                var e = t.next(), n = e.getEdges().getLabel();
                e.getLabel().merge(n)
            }
        }, o.prototype.getResultGeometry = function (t) {
            return this.computeOverlay(t), this._resultGeom
        }, o.prototype.insertUniqueEdges = function (t) {
            for (var e = t.iterator(); e.hasNext();) {
                var n = e.next();
                this.insertUniqueEdge(n)
            }
        }, o.prototype.computeOverlay = function (t) {
            this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
            var e = new fu;
            this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Kl.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
            var n = new $c(this._geomFact);
            n.add(this._graph), this._resultPolyList = n.getPolygons();
            var r = new $l(this, this._geomFact, this._ptLocator);
            this._resultLineList = r.build(t);
            var i = new tp(this, this._geomFact, this._ptLocator);
            this._resultPointList = i.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t)
        }, o.prototype.labelIncompleteNode = function (t, e) {
            var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());
            t.getLabel().setLocation(e, n)
        }, o.prototype.copyPoints = function (t) {
            for (var e = this._arg[t].getNodeIterator(); e.hasNext();) {
                var n = e.next();
                this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
            }
        }, o.prototype.findResultAreaEdges = function (t) {
            for (var e = this._graph.getEdgeEnds().iterator(); e.hasNext();) {
                var n = e.next(), r = n.getLabel();
                r.isArea() && !n.isInteriorAreaEdge() && o.isResultOfOp(r.getLocation(0, Oc.RIGHT), r.getLocation(1, Oc.RIGHT), t) && n.setInResult(!0)
            }
        }, o.prototype.computeLabelsFromDepths = function () {
            for (var t = this._edgeList.iterator(); t.hasNext();) {
                var e = t.next(), n = e.getLabel(), r = e.getDepth();
                if (!r.isNull()) {
                    r.normalize();
                    for (var i = 0; i < 2; i++) n.isNull(i) || !n.isArea() || r.isNull(i) || (0 === r.getDelta(i) ? n.toLine(i) : (Xa.isTrue(!r.isNull(i, Oc.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(i, Oc.LEFT, r.getLocation(i, Oc.LEFT)), Xa.isTrue(!r.isNull(i, Oc.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(i, Oc.RIGHT, r.getLocation(i, Oc.RIGHT))))
                }
            }
        }, o.prototype.computeLabelling = function () {
            for (var t = this._graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().computeLabelling(this._arg);
            this.mergeSymLabels(), this.updateNodeLabelling()
        }, o.prototype.labelIncompleteNodes = function () {
            for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
                var e = t.next(), n = e.getLabel();
                e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n)
            }
        }, o.prototype.isCoveredByA = function (t) {
            return !!this.isCovered(t, this._resultPolyList)
        }, o.prototype.interfaces_ = function () {
            return []
        }, o.prototype.getClass = function () {
            return o
        }, o
    }(Op);
    Tp.overlayOp = function (t, e, n) {
        return new Tp(t, e).getResultGeometry(n)
    }, Tp.intersection = function (t, e) {
        if (t.isEmpty() || e.isEmpty()) return Tp.createEmptyResult(Tp.INTERSECTION, t, e, t.getFactory());
        if (t.isGeometryCollection()) {
            var n = e;
            return Ql.map(t, {
                interfaces_: function () {
                    return [Rp.MapOp]
                }, map: function (t) {
                    return t.intersection(n)
                }
            })
        }
        return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), pp.overlayOp(t, e, Tp.INTERSECTION)
    }, Tp.symDifference = function (t, e) {
        if (t.isEmpty() || e.isEmpty()) {
            if (t.isEmpty() && e.isEmpty()) return Tp.createEmptyResult(Tp.SYMDIFFERENCE, t, e, t.getFactory());
            if (t.isEmpty()) return e.copy();
            if (e.isEmpty()) return t.copy()
        }
        return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), pp.overlayOp(t, e, Tp.SYMDIFFERENCE)
    }, Tp.resultDimension = function (t, e, n) {
        var r = e.getDimension(), i = n.getDimension(), o = -1;
        switch (t) {
            case Tp.INTERSECTION:
                o = Math.min(r, i);
                break;
            case Tp.UNION:
                o = Math.max(r, i);
                break;
            case Tp.DIFFERENCE:
                o = r;
                break;
            case Tp.SYMDIFFERENCE:
                o = Math.max(r, i)
        }
        return o
    }, Tp.createEmptyResult = function (t, e, n, r) {
        var i = null;
        switch (Tp.resultDimension(t, e, n)) {
            case-1:
                i = r.createGeometryCollection(new Array(0).fill(null));
                break;
            case 0:
                i = r.createPoint();
                break;
            case 1:
                i = r.createLineString();
                break;
            case 2:
                i = r.createPolygon()
        }
        return i
    }, Tp.difference = function (t, e) {
        return t.isEmpty() ? Tp.createEmptyResult(Tp.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), pp.overlayOp(t, e, Tp.DIFFERENCE))
    }, Tp.isResultOfOp = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1], n = t.getLocation(0), r = t.getLocation(1);
            return Tp.isResultOfOp(n, r, e)
        }
        if (3 === arguments.length) {
            var i = arguments[0], o = arguments[1], s = arguments[2];
            switch (i === ya.BOUNDARY && (i = ya.INTERIOR), o === ya.BOUNDARY && (o = ya.INTERIOR), s) {
                case Tp.INTERSECTION:
                    return i === ya.INTERIOR && o === ya.INTERIOR;
                case Tp.UNION:
                    return i === ya.INTERIOR || o === ya.INTERIOR;
                case Tp.DIFFERENCE:
                    return i === ya.INTERIOR && o !== ya.INTERIOR;
                case Tp.SYMDIFFERENCE:
                    return i === ya.INTERIOR && o !== ya.INTERIOR || i !== ya.INTERIOR && o === ya.INTERIOR
            }
            return !1
        }
    }, Tp.INTERSECTION = 1, Tp.UNION = 2, Tp.DIFFERENCE = 3, Tp.SYMDIFFERENCE = 4;
    var Ap = function () {
        this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Rl, this._seg = new wh;
        var t = arguments[0], e = arguments[1];
        this._g = t, this._boundaryDistanceTolerance = e, this._linework = this.extractLinework(t)
    };
    Ap.prototype.isWithinToleranceOfBoundary = function (t) {
        for (var e = 0; e < this._linework.getNumGeometries(); e++) for (var n = this._linework.getGeometryN(e).getCoordinateSequence(), r = 0; r < n.size() - 1; r++) if (n.getCoordinate(r, this._seg.p0), n.getCoordinate(r + 1, this._seg.p1), this._seg.distance(t) <= this._boundaryDistanceTolerance) return !0;
        return !1
    }, Ap.prototype.getLocation = function (t) {
        return this.isWithinToleranceOfBoundary(t) ? ya.BOUNDARY : this._ptLocator.locate(t, this._g)
    }, Ap.prototype.extractLinework = function (t) {
        var e = new Dp;
        t.apply(e);
        var n = e.getLinework(), r = bc.toLineStringArray(n);
        return t.getFactory().createMultiLineString(r)
    }, Ap.prototype.interfaces_ = function () {
        return []
    }, Ap.prototype.getClass = function () {
        return Ap
    };
    var Dp = function () {
        this._linework = null, this._linework = new fu
    };
    Dp.prototype.getLinework = function () {
        return this._linework
    }, Dp.prototype.filter = function (t) {
        if (t instanceof oc) {
            var e = t;
            this._linework.add(e.getExteriorRing());
            for (var n = 0; n < e.getNumInteriorRing(); n++) this._linework.add(e.getInteriorRingN(n))
        }
    }, Dp.prototype.interfaces_ = function () {
        return [ku]
    }, Dp.prototype.getClass = function () {
        return Dp
    };
    var Fp = function () {
        this._g = null, this._doLeft = !0, this._doRight = !0;
        var t = arguments[0];
        this._g = t
    };
    Fp.prototype.extractPoints = function (t, e, n) {
        for (var r = t.getCoordinates(), i = 0; i < r.length - 1; i++) this.computeOffsetPoints(r[i], r[i + 1], e, n)
    }, Fp.prototype.setSidesToGenerate = function (t, e) {
        this._doLeft = t, this._doRight = e
    }, Fp.prototype.getPoints = function (t) {
        for (var e = new fu, n = Ol.getLines(this._g).iterator(); n.hasNext();) {
            var r = n.next();
            this.extractPoints(r, t, e)
        }
        return e
    }, Fp.prototype.computeOffsetPoints = function (t, e, n, r) {
        var i = e.x - t.x, o = e.y - t.y, s = Math.sqrt(i * i + o * o), a = n * i / s, u = n * o / s,
            c = (e.x + t.x) / 2, h = (e.y + t.y) / 2;
        if (this._doLeft) {
            var l = new pa(c - u, h + a);
            r.add(l)
        }
        if (this._doRight) {
            var p = new pa(c + u, h - a);
            r.add(p)
        }
    }, Fp.prototype.interfaces_ = function () {
        return []
    }, Fp.prototype.getClass = function () {
        return Fp
    };
    var qp = function t() {
        this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t.TOLERANCE, this._testCoords = new fu;
        var e = arguments[0], n = arguments[1], r = arguments[2];
        this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(e, n), this._geom = [e, n, r], this._locFinder = [new Ap(this._geom[0], this._boundaryDistanceTolerance), new Ap(this._geom[1], this._boundaryDistanceTolerance), new Ap(this._geom[2], this._boundaryDistanceTolerance)]
    }, Gp = {TOLERANCE: {configurable: !0}};
    qp.prototype.reportResult = function (t, e, n) {
        Ra.out.println("Overlay result invalid - A:" + ya.toLocationSymbol(e[0]) + " B:" + ya.toLocationSymbol(e[1]) + " expected:" + (n ? "i" : "e") + " actual:" + ya.toLocationSymbol(e[2]))
    }, qp.prototype.isValid = function (t) {
        return this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]), this.checkValid(t)
    }, qp.prototype.checkValid = function () {
        if (1 === arguments.length) {
            for (var t = arguments[0], e = 0; e < this._testCoords.size(); e++) {
                var n = this._testCoords.get(e);
                if (!this.checkValid(t, n)) return this._invalidLocation = n, !1
            }
            return !0
        }
        if (2 === arguments.length) {
            var r = arguments[0], i = arguments[1];
            return this._location[0] = this._locFinder[0].getLocation(i), this._location[1] = this._locFinder[1].getLocation(i), this._location[2] = this._locFinder[2].getLocation(i), !!qp.hasLocation(this._location, ya.BOUNDARY) || this.isValidResult(r, this._location)
        }
    }, qp.prototype.addTestPts = function (t) {
        var e = new Fp(t);
        this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance))
    }, qp.prototype.isValidResult = function (t, e) {
        var n = Tp.isResultOfOp(e[0], e[1], t), r = !(n ^ e[2] === ya.INTERIOR);
        return r || this.reportResult(t, e, n), r
    }, qp.prototype.getInvalidLocation = function () {
        return this._invalidLocation
    }, qp.prototype.interfaces_ = function () {
        return []
    }, qp.prototype.getClass = function () {
        return qp
    }, qp.hasLocation = function (t, e) {
        for (var n = 0; n < 3; n++) if (t[n] === e) return !0;
        return !1
    }, qp.computeBoundaryDistanceTolerance = function (t, e) {
        return Math.min(rp.computeSizeBasedSnapTolerance(t), rp.computeSizeBasedSnapTolerance(e))
    }, qp.isValid = function (t, e, n, r) {
        return new qp(t, e, r).isValid(n)
    }, Gp.TOLERANCE.get = function () {
        return 1e-6
    }, Object.defineProperties(qp, Gp);
    var Bp = function t(e) {
        this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = t.extractFactory(e), this._inputGeoms = e
    };
    Bp.prototype.extractElements = function (t, e) {
        if (null === t) return null;
        for (var n = 0; n < t.getNumGeometries(); n++) {
            var r = t.getGeometryN(n);
            this._skipEmpty && r.isEmpty() || e.add(r)
        }
    }, Bp.prototype.combine = function () {
        for (var t = new fu, e = this._inputGeoms.iterator(); e.hasNext();) {
            var n = e.next();
            this.extractElements(n, t)
        }
        return 0 === t.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t)
    }, Bp.prototype.interfaces_ = function () {
        return []
    }, Bp.prototype.getClass = function () {
        return Bp
    }, Bp.combine = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return new Bp(t).combine()
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return new Bp(Bp.createList(e, n)).combine()
        }
        if (3 === arguments.length) {
            var r = arguments[0], i = arguments[1], o = arguments[2];
            return new Bp(Bp.createList(r, i, o)).combine()
        }
    }, Bp.extractFactory = function (t) {
        return t.isEmpty() ? null : t.iterator().next().getFactory()
    }, Bp.createList = function () {
        if (2 === arguments.length) {
            var t = arguments[0], e = arguments[1], n = new fu;
            return n.add(t), n.add(e), n
        }
        if (3 === arguments.length) {
            var r = arguments[0], i = arguments[1], o = arguments[2], s = new fu;
            return s.add(r), s.add(i), s.add(o), s
        }
    };
    var kp = function () {
        this._inputPolys = null, this._geomFactory = null;
        var t = arguments[0];
        this._inputPolys = t, null === this._inputPolys && (this._inputPolys = new fu)
    }, zp = {STRTREE_NODE_CAPACITY: {configurable: !0}};
    kp.prototype.reduceToGeometries = function (t) {
        for (var e = new fu, n = t.iterator(); n.hasNext();) {
            var r = n.next(), i = null;
            ma(r, lu) ? i = this.unionTree(r) : r instanceof Qa && (i = r), e.add(i)
        }
        return e
    }, kp.prototype.extractByEnvelope = function (t, e, n) {
        for (var r = new fu, i = 0; i < e.getNumGeometries(); i++) {
            var o = e.getGeometryN(i);
            o.getEnvelopeInternal().intersects(t) ? r.add(o) : n.add(o)
        }
        return this._geomFactory.buildGeometry(r)
    }, kp.prototype.unionOptimized = function (t, e) {
        var n = t.getEnvelopeInternal(), r = e.getEnvelopeInternal();
        if (!n.intersects(r)) return Bp.combine(t, e);
        if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);
        var i = n.intersection(r);
        return this.unionUsingEnvelopeIntersection(t, e, i)
    }, kp.prototype.union = function () {
        if (null === this._inputPolys) throw new Error("union() method cannot be called twice");
        if (this._inputPolys.isEmpty()) return null;
        this._geomFactory = this._inputPolys.iterator().next().getFactory();
        for (var t = new fh(kp.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext();) {
            var n = e.next();
            t.insert(n.getEnvelopeInternal(), n)
        }
        this._inputPolys = null;
        var r = t.itemsTree();
        return this.unionTree(r)
    }, kp.prototype.binaryUnion = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return this.binaryUnion(t, 0, t.size())
        }
        if (3 === arguments.length) {
            var e = arguments[0], n = arguments[1], r = arguments[2];
            if (r - n <= 1) {
                var i = kp.getGeometry(e, n);
                return this.unionSafe(i, null)
            }
            if (r - n == 2) return this.unionSafe(kp.getGeometry(e, n), kp.getGeometry(e, n + 1));
            var o = Math.trunc((r + n) / 2), s = this.binaryUnion(e, n, o), a = this.binaryUnion(e, o, r);
            return this.unionSafe(s, a)
        }
    }, kp.prototype.repeatedUnion = function (t) {
        for (var e = null, n = t.iterator(); n.hasNext();) {
            var r = n.next();
            e = null === e ? r.copy() : e.union(r)
        }
        return e
    }, kp.prototype.unionSafe = function (t, e) {
        return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e)
    }, kp.prototype.unionActual = function (t, e) {
        return kp.restrictToPolygons(t.union(e))
    }, kp.prototype.unionTree = function (t) {
        var e = this.reduceToGeometries(t);
        return this.binaryUnion(e)
    }, kp.prototype.unionUsingEnvelopeIntersection = function (t, e, n) {
        var r = new fu, i = this.extractByEnvelope(n, t, r), o = this.extractByEnvelope(n, e, r),
            s = this.unionActual(i, o);
        return r.add(s), Bp.combine(r)
    }, kp.prototype.bufferUnion = function () {
        if (1 === arguments.length) {
            var t = arguments[0];
            return t.get(0).getFactory().buildGeometry(t).buffer(0)
        }
        if (2 === arguments.length) {
            var e = arguments[0], n = arguments[1];
            return e.getFactory().createGeometryCollection([e, n]).buffer(0)
        }
    }, kp.prototype.interfaces_ = function () {
        return []
    }, kp.prototype.getClass = function () {
        return kp
    }, kp.restrictToPolygons = function (t) {
        if (ma(t, ic)) return t;
        var e = Pl.getPolygons(t);
        return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(bc.toPolygonArray(e))
    }, kp.getGeometry = function (t, e) {
        return e >= t.size() ? null : t.get(e)
    }, kp.union = function (t) {
        return new kp(t).union()
    }, zp.STRTREE_NODE_CAPACITY.get = function () {
        return 4
    }, Object.defineProperties(kp, zp);
    var jp = function () {
    };

    function Xp(t) {
        switch (t.type) {
            case"Polygon":
                return 1 < rr(t) ? t : null;
            case"MultiPolygon":
                var e = [];
                if (A(t, function (t) {
                    1 < rr(t) && e.push(t.geometry.coordinates)
                }), e.length) return {type: "MultiPolygon", coordinates: e}
        }
    }

    jp.prototype.interfaces_ = function () {
        return []
    }, jp.prototype.getClass = function () {
        return jp
    }, jp.union = function (t, e) {
        if (t.isEmpty() || e.isEmpty()) {
            if (t.isEmpty() && e.isEmpty()) return Tp.createEmptyResult(Tp.UNION, t, e, t.getFactory());
            if (t.isEmpty()) return e.copy();
            if (e.isEmpty()) return t.copy()
        }
        return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), pp.overlayOp(t, e, Tp.UNION)
    };
    var Up = function () {
        return new Yp
    };

    function Yp() {
        this.reset()
    }

    Yp.prototype = {
        constructor: Yp, reset: function () {
            this.s = this.t = 0
        }, add: function (t) {
            Hp(Vp, t, this.t), Hp(this, Vp.s, this.s), this.s ? this.t += Vp.t : this.s = Vp.t
        }, valueOf: function () {
            return this.s
        }
    };
    var Vp = new Yp;

    function Hp(t, e, n) {
        var r = t.s = e + n, i = r - e, o = r - i;
        t.t = e - o + (n - i)
    }

    var Wp = 1e-6, Jp = Math.PI, Zp = Jp / 2, Kp = Jp / 4, Qp = 2 * Jp, $p = 180 / Jp, tf = Jp / 180, ef = Math.abs,
        nf = Math.atan, rf = Math.atan2, of = Math.cos, sf = Math.exp, af = Math.log, uf = Math.sin, cf = Math.sqrt,
        hf = Math.tan;

    function lf(t) {
        return 1 < t ? Zp : t < -1 ? -Zp : Math.asin(t)
    }

    function pf() {
    }

    function ff(t, e) {
        t && df.hasOwnProperty(t.type) && df[t.type](t, e)
    }

    var gf = {
        Feature: function (t, e) {
            ff(t.geometry, e)
        }, FeatureCollection: function (t, e) {
            for (var n = t.features, r = -1, i = n.length; ++r < i;) ff(n[r].geometry, e)
        }
    }, df = {
        Sphere: function (t, e) {
            e.sphere()
        }, Point: function (t, e) {
            t = t.coordinates, e.point(t[0], t[1], t[2])
        }, MultiPoint: function (t, e) {
            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) t = n[r], e.point(t[0], t[1], t[2])
        }, LineString: function (t, e) {
            yf(t.coordinates, e, 0)
        }, MultiLineString: function (t, e) {
            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) yf(n[r], e, 0)
        }, Polygon: function (t, e) {
            _f(t.coordinates, e)
        }, MultiPolygon: function (t, e) {
            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) _f(n[r], e)
        }, GeometryCollection: function (t, e) {
            for (var n = t.geometries, r = -1, i = n.length; ++r < i;) ff(n[r], e)
        }
    };

    function yf(t, e, n) {
        var r, i = -1, o = t.length - n;
        for (e.lineStart(); ++i < o;) r = t[i], e.point(r[0], r[1], r[2]);
        e.lineEnd()
    }

    function _f(t, e) {
        var n = -1, r = t.length;
        for (e.polygonStart(); ++n < r;) yf(t[n], e, 1);
        e.polygonEnd()
    }

    var mf = function (t, e) {
        t && gf.hasOwnProperty(t.type) ? gf[t.type](t, e) : ff(t, e)
    };

    function vf(t) {
        return [rf(t[1], t[0]), lf(t[2])]
    }

    function xf(t) {
        var e = t[0], n = t[1], r = of(n);
        return [r * of(e), r * uf(e), uf(n)]
    }

    function Ef(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
    }

    function wf(t, e) {
        return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
    }

    function bf(t, e) {
        t[0] += e[0], t[1] += e[1], t[2] += e[2]
    }

    function If(t, e) {
        return [t[0] * e, t[1] * e, t[2] * e]
    }

    function Nf(t) {
        var e = cf(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
        t[0] /= e, t[1] /= e, t[2] /= e
    }

    Up(), Up(), Up();
    var Cf = function (n, r) {
        function t(t, e) {
            return t = n(t, e), r(t[0], t[1])
        }

        return n.invert && r.invert && (t.invert = function (t, e) {
            return (t = r.invert(t, e)) && n.invert(t[0], t[1])
        }), t
    };

    function Sf(t, e) {
        return [Jp < t ? t - Qp : t < -Jp ? t + Qp : t, e]
    }

    function Mf(t, e, n) {
        return (t %= Qp) ? e || n ? Cf(Pf(t), Of(e, n)) : Pf(t) : e || n ? Of(e, n) : Sf
    }

    function Lf(n) {
        return function (t, e) {
            return [Jp < (t += n) ? t - Qp : t < -Jp ? t + Qp : t, e]
        }
    }

    function Pf(t) {
        var e = Lf(t);
        return e.invert = Lf(-t), e
    }

    function Of(t, e) {
        var a = of(t), u = uf(t), c = of(e), h = uf(e);

        function n(t, e) {
            var n = of(e), r = of(t) * n, i = uf(t) * n, o = uf(e), s = o * a + r * u;
            return [rf(i * c - s * h, r * a - o * u), lf(s * c + i * h)]
        }

        return n.invert = function (t, e) {
            var n = of(e), r = of(t) * n, i = uf(t) * n, o = uf(e), s = o * c - i * h;
            return [rf(i * c + o * h, r * a + s * u), lf(s * a - r * u)]
        }, n
    }

    function Rf(t, e) {
        (e = xf(e))[0] -= t, Nf(e);
        var n, r = 1 < (n = -e[1]) ? 0 : n < -1 ? Jp : Math.acos(n);
        return ((-e[2] < 0 ? -r : r) + Qp - Wp) % Qp
    }

    Sf.invert = Sf;
    var Tf = function () {
        var n, e = [];
        return {
            point: function (t, e) {
                n.push([t, e])
            }, lineStart: function () {
                e.push(n = [])
            }, lineEnd: pf, rejoin: function () {
                1 < e.length && e.push(e.pop().concat(e.shift()))
            }, result: function () {
                var t = e;
                return e = [], n = null, t
            }
        }
    }, Af = function (t, e, n, r, i, o) {
        var s, a = t[0], u = t[1], c = 0, h = 1, l = e[0] - a, p = e[1] - u;
        if (s = n - a, l || !(0 < s)) {
            if (s /= l, l < 0) {
                if (s < c) return;
                s < h && (h = s)
            } else if (0 < l) {
                if (h < s) return;
                c < s && (c = s)
            }
            if (s = i - a, l || !(s < 0)) {
                if (s /= l, l < 0) {
                    if (h < s) return;
                    c < s && (c = s)
                } else if (0 < l) {
                    if (s < c) return;
                    s < h && (h = s)
                }
                if (s = r - u, p || !(0 < s)) {
                    if (s /= p, p < 0) {
                        if (s < c) return;
                        s < h && (h = s)
                    } else if (0 < p) {
                        if (h < s) return;
                        c < s && (c = s)
                    }
                    if (s = o - u, p || !(s < 0)) {
                        if (s /= p, p < 0) {
                            if (h < s) return;
                            c < s && (c = s)
                        } else if (0 < p) {
                            if (s < c) return;
                            s < h && (h = s)
                        }
                        return 0 < c && (t[0] = a + c * l, t[1] = u + c * p), h < 1 && (e[0] = a + h * l, e[1] = u + h * p), !0
                    }
                }
            }
        }
    }, Df = function (t, e) {
        return ef(t[0] - e[0]) < Wp && ef(t[1] - e[1]) < Wp
    };

    function Ff(t, e, n, r) {
        this.x = t, this.z = e, this.o = n, this.e = r, this.v = !1, this.n = this.p = null
    }

    var qf = function (t, e, n, r, o) {
        var s, i, a = [], u = [];
        if (t.forEach(function (t) {
            if (!((e = t.length - 1) <= 0)) {
                var e, n, r = t[0], i = t[e];
                if (Df(r, i)) {
                    for (o.lineStart(), s = 0; s < e; ++s) o.point((r = t[s])[0], r[1]);
                    o.lineEnd()
                } else a.push(n = new Ff(r, t, null, !0)), u.push(n.o = new Ff(r, null, n, !1)), a.push(n = new Ff(i, t, null, !1)), u.push(n.o = new Ff(i, null, n, !0))
            }
        }), a.length) {
            for (u.sort(e), Gf(a), Gf(u), s = 0, i = u.length; s < i; ++s) u[s].e = n = !n;
            for (var c, h, l = a[0]; ;) {
                for (var p = l, f = !0; p.v;) if ((p = p.n) === l) return;
                c = p.z, o.lineStart();
                do {
                    if (p.v = p.o.v = !0, p.e) {
                        if (f) for (s = 0, i = c.length; s < i; ++s) o.point((h = c[s])[0], h[1]); else r(p.x, p.n.x, 1, o);
                        p = p.n
                    } else {
                        if (f) for (c = p.p.z, s = c.length - 1; 0 <= s; --s) o.point((h = c[s])[0], h[1]); else r(p.x, p.p.x, -1, o);
                        p = p.p
                    }
                    c = (p = p.o).z, f = !f
                } while (!p.v);
                o.lineEnd()
            }
        }
    };

    function Gf(t) {
        if (e = t.length) {
            for (var e, n, r = 0, i = t[0]; ++r < e;) i.n = n = t[r], n.p = i, i = n;
            i.n = n = t[0], n.p = i
        }
    }

    var Bf = function (t, e) {
        return t < e ? -1 : e < t ? 1 : e <= t ? 0 : NaN
    };
    1 === (kf = Bf).length && (zf = kf, kf = function (t, e) {
        return Bf(zf(t), e)
    });
    var kf, zf, jf = function (t) {
        for (var e, n, r, i = t.length, o = -1, s = 0; ++o < i;) s += t[o].length;
        for (n = new Array(s); 0 <= --i;) for (e = (r = t[i]).length; 0 <= --e;) n[--s] = r[e];
        return n
    }, Xf = 1e9, Uf = -Xf;
    var Yf = Up(), Vf = (Up(), function (t) {
        return t
    }), Hf = (Up(), Up(), 1 / 0), Wf = Hf, Jf = -Hf, Zf = Jf, Kf = {
        point: function (t, e) {
            t < Hf && (Hf = t), Jf < t && (Jf = t), e < Wf && (Wf = e), Zf < e && (Zf = e)
        }, lineStart: pf, lineEnd: pf, polygonStart: pf, polygonEnd: pf, result: function () {
            var t = [[Hf, Wf], [Jf, Zf]];
            return Jf = Zf = -(Wf = Hf = 1 / 0), t
        }
    };
    Up();
    var Qf = function (m, v, x, E) {
        return function (r, a) {
            var u, c, h, i = v(a), e = r.invert(E[0], E[1]), l = Tf(), p = v(l), f = !1, n = {
                point: o, lineStart: s, lineEnd: g, polygonStart: function () {
                    n.point = d, n.lineStart = y, n.lineEnd = _, c = [], u = []
                }, polygonEnd: function () {
                    n.point = o, n.lineStart = s, n.lineEnd = g, c = jf(c);
                    var t = function (t, e) {
                        var n = e[0], r = e[1], i = [uf(n), -of(n), 0], o = 0, s = 0;
                        Yf.reset();
                        for (var a = 0, u = t.length; a < u; ++a) if (h = (c = t[a]).length) for (var c, h, l = c[h - 1], p = l[0], f = l[1] / 2 + Kp, g = uf(f), d = of(f), y = 0; y < h; ++y, p = m, g = x, d = E, l = _) {
                            var _ = c[y], m = _[0], v = _[1] / 2 + Kp, x = uf(v), E = of(v), w = m - p,
                                b = 0 <= w ? 1 : -1, I = b * w, N = Jp < I, C = g * x;
                            if (Yf.add(rf(C * b * uf(I), d * E + C * of(I))), o += N ? w + b * Qp : w, N ^ n <= p ^ n <= m) {
                                var S = wf(xf(l), xf(_));
                                Nf(S);
                                var M = wf(i, S);
                                Nf(M);
                                var L = (N ^ 0 <= w ? -1 : 1) * lf(M[2]);
                                (L < r || r === L && (S[0] || S[1])) && (s += N ^ 0 <= w ? 1 : -1)
                            }
                        }
                        return (o < -Wp || o < Wp && Yf < -Wp) ^ 1 & s
                    }(u, e);
                    c.length ? (f || (a.polygonStart(), f = !0), qf(c, tg, t, x, a)) : t && (f || (a.polygonStart(), f = !0), a.lineStart(), x(null, null, 1, a), a.lineEnd()), f && (a.polygonEnd(), f = !1), c = u = null
                }, sphere: function () {
                    a.polygonStart(), a.lineStart(), x(null, null, 1, a), a.lineEnd(), a.polygonEnd()
                }
            };

            function o(t, e) {
                var n = r(t, e);
                m(t = n[0], e = n[1]) && a.point(t, e)
            }

            function t(t, e) {
                var n = r(t, e);
                i.point(n[0], n[1])
            }

            function s() {
                n.point = t, i.lineStart()
            }

            function g() {
                n.point = o, i.lineEnd()
            }

            function d(t, e) {
                h.push([t, e]);
                var n = r(t, e);
                p.point(n[0], n[1])
            }

            function y() {
                p.lineStart(), h = []
            }

            function _() {
                d(h[0][0], h[0][1]), p.lineEnd();
                var t, e, n, r, i = p.clean(), o = l.result(), s = o.length;
                if (h.pop(), u.push(h), h = null, s) if (1 & i) {
                    if (0 < (e = (n = o[0]).length - 1)) {
                        for (f || (a.polygonStart(), f = !0), a.lineStart(), t = 0; t < e; ++t) a.point((r = n[t])[0], r[1]);
                        a.lineEnd()
                    }
                } else 1 < s && 2 & i && o.push(o.pop().concat(o.shift())), c.push(o.filter($f))
            }

            return n
        }
    };

    function $f(t) {
        return 1 < t.length
    }

    function tg(t, e) {
        return ((t = t.x)[0] < 0 ? t[1] - Zp - Wp : Zp - t[1]) - ((e = e.x)[0] < 0 ? e[1] - Zp - Wp : Zp - e[1])
    }

    var eg = Qf(function () {
        return !0
    }, function (l) {
        var p, f = NaN, g = NaN, d = NaN;
        return {
            lineStart: function () {
                l.lineStart(), p = 1
            }, point: function (t, e) {
                var n, r, i, o, s, a, u, c = 0 < t ? Jp : -Jp, h = ef(t - f);
                ef(h - Jp) < Wp ? (l.point(f, g = 0 < (g + e) / 2 ? Zp : -Zp), l.point(d, g), l.lineEnd(), l.lineStart(), l.point(c, g), l.point(t, g), p = 0) : d !== c && Jp <= h && (ef(f - d) < Wp && (f -= d * Wp), ef(t - c) < Wp && (t -= c * Wp), r = g, o = e, u = uf((n = f) - (i = t)), g = ef(u) > Wp ? nf((uf(r) * (a = of(o)) * uf(i) - uf(o) * (s = of(r)) * uf(n)) / (s * a * u)) : (r + o) / 2, l.point(d, g), l.lineEnd(), l.lineStart(), l.point(c, g), p = 0), l.point(f = t, g = e), d = c
            }, lineEnd: function () {
                l.lineEnd(), f = g = NaN
            }, clean: function () {
                return 2 - p
            }
        }
    }, function (t, e, n, r) {
        var i;
        if (null == t) i = n * Zp, r.point(-Jp, i), r.point(0, i), r.point(Jp, i), r.point(Jp, 0), r.point(Jp, -i), r.point(0, -i), r.point(-Jp, -i), r.point(-Jp, 0), r.point(-Jp, i); else if (ef(t[0] - e[0]) > Wp) {
            var o = t[0] < e[0] ? Jp : -Jp;
            i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i)
        } else r.point(e[0], e[1])
    }, [-Jp, -Zp]), ng = function (i, o) {
        var C = of(i), f = 0 < C, g = ef(C) > Wp;

        function d(t, e) {
            return of(t) * of(e) > C
        }

        function y(t, e, n) {
            var r = [1, 0, 0], i = wf(xf(t), xf(e)), o = Ef(i, i), s = i[0], a = o - s * s;
            if (!a) return !n && t;
            var u = C * o / a, c = -C * s / a, h = wf(r, i), l = If(r, u);
            bf(l, If(i, c));
            var p = h, f = Ef(l, p), g = Ef(p, p), d = f * f - g * (Ef(l, l) - 1);
            if (!(d < 0)) {
                var y = cf(d), _ = If(p, (-f - y) / g);
                if (bf(_, l), _ = vf(_), !n) return _;
                var m, v = t[0], x = e[0], E = t[1], w = e[1];
                x < v && (m = v, v = x, x = m);
                var b = x - v, I = ef(b - Jp) < Wp;
                if (!I && w < E && (m = E, E = w, w = m), I || b < Wp ? I ? 0 < E + w ^ _[1] < (ef(_[0] - v) < Wp ? E : w) : E <= _[1] && _[1] <= w : Jp < b ^ (v <= _[0] && _[0] <= x)) {
                    var N = If(p, (-f + y) / g);
                    return bf(N, l), [_, vf(N)]
                }
            }
        }

        function _(t, e) {
            var n = f ? i : Jp - i, r = 0;
            return t < -n ? r |= 1 : n < t && (r |= 2), e < -n ? r |= 4 : n < e && (r |= 8), r
        }

        return Qf(d, function (a) {
            var u, c, h, l, p;
            return {
                lineStart: function () {
                    l = h = !1, p = 1
                }, point: function (t, e) {
                    var n, r = [t, e], i = d(t, e), o = f ? i ? 0 : _(t, e) : i ? _(t + (t < 0 ? Jp : -Jp), e) : 0;
                    if (!u && (l = h = i) && a.lineStart(), i !== h && (!(n = y(u, r)) || Df(u, n) || Df(r, n)) && (r[0] += Wp, r[1] += Wp, i = d(r[0], r[1])), i !== h) p = 0, i ? (a.lineStart(), n = y(r, u), a.point(n[0], n[1])) : (n = y(u, r), a.point(n[0], n[1]), a.lineEnd()), u = n; else if (g && u && f ^ i) {
                        var s;
                        o & c || !(s = y(r, u, !0)) || (p = 0, f ? (a.lineStart(), a.point(s[0][0], s[0][1]), a.point(s[1][0], s[1][1]), a.lineEnd()) : (a.point(s[1][0], s[1][1]), a.lineEnd(), a.lineStart(), a.point(s[0][0], s[0][1])))
                    }
                    !i || u && Df(u, r) || a.point(r[0], r[1]), u = r, h = i, c = o
                }, lineEnd: function () {
                    h && a.lineEnd(), u = null
                }, clean: function () {
                    return p | (l && h) << 1
                }
            }
        }, function (t, e, n, r) {
            !function (t, e, n, r, i, o) {
                if (n) {
                    var s = of(e), a = uf(e), u = r * n;
                    null == i ? (i = e + r * Qp, o = e - u / 2) : (i = Rf(s, i), o = Rf(s, o), (0 < r ? i < o : o < i) && (i += r * Qp));
                    for (var c, h = i; 0 < r ? o < h : h < o; h -= u) c = vf([s, -a * of(h), -a * uf(h)]), t.point(c[0], c[1])
                }
            }(r, i, o, n, t, e)
        }, f ? [0, -i] : [-Jp, i - Jp])
    };

    function rg(r) {
        return function (t) {
            var e = new ig;
            for (var n in r) e[n] = r[n];
            return e.stream = t, e
        }
    }

    function ig() {
    }

    function og(t, e, n) {
        var r = e[1][0] - e[0][0], i = e[1][1] - e[0][1], o = t.clipExtent && t.clipExtent();
        t.scale(150).translate([0, 0]), null != o && t.clipExtent(null), mf(n, t.stream(Kf));
        var s = Kf.result(), a = Math.min(r / (s[1][0] - s[0][0]), i / (s[1][1] - s[0][1])),
            u = +e[0][0] + (r - a * (s[1][0] + s[0][0])) / 2, c = +e[0][1] + (i - a * (s[1][1] + s[0][1])) / 2;
        return null != o && t.clipExtent(o), t.scale(150 * a).translate([u, c])
    }

    ig.prototype = {
        constructor: ig, point: function (t, e) {
            this.stream.point(t, e)
        }, sphere: function () {
            this.stream.sphere()
        }, lineStart: function () {
            this.stream.lineStart()
        }, lineEnd: function () {
            this.stream.lineEnd()
        }, polygonStart: function () {
            this.stream.polygonStart()
        }, polygonEnd: function () {
            this.stream.polygonEnd()
        }
    };
    var sg = of(30 * tf), ag = function (t, e) {
        return +e ? function (L, P) {
            function O(t, e, n, r, i, o, s, a, u, c, h, l, p, f) {
                var g = s - t, d = a - e, y = g * g + d * d;
                if (4 * P < y && p--) {
                    var _ = r + c, m = i + h, v = o + l, x = cf(_ * _ + m * m + v * v), E = lf(v /= x),
                        w = ef(ef(v) - 1) < Wp || ef(n - u) < Wp ? (n + u) / 2 : rf(m, _), b = L(w, E), I = b[0],
                        N = b[1], C = I - t, S = N - e, M = d * C - g * S;
                    (P < M * M / y || .3 < ef((g * C + d * S) / y - .5) || r * c + i * h + o * l < sg) && (O(t, e, n, r, i, o, I, N, w, _ /= x, m /= x, v, p, f), f.point(I, N), O(I, N, w, _, m, v, s, a, u, c, h, l, p, f))
                }
            }

            return function (i) {
                var n, r, o, s, a, u, c, h, l, p, f, g, d = {
                    point: t, lineStart: e, lineEnd: _, polygonStart: function () {
                        i.polygonStart(), d.lineStart = m
                    }, polygonEnd: function () {
                        i.polygonEnd(), d.lineStart = e
                    }
                };

                function t(t, e) {
                    t = L(t, e), i.point(t[0], t[1])
                }

                function e() {
                    h = NaN, d.point = y, i.lineStart()
                }

                function y(t, e) {
                    var n = xf([t, e]), r = L(t, e);
                    O(h, l, c, p, f, g, h = r[0], l = r[1], c = t, p = n[0], f = n[1], g = n[2], 16, i), i.point(h, l)
                }

                function _() {
                    d.point = t, i.lineEnd()
                }

                function m() {
                    e(), d.point = v, d.lineEnd = x
                }

                function v(t, e) {
                    y(n = t, e), r = h, o = l, s = p, a = f, u = g, d.point = y
                }

                function x() {
                    O(h, l, c, p, f, g, r, o, n, s, a, u, 16, i), (d.lineEnd = _)()
                }

                return d
            }
        }(t, e) : (n = t, rg({
            point: function (t, e) {
                t = n(t, e), this.stream.point(t[0], t[1])
            }
        }));
        var n
    }, ug = rg({
        point: function (t, e) {
            this.stream.point(t * tf, e * tf)
        }
    });

    function cg(P) {
        return function (t) {
            var n, r, i, e, o, s, a, u, c, h, l = 150, p = 480, f = 250, g = 0, d = 0, y = 0, _ = 0, m = 0, v = null,
                x = eg, E = null, w = Vf, b = .5, I = ag(S, b);

            function N(t) {
                return [(t = o(t[0] * tf, t[1] * tf))[0] * l + r, i - t[1] * l]
            }

            function C(t) {
                return (t = o.invert((t[0] - r) / l, (i - t[1]) / l)) && [t[0] * $p, t[1] * $p]
            }

            function S(t, e) {
                return [(t = n(t, e))[0] * l + r, i - t[1] * l]
            }

            function M() {
                o = Cf(e = Mf(y, _, m), n);
                var t = n(g, d);
                return r = p - t[0] * l, i = f + t[1] * l, L()
            }

            function L() {
                return c = h = null, N
            }

            return N.stream = function (t) {
                return c && h === t ? c : c = ug(x(e, I(w(h = t))))
            }, N.clipAngle = function (t) {
                return arguments.length ? (x = +t ? ng(v = t * tf, 6 * tf) : (v = null, eg), L()) : v * $p
            }, N.clipExtent = function (t) {
                return arguments.length ? (w = null == t ? (E = s = a = u = null, Vf) : function (_, m, v, x) {
                    function E(t, e) {
                        return _ <= t && t <= v && m <= e && e <= x
                    }

                    function w(t, e, n, r) {
                        var i = 0, o = 0;
                        if (null == t || (i = s(t, n)) !== (o = s(e, n)) || a(t, e) < 0 ^ 0 < n) for (; r.point(0 === i || 3 === i ? _ : v, 1 < i ? x : m), (i = (i + n + 4) % 4) !== o;) ; else r.point(e[0], e[1])
                    }

                    function s(t, e) {
                        return ef(t[0] - _) < Wp ? 0 < e ? 0 : 3 : ef(t[0] - v) < Wp ? 0 < e ? 2 : 1 : ef(t[1] - m) < Wp ? 0 < e ? 1 : 0 : 0 < e ? 3 : 2
                    }

                    function b(t, e) {
                        return a(t.x, e.x)
                    }

                    function a(t, e) {
                        var n = s(t, 1), r = s(e, 1);
                        return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0]
                    }

                    return function (r) {
                        var i, l, o, s, a, u, c, h, p, f, g, d = r, t = Tf(), e = {
                            point: n, lineStart: function () {
                                e.point = y, l && l.push(o = []), p = !(f = !0), c = h = NaN
                            }, lineEnd: function () {
                                i && (y(s, a), u && p && t.rejoin(), i.push(t.result())), e.point = n, p && d.lineEnd()
                            }, polygonStart: function () {
                                d = t, i = [], l = [], g = !0
                            }, polygonEnd: function () {
                                var t = function () {
                                    for (var t = 0, e = 0, n = l.length; e < n; ++e) for (var r, i, o = l[e], s = 1, a = o.length, u = o[0], c = u[0], h = u[1]; s < a; ++s) r = c, i = h, c = (u = o[s])[0], h = u[1], i <= x ? x < h && (h - i) * (_ - r) < (c - r) * (x - i) && ++t : h <= x && (c - r) * (x - i) < (h - i) * (_ - r) && --t;
                                    return t
                                }(), e = g && t, n = (i = jf(i)).length;
                                (e || n) && (r.polygonStart(), e && (r.lineStart(), w(null, null, 1, r), r.lineEnd()), n && qf(i, b, t, w, r), r.polygonEnd()), d = r, i = l = o = null
                            }
                        };

                        function n(t, e) {
                            E(t, e) && d.point(t, e)
                        }

                        function y(t, e) {
                            var n = E(t, e);
                            if (l && o.push([t, e]), f) s = t, a = e, f = !1, (u = n) && (d.lineStart(), d.point(t, e)); else if (n && p) d.point(t, e); else {
                                var r = [c = Math.max(Uf, Math.min(Xf, c)), h = Math.max(Uf, Math.min(Xf, h))],
                                    i = [t = Math.max(Uf, Math.min(Xf, t)), e = Math.max(Uf, Math.min(Xf, e))];
                                Af(r, i, _, m, v, x) ? (p || (d.lineStart(), d.point(r[0], r[1])), d.point(i[0], i[1]), n || d.lineEnd(), g = !1) : n && (d.lineStart(), d.point(t, e), g = !1)
                            }
                            c = t, h = e, p = n
                        }

                        return e
                    }
                }(E = +t[0][0], s = +t[0][1], a = +t[1][0], u = +t[1][1]), L()) : null == E ? null : [[E, s], [a, u]]
            }, N.scale = function (t) {
                return arguments.length ? (l = +t, M()) : l
            }, N.translate = function (t) {
                return arguments.length ? (p = +t[0], f = +t[1], M()) : [p, f]
            }, N.center = function (t) {
                return arguments.length ? (g = t[0] % 360 * tf, d = t[1] % 360 * tf, M()) : [g * $p, d * $p]
            }, N.rotate = function (t) {
                return arguments.length ? (y = t[0] % 360 * tf, _ = t[1] % 360 * tf, m = 2 < t.length ? t[2] % 360 * tf : 0, M()) : [y * $p, _ * $p, m * $p]
            }, N.precision = function (t) {
                return arguments.length ? (I = ag(S, b = t * t), L()) : cf(b)
            }, N.fitExtent = function (t, e) {
                return og(N, t, e)
            }, N.fitSize = function (t, e) {
                return og(N, [[0, 0], t], e)
            }, function () {
                return n = function () {
                    return P
                }.apply(this, arguments), N.invert = n.invert && C, M()
            }
        }()()
    }

    function hg(t, e) {
        return [t, af(hf((Zp + e) / 2))]
    }

    function lg(t, e) {
        return [af(hf((Zp + e) / 2)), -t]
    }

    hg.invert = function (t, e) {
        return [t, 2 * nf(sf(e)) - Zp]
    }, lg.invert = function (t, e) {
        return [-e, 2 * nf(sf(t)) - Zp]
    };
    var pg = function () {
        var t = function (n) {
            var r, i, o, s = cg(n), e = s.center, a = s.scale, u = s.translate, c = s.clipExtent, h = null;

            function l() {
                var t = Jp * a(), e = s(function (e) {
                    function t(t) {
                        return (t = e(t[0] * tf, t[1] * tf))[0] *= $p, t[1] *= $p, t
                    }

                    return e = Mf(e[0] * tf, e[1] * tf, 2 < e.length ? e[2] * tf : 0), t.invert = function (t) {
                        return (t = e.invert(t[0] * tf, t[1] * tf))[0] *= $p, t[1] *= $p, t
                    }, t
                }(s.rotate()).invert([0, 0]));
                return c(null == h ? [[e[0] - t, e[1] - t], [e[0] + t, e[1] + t]] : n === hg ? [[Math.max(e[0] - t, h), r], [Math.min(e[0] + t, i), o]] : [[h, Math.max(e[1] - t, r)], [i, Math.min(e[1] + t, o)]])
            }

            return s.scale = function (t) {
                return arguments.length ? (a(t), l()) : a()
            }, s.translate = function (t) {
                return arguments.length ? (u(t), l()) : u()
            }, s.center = function (t) {
                return arguments.length ? (e(t), l()) : e()
            }, s.clipExtent = function (t) {
                return arguments.length ? (null == t ? h = r = i = o = null : (h = +t[0][0], r = +t[0][1], i = +t[1][0], o = +t[1][1]), l()) : null == h ? null : [[h, r], [i, o]]
            }, l()
        }(lg), e = t.center, n = t.rotate;
        return t.center = function (t) {
            return arguments.length ? e([-t[1], t[0]]) : [(t = e())[1], -t[0]]
        }, t.rotate = function (t) {
            return arguments.length ? n([t[0], t[1], 2 < t.length ? t[2] + 90 : 90]) : [(t = n())[0], t[1], t[2] - 90]
        }, n([0, 0, 90]).scale(159.155)
    };

    function fg(t, n, r, i) {
        var e, o = t.properties || {}, s = "Feature" === t.type ? t.geometry : t;
        if ("GeometryCollection" === s.type) {
            var a = [];
            return R(t, function (t) {
                var e = fg(t, n, r, i);
                e && a.push(e)
            }), Y(a)
        }
        var u = W(t), c = 50 < u[1] && 50 < u[3];
        e = c ? {
            type: s.type, coordinates: function e(t, n) {
                return "object" != typeof t[0] ? n(t) : t.map(function (t) {
                    return e(t, n)
                })
            }(s.coordinates, gg(s))
        } : Hn(s);
        var h, l = (new Lc).read(e), p = g(d(n, r), "meters"), f = wl.bufferOp(l, p);
        if (!function t(e) {
            return Array.isArray(e[0]) ? t(e[0]) : isNaN(e[0])
        }((f = (new Pc).write(f)).coordinates)) return (h = c ? {
            type: f.type, coordinates: function e(t, n) {
                return "object" != typeof t[0] ? n.invert(t) : t.map(function (t) {
                    return e(t, n)
                })
            }(f.coordinates, gg(s))
        } : Wn(f)).geometry ? h : j(h, o)
    }

    function gg(t) {
        var e = Ve(t).geometry.coordinates.reverse(), n = e.map(function (t) {
            return -t
        });
        return pg().center(e).rotate(n).scale(f)
    }

    function dg() {
        for (var t = new Lc, e = t.read(JSON.stringify(arguments[0].geometry)), n = 1; n < arguments.length; n++) e = jp.union(e, t.read(JSON.stringify(arguments[n].geometry)));
        return {type: "Feature", geometry: e = (new Pc).write(e), properties: arguments[0].properties}
    }

    function yg(t, e) {
        var n = et(t), r = et(e);
        if (Re(dr(r, {precision: 4})).coordinates[0].length < 4) return null;
        if (Re(dr(n, {precision: 4})).coordinates[0].length < 4) return null;
        var i = new Lc, o = i.read(dr(n)), s = i.read(dr(r)), a = Tp.intersection(o, s);
        return a.isEmpty() ? null : j((new Pc).write(a))
    }

    function _g(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.properties || {}, i = n.triangles, o = n.mask;
        if (null == e) throw new Error("cellSide is required");
        if (!V(e)) throw new Error("cellSide is invalid");
        if (!t) throw new Error("bbox is required");
        if (!Array.isArray(t)) throw new Error("bbox must be array");
        if (4 !== t.length) throw new Error("bbox must contain 4 numbers");
        if (o && -1 === ["Polygon", "MultiPolygon"].indexOf(rt(o))) throw new Error("options.mask must be a (Multi)Polygon");
        var s = t[0], a = t[1], u = t[2], c = t[3], h = (a + c) / 2, l = (s + u) / 2,
            p = 2 * e / he([s, h], [u, h], n) * (u - s), f = 2 * e / he([l, a], [l, c], n) * (c - a), g = p / 2,
            d = 2 * g, y = Math.sqrt(3) / 2 * f, _ = u - s, m = c - a, v = .75 * d, x = y, E = (_ - d) / (d - g / 2),
            w = Math.floor(E), b = (w * v - g / 2 - _) / 2 - g / 2 + v / 2, I = Math.floor((m - y) / y),
            N = (m - I * y) / 2, C = y / 2 < I * y - m;
        C && (N -= y / 4);
        for (var S = [], M = [], L = 0; L < 6; L++) {
            var P = 2 * Math.PI / 6 * L;
            S.push(Math.cos(P)), M.push(Math.sin(P))
        }
        for (var O = [], R = 0; R <= w; R++) for (var T = 0; T <= I; T++) {
            var A = R % 2 == 1;
            if (!(0 === T && A || 0 === T && C)) {
                var D = R * v + s - b, F = T * x + a + N;
                if (A && (F -= y / 2), !0 === i) vg([D, F], p / 2, f / 2, r, S, M).forEach(function (t) {
                    o ? yg(o, t) && O.push(t) : O.push(t)
                }); else {
                    var q = mg([D, F], p / 2, f / 2, r, S, M);
                    o ? yg(o, q) && O.push(q) : O.push(q)
                }
            }
        }
        return Y(O)
    }

    function mg(t, e, n, r, i, o) {
        for (var s = [], a = 0; a < 6; a++) {
            var u = t[0] + e * i[a], c = t[1] + n * o[a];
            s.push([u, c])
        }
        return s.push(s[0].slice()), B([s], r)
    }

    function vg(t, e, n, r, i, o) {
        for (var s = [], a = 0; a < 6; a++) {
            var u = [];
            u.push(t), u.push([t[0] + e * i[a], t[1] + n * o[a]]), u.push([t[0] + e * i[(a + 1) % 6], t[1] + n * o[(a + 1) % 6]]), u.push(t), s.push(B([u], r))
        }
        return s
    }

    function xg(t) {
        if (t.features.length <= 1) return t;
        var e, n, r, o = (e = t, n = dt(), r = [], A(e, function (t, e) {
            var n = W(t);
            r.push({minX: n[0], minY: n[1], maxX: n[2], maxY: n[3], geojson: t, index: e})
        }), n.load(r), n), s = [], a = {};
        return A(t, function (t, e) {
            if (a[e]) return !0;
            for (o.remove({index: e}, Eg), a[e] = !0; ;) {
                var n = W(t), r = o.search({minX: n[0], minY: n[1], maxX: n[2], maxY: n[3]});
                if (0 < r.length) {
                    var i = r.map(function (t) {
                        return a[t.index] = !0, o.remove({index: t.index}, Eg), t.geojson
                    });
                    i.push(t), t = dg.apply(this, i)
                }
                if (0 === r.length) break
            }
            s.push(t)
        }), Y(s)
    }

    function Eg(t, e) {
        return t.index === e.index
    }

    function wg(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.properties, i = n.mask, o = [];
        if (null == e) throw new Error("cellSide is required");
        if (!V(e)) throw new Error("cellSide is invalid");
        if (!t) throw new Error("bbox is required");
        if (!Array.isArray(t)) throw new Error("bbox must be array");
        if (4 !== t.length) throw new Error("bbox must contain 4 numbers");
        if (i && -1 === ["Polygon", "MultiPolygon"].indexOf(rt(i))) throw new Error("options.mask must be a (Multi)Polygon");
        for (var s = t[0], a = t[1], u = t[2], c = t[3], h = e / he([s, a], [u, a], n) * (u - s), l = e / he([s, a], [s, c], n) * (c - a), p = u - s, f = c - a, g = Math.floor(p / h), d = Math.floor(f / l), y = (f - d * l) / 2, _ = s + (p - g * h) / 2, m = 0; m < g; m++) {
            for (var v = a + y, x = 0; x < d; x++) {
                var E = B([[[_, v], [_, v + l], [_ + h, v + l], [_ + h, v], [_, v]]], r);
                i ? yg(i, E) && o.push(E) : o.push(E), v += l
            }
            _ += h
        }
        return Y(o)
    }

    function bg(t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.properties, i = n.mask, o = [];
        if (null == e) throw new Error("cellSide is required");
        if (!V(e)) throw new Error("cellSide is invalid");
        if (!t) throw new Error("bbox is required");
        if (!Array.isArray(t)) throw new Error("bbox must be array");
        if (4 !== t.length) throw new Error("bbox must contain 4 numbers");
        if (i && -1 === ["Polygon", "MultiPolygon"].indexOf(rt(i))) throw new Error("options.mask must be a (Multi)Polygon");
        for (var s = e / he([t[0], t[1]], [t[2], t[1]], n) * (t[2] - t[0]), a = e / he([t[0], t[1]], [t[0], t[3]], n) * (t[3] - t[1]), u = 0, c = t[0]; c <= t[2];) {
            for (var h = 0, l = t[1]; l <= t[3];) {
                var p = null, f = null;
                u % 2 == 0 && h % 2 == 0 ? (p = B([[[c, l], [c, l + a], [c + s, l], [c, l]]], r), f = B([[[c, l + a], [c + s, l + a], [c + s, l], [c, l + a]]], r)) : u % 2 == 0 && h % 2 == 1 ? (p = B([[[c, l], [c + s, l + a], [c + s, l], [c, l]]], r), f = B([[[c, l], [c, l + a], [c + s, l + a], [c, l]]], r)) : h % 2 == 0 && u % 2 == 1 ? (p = B([[[c, l], [c, l + a], [c + s, l + a], [c, l]]], r), f = B([[[c, l], [c + s, l + a], [c + s, l], [c, l]]], r)) : h % 2 == 1 && u % 2 == 1 && (p = B([[[c, l], [c, l + a], [c + s, l], [c, l]]], r), f = B([[[c, l + a], [c + s, l + a], [c + s, l], [c, l + a]]], r)), i ? (yg(i, p) && o.push(p), yg(i, f) && o.push(f)) : (o.push(p), o.push(f)), l += a, h++
            }
            u++, c += s
        }
        return Y(o)
    }

    t.projection = Qn, t.random = Js, t.clusters = ra, t.helpers = I, t.invariant = it, t.meta = z, t.isolines = function (t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.zProperty || "elevation", i = n.commonProperties || {}, o = n.breaksProperties || [];
        if (tt(t, "Point", "Input must contain Points"), !e) throw new Error("breaks is required");
        if (!Array.isArray(e)) throw new Error("breaks must be an Array");
        if (!H(i)) throw new Error("commonProperties must be an Object");
        if (!Array.isArray(o)) throw new Error("breaksProperties must be an Array");
        var s, a, u, c, h, l, p, f, g, d, y, _, m = function (t, e) {
            if (!H(e = e || {})) throw new Error("options is invalid");
            var n = e.zProperty || "elevation", r = e.flip, i = e.flags;
            tt(t, "Point", "input must contain Points");
            for (var o, s, a = (o = r, s = {}, L(t, function (t) {
                var e = Z(t)[1];
                s[e] || (s[e] = []), s[e].push(t)
            }), Object.keys(s).map(function (t) {
                return s[t].sort(function (t, e) {
                    return Z(t)[0] - Z(e)[0]
                })
            }).sort(function (t, e) {
                return o ? Z(t[0])[1] - Z(e[0])[1] : Z(e[0])[1] - Z(t[0])[1]
            })), u = [], c = 0; c < a.length; c++) {
                for (var h = a[c], l = [], p = 0; p < h.length; p++) {
                    var f = h[p];
                    f.properties[n] ? l.push(f.properties[n]) : l.push(0), !0 === i && (f.properties.matrixPosition = [c, p])
                }
                u.push(l)
            }
            return u
        }(t, {zProperty: r, flip: !0});
        return Y((s = function (t, e, n, r, i) {
            for (var o = [], s = 1; s < e.length; s++) {
                var a = +e[s], u = Object.assign({}, r, i[s]), c = v(at(t, u[n] = a), u);
                o.push(c)
            }
            return o
        }(m, e, r, i, o), a = m, c = (u = W(t))[2] - u[0], h = u[3] - u[1], l = u[0], p = u[1], f = a[0].length - 1, g = a.length - 1, d = c / f, y = h / g, _ = function (t) {
            t[0] = t[0] * d + l, t[1] = t[1] * y + p
        }, s.forEach(function (t) {
            N(t, _)
        }), s))
    }, t.convex = ne, t.pointsWithinPolygon = oe, t.concave = function (t, a) {
        if (!H(a = a || {})) throw new Error("options is invalid");
        if (!t) throw new Error("points is required");
        var u = a.maxEdge || 1 / 0;
        if (!V(u)) throw new Error("maxEdge is invalid");
        var n, r, e = se((n = [], r = {}, L(t, function (t) {
            if (t.geometry) {
                var e = t.geometry.coordinates.join("-");
                r.hasOwnProperty(e) || (n.push(t), r[e] = !0)
            }
        }), Y(n)));
        if (e.features = e.features.filter(function (t) {
            var e = t.geometry.coordinates[0][0], n = t.geometry.coordinates[0][1], r = t.geometry.coordinates[0][2],
                i = he(e, n, a), o = he(n, r, a), s = he(e, r, a);
            return i <= u && o <= u && s <= u
        }), e.features.length < 1) return null;
        var i = Oe(e, a);
        return 1 === i.coordinates.length && (i.coordinates = i.coordinates[0], i.type = "Polygon"), j(i)
    }, t.collect = function (t, e, n, i) {
        var o = dt(6), r = e.features.map(function (t) {
            return {
                minX: t.geometry.coordinates[0],
                minY: t.geometry.coordinates[1],
                maxX: t.geometry.coordinates[0],
                maxY: t.geometry.coordinates[1],
                property: t.properties[n]
            }
        });
        return o.load(r), t.features.forEach(function (e) {
            e.properties || (e.properties = {});
            var t = W(e), n = o.search({minX: t[0], minY: t[1], maxX: t[2], maxY: t[3]}), r = [];
            n.forEach(function (t) {
                re([t.minX, t.minY], e) && r.push(t.property)
            }), e.properties[i] = r
        }), t
    }, t.flip = function (t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.mutate;
        if (!t) throw new Error("geojson is required");
        return !1 !== n && void 0 !== n || (t = le(t)), N(t, function (t) {
            var e = t[0], n = t[1];
            t[0] = n, t[1] = e
        }), t
    }, t.simplify = function (t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = void 0 !== e.tolerance ? e.tolerance : 1, r = e.highQuality || !1, i = e.mutate || !1;
        if (!t) throw new Error("geojson is required");
        if (n && n < 0) throw new Error("invalid tolerance");
        return !0 !== i && (t = le(t)), R(t, function (t) {
            !function (t, e, n) {
                var r = t.type;
                if ("Point" !== r && "MultiPoint" !== r) {
                    Re(t, !0);
                    var i = t.coordinates;
                    switch (r) {
                        case"LineString":
                            t.coordinates = Fe(i, e, n);
                            break;
                        case"MultiLineString":
                            t.coordinates = i.map(function (t) {
                                return Fe(t, e, n)
                            });
                            break;
                        case"Polygon":
                            t.coordinates = qe(i, e, n);
                            break;
                        case"MultiPolygon":
                            t.coordinates = i.map(function (t) {
                                return qe(t, e, n)
                            })
                    }
                }
            }(t, n, r)
        }), t
    }, t.bezierSpline = Be, t.tag = function (t, n, r, i) {
        return t = le(t), n = le(n), L(t, function (e) {
            e.properties || (e.properties = {}), L(n, function (t) {
                void 0 === e.properties[i] && re(e, t) && (e.properties[i] = t.properties[r])
            })
        }), t
    }, t.sample = function (t, e) {
        if (!t) throw new Error("featurecollection is required");
        if (null == e) throw new Error("num is required");
        if ("number" != typeof e) throw new Error("num must be a number");
        return Y(function (t, e) {
            for (var n, r, i = t.slice(0), o = t.length, s = o - e; o-- > s;) n = i[r = Math.floor((o + 1) * Math.random())], i[r] = i[o], i[o] = n;
            return i.slice(s)
        }(t.features, e))
    }, t.envelope = ze, t.square = je, t.circle = Ue, t.midpoint = function (t, e) {
        return Xe(t, he(t, e) / 2, Ye(t, e))
    }, t.center = Ve, t.centerOfMass = function t(e, n) {
        switch (rt(e)) {
            case"Point":
                return e;
            case"Polygon":
                var r = [];
                N(e, function (t) {
                    r.push(t)
                });
                var i, o, s, a, u, c, h, l, p = He(e, n), f = p.geometry.coordinates, g = 0, d = 0, y = 0,
                    _ = r.map(function (t) {
                        return [t[0] - f[0], t[1] - f[1]]
                    });
                for (i = 0; i < r.length - 1; i++) a = (o = _[i])[0], c = o[1], u = (s = _[i + 1])[0], y += l = a * (h = s[1]) - u * c, g += (a + u) * l, d += (c + h) * l;
                if (0 === y) return p;
                var m = 1 / (.5 * y * 6);
                return X([f[0] + m * g, f[1] + m * d], n);
            default:
                var v = ne(e);
                return v ? t(v, n) : He(e, n)
        }
    }, t.centroid = He, t.combine = function (t) {
        var r = {
            MultiPoint: {coordinates: [], properties: []},
            MultiLineString: {coordinates: [], properties: []},
            MultiPolygon: {coordinates: [], properties: []}
        }, e = Object.keys(r).reduce(function (t, e) {
            return t[e.replace("Multi", "")] = e, t
        }, {});

        function n(t, e, n) {
            n ? r[e].coordinates = r[e].coordinates.concat(t.geometry.coordinates) : r[e].coordinates.push(t.geometry.coordinates), r[e].properties.push(t.properties)
        }

        return L(t, function (t) {
            t.geometry && (r[t.geometry.type] ? n(t, t.geometry.type, !0) : e[t.geometry.type] && n(t, e[t.geometry.type], !1))
        }), Y(Object.keys(r).filter(function (t) {
            return r[t].coordinates.length
        }).sort().map(function (t) {
            return j({type: t, coordinates: r[t].coordinates}, {collectedProperties: r[t].properties})
        }))
    }, t.distance = he, t.explode = We, t.bbox = W, t.tesselate = function (t) {
        if (!t.geometry || "Polygon" !== t.geometry.type && "MultiPolygon" !== t.geometry.type) throw new Error("input must be a Polygon or MultiPolygon");
        var e = {type: "FeatureCollection", features: []};
        return "Polygon" === t.geometry.type ? e.features = xn(t.geometry.coordinates) : t.geometry.coordinates.forEach(function (t) {
            e.features = e.features.concat(xn(t))
        }), e
    }, t.bboxPolygon = ke, t.booleanPointInPolygon = re, t.nearestPoint = En, t.nearestPointOnLine = Xn, t.nearestPointToLine = function (t, n, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var r = e.units, i = e.properties || {};
        if (!t) throw new Error("points is required");
        if (!(t = function (t) {
            var e = [];
            switch (t.geometry ? t.geometry.type : t.type) {
                case"GeometryCollection":
                    return R(t, function (t) {
                        "Point" === t.type && e.push({type: "Feature", properties: {}, geometry: t})
                    }), {type: "FeatureCollection", features: e};
                case"FeatureCollection":
                    return t.features = t.features.filter(function (t) {
                        return "Point" === t.geometry.type
                    }), t;
                default:
                    throw new Error("points must be a Point Collection")
            }
        }(t)).features.length) throw new Error("points must contain features");
        if (!n) throw new Error("line is required");
        if ("LineString" !== rt(n)) throw new Error("line must be a LineString");
        var o = 1 / 0, s = null;
        return L(t, function (t) {
            var e = $n(t, n, {units: r});
            e < o && (o = e, s = t)
        }), s && (s.properties = Object.assign({dist: o}, s.properties, i)), s
    }, t.planepoint = function (t, e) {
        var n = J(t), r = et(e).coordinates[0];
        if (r.length < 4) throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
        var i = e.properties || {}, o = i.a, s = i.b, a = i.c, u = n[0], c = n[1], h = r[0][0], l = r[0][1],
            p = void 0 !== o ? o : r[0][2], f = r[1][0], g = r[1][1], d = void 0 !== s ? s : r[1][2], y = r[2][0],
            _ = r[2][1], m = void 0 !== a ? a : r[2][2];
        return (m * (u - h) * (c - g) + p * (u - f) * (c - _) + d * (u - y) * (c - l) - d * (u - h) * (c - _) - m * (u - f) * (c - l) - p * (u - y) * (c - g)) / ((u - h) * (c - g) + (u - f) * (c - _) + (u - y) * (c - l) - (u - h) * (c - _) - (u - f) * (c - l) - (u - y) * (c - g))
    }, t.tin = se, t.bearing = Ye, t.destination = Xe, t.kinks = function (t) {
        var e, n, m = {type: "FeatureCollection", features: []};
        if ("LineString" === (n = "Feature" === t.type ? t.geometry : t).type) e = [n.coordinates]; else if ("MultiLineString" === n.type) e = n.coordinates; else if ("MultiPolygon" === n.type) e = [].concat.apply([], n.coordinates); else {
            if ("Polygon" !== n.type) throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
            e = n.coordinates
        }
        return e.forEach(function (_) {
            e.forEach(function (t) {
                for (var e = 0; e < _.length - 1; e++) for (var n = e; n < t.length - 1; n++) {
                    if (_ === t) {
                        if (1 === Math.abs(e - n)) continue;
                        if (0 === e && n === _.length - 2 && _[e][0] === _[_.length - 1][0] && _[e][1] === _[_.length - 1][1]) continue
                    }
                    var r = (i = _[e][0], o = _[e][1], s = _[e + 1][0], a = _[e + 1][1], u = t[n][0], c = t[n][1], h = t[n + 1][0], y = d = g = f = void 0, y = {
                        x: null,
                        y: null,
                        onLine1: !1,
                        onLine2: !1
                    }, 0 == (p = ((l = t[n + 1][1]) - c) * (s - i) - (h - u) * (a - o)) ? null !== y.x && null !== y.y && y : (d = (s - i) * (f = o - c) - (a - o) * (g = i - u), f = ((h - u) * f - (l - c) * g) / p, g = d / p, y.x = i + f * (s - i), y.y = o + f * (a - o), 0 <= f && f <= 1 && (y.onLine1 = !0), 0 <= g && g <= 1 && (y.onLine2 = !0), !(!y.onLine1 || !y.onLine2) && [y.x, y.y]));
                    r && m.features.push(X([r[0], r[1]]))
                }
                var i, o, s, a, u, c, h, l, p, f, g, d, y
            })
        }), m
    }, t.pointOnFeature = er, t.area = rr, t.along = function (t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r;
        if ("Feature" === t.type) r = t.geometry.coordinates; else {
            if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
            r = t.coordinates
        }
        if (!V(e)) throw new Error("distance must be a number");
        for (var i = 0, o = 0; o < r.length && !(i <= e && o === r.length - 1); o++) {
            if (e <= i) {
                var s = e - i;
                if (s) {
                    var a = Ye(r[o], r[o - 1]) - 180;
                    return Xe(r[o], s, a, n)
                }
                return X(r[o])
            }
            i += he(r[o], r[o + 1], n)
        }
        return X(r[r.length - 1])
    }, t.length = ur, t.lineSlice = function (t, e, n) {
        var r = Z(n);
        if ("LineString" !== rt(n)) throw new Error("line must be a LineString");
        for (var i, o = Xn(n, t), s = Xn(n, e), a = [(i = o.properties.index <= s.properties.index ? [o, s] : [s, o])[0].geometry.coordinates], u = i[0].properties.index + 1; u < i[1].properties.index + 1; u++) a.push(r[u]);
        return a.push(i[1].geometry.coordinates), U(a, n.properties)
    }, t.lineSliceAlong = cr, t.pointGrid = gr, t.truncate = dr, t.flatten = function (t) {
        if (!t) throw new Error("geojson is required");
        var e = [];
        return A(t, function (t) {
            e.push(t)
        }), Y(e)
    }, t.lineIntersect = zn, t.lineChunk = function (t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.units, i = n.reverse;
        if (!t) throw new Error("geojson is required");
        if (e <= 0) throw new Error("segmentLength must be greater than 0");
        var o = [];
        return A(t, function (t) {
            i && (t.geometry.coordinates = t.geometry.coordinates.reverse()), function (t, e, n, r) {
                var i = ur(t, {units: n});
                if (i <= e) return r(t);
                var o = i / e;
                Number.isInteger(o) || (o = Math.floor(o) + 1);
                for (var s = 0; s < o; s++) {
                    r(cr(t, e * s, e * (s + 1), {units: n}))
                }
            }(t, e, r, function (t) {
                o.push(t)
            })
        }), Y(o)
    }, t.unkinkPolygon = function (t) {
        var n = [];
        return A(t, function (e) {
            "Polygon" === e.geometry.type && L(function (t) {
                if ("Feature" != t.type) throw new Error("The input must a geojson object of type Feature");
                if (void 0 === t.geometry || null == t.geometry) throw new Error("The input must a geojson object with a non-empty geometry");
                if ("Polygon" != t.geometry.type) throw new Error("The input must be a geojson Polygon");
                for (var e = t.geometry.coordinates.length, n = [], r = 0; r < e; r++) {
                    var i = t.geometry.coordinates[r];
                    Er(i[0], i[i.length - 1]) || i.push(i[0]), n.push.apply(n, i.slice(0, i.length - 1))
                }
                if (!function (t) {
                    for (var e = {}, n = 1, r = 0, i = t.length; r < i; ++r) {
                        if (e.hasOwnProperty(t[r])) {
                            n = 0;
                            break
                        }
                        e[t[r]] = 1
                    }
                    return n
                }(n)) throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");
                var o = n.length, s = function (t, f, e) {
                    if ("Polygon" !== t.geometry.type) throw new Error("The input feature must be a Polygon");
                    void 0 === e && (e = 1);
                    var g = t.geometry.coordinates, d = [], y = {};
                    if (e) {
                        for (var n = [], r = 0; r < g.length; r++) for (var i = 0; i < g[r].length - 1; i++) n.push(l(r, i));
                        var o = dt();
                        o.load(n)
                    }
                    for (var s = 0; s < g.length; s++) for (var a = 0; a < g[s].length - 1; a++) if (e) o.search(l(s, a)).forEach(function (t) {
                        var e = t.ring, n = t.edge;
                        h(s, a, e, n)
                    }); else for (var u = 0; u < g.length; u++) for (var c = 0; c < g[u].length - 1; c++) h(s, a, u, c);
                    return f || (d = {type: "Feature", geometry: {type: "MultiPoint", coordinates: d}}), d;

                    function h(t, e, n, r) {
                        var i, o, s = g[t][e], a = g[t][e + 1], u = g[n][r], c = g[n][r + 1],
                            h = function (t, e, n, r) {
                                if (yr(t, n) || yr(t, r) || yr(e, n) || yr(r, n)) return null;
                                var i = t[0], o = t[1], s = e[0], a = e[1], u = n[0], c = n[1], h = r[0], l = r[1],
                                    p = (i - s) * (c - l) - (o - a) * (u - h);
                                return 0 === p ? null : [((i * a - o * s) * (u - h) - (i - s) * (u * l - c * h)) / p, ((i * a - o * s) * (c - l) - (o - a) * (u * l - c * h)) / p]
                            }(s, a, u, c);
                        if (null !== h && (i = a[0] !== s[0] ? (h[0] - s[0]) / (a[0] - s[0]) : (h[1] - s[1]) / (a[1] - s[1]), o = c[0] !== u[0] ? (h[0] - u[0]) / (c[0] - u[0]) : (h[1] - u[1]) / (c[1] - u[1]), !(1 <= i || i <= 0 || 1 <= o || o <= 0))) {
                            var l = h, p = !y[l];
                            p && (y[l] = !0), f ? d.push(f(h, t, e, s, a, i, n, r, u, c, o, p)) : d.push(h)
                        }
                    }

                    function l(t, e) {
                        var n, r, i, o, s = g[t][e], a = g[t][e + 1];
                        return r = s[0] < a[0] ? (n = s[0], a[0]) : (n = a[0], s[0]), o = s[1] < a[1] ? (i = s[1], a[1]) : (i = a[1], s[1]), {
                            minX: n,
                            minY: i,
                            maxX: r,
                            maxY: o,
                            ring: t,
                            edge: e
                        }
                    }
                }(t, function (t, e, n, r, i, o, s, a, u, c, h, l) {
                    return [t, e, n, r, i, o, s, a, u, c, h, l]
                }), a = s.length;
                if (0 == a) {
                    var u = [];
                    for (r = 0; r < e; r++) u.push(B([t.geometry.coordinates[r]], {
                        parent: -1,
                        winding: xr(t.geometry.coordinates[r])
                    }));
                    var c = Y(u);
                    return F(), q(), c
                }
                var h = [], l = [];
                for (r = 0; r < e; r++) {
                    h.push([]);
                    for (var p = 0; p < t.geometry.coordinates[r].length - 1; p++) h[r].push([new _r(t.geometry.coordinates[r][(p + 1).modulo(t.geometry.coordinates[r].length - 1)], 1, [r, p], [r, (p + 1).modulo(t.geometry.coordinates[r].length - 1)], void 0)]), l.push(new mr(t.geometry.coordinates[r][p], [r, (p - 1).modulo(t.geometry.coordinates[r].length - 1)], [r, p], void 0, void 0, !1, !0))
                }
                for (r = 0; r < a; r++) h[s[r][1]][s[r][2]].push(new _r(s[r][0], s[r][5], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0)), s[r][11] && l.push(new mr(s[r][0], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0, void 0, !0, !0));
                var f = l.length;
                for (r = 0; r < h.length; r++) for (p = 0; p < h[r].length; p++) h[r][p].sort(function (t, e) {
                    return t.param < e.param ? -1 : 1
                });
                var g = [];
                for (r = 0; r < f; r++) g.push({
                    minX: l[r].coord[0],
                    minY: l[r].coord[1],
                    maxX: l[r].coord[0],
                    maxY: l[r].coord[1],
                    index: r
                });
                var d = dt();
                for (d.load(g), r = 0; r < h.length; r++) for (p = 0; p < h[r].length; p++) for (var y = 0; y < h[r][p].length; y++) {
                    m = y == h[r][p].length - 1 ? h[r][(p + 1).modulo(t.geometry.coordinates[r].length - 1)][0].coord : h[r][p][y + 1].coord;
                    var _ = d.search({minX: m[0], minY: m[1], maxX: m[0], maxY: m[1]})[0];
                    h[r][p][y].nxtIsectAlongEdgeIn = _.index
                }
                for (r = 0; r < h.length; r++) for (p = 0; p < h[r].length; p++) for (y = 0; y < h[r][p].length; y++) {
                    var m = h[r][p][y].coord,
                        v = (_ = d.search({minX: m[0], minY: m[1], maxX: m[0], maxY: m[1]})[0]).index;
                    v < o ? l[v].nxtIsectAlongRingAndEdge2 = h[r][p][y].nxtIsectAlongEdgeIn : Er(l[v].ringAndEdge1, h[r][p][y].ringAndEdgeIn) ? l[v].nxtIsectAlongRingAndEdge1 = h[r][p][y].nxtIsectAlongEdgeIn : l[v].nxtIsectAlongRingAndEdge2 = h[r][p][y].nxtIsectAlongEdgeIn
                }
                var x = [];
                for (p = r = 0; p < e; p++) {
                    var E = r;
                    for (y = 0; y < t.geometry.coordinates[p].length - 1; y++) l[r].coord[0] < l[E].coord[0] && (E = r), r++;
                    var w = l[E].nxtIsectAlongRingAndEdge2;
                    for (y = 0; y < l.length; y++) if (l[y].nxtIsectAlongRingAndEdge1 == E || l[y].nxtIsectAlongRingAndEdge2 == E) {
                        var b = y;
                        break
                    }
                    var I = vr([l[b].coord, l[E].coord, l[w].coord], !0) ? 1 : -1;
                    x.push({isect: E, parent: -1, winding: I})
                }
                for (x.sort(function (t, e) {
                    return l[t.isect].coord > l[e.isect].coord ? -1 : 1
                }), u = []; 0 < x.length;) {
                    var N = x.pop(), C = N.isect, S = N.parent, M = N.winding, L = u.length, P = [l[C].coord], O = C;
                    if (l[C].ringAndEdge1Walkable) var R = l[C].ringAndEdge1,
                        T = l[C].nxtIsectAlongRingAndEdge1; else R = l[C].ringAndEdge2, T = l[C].nxtIsectAlongRingAndEdge2;
                    for (; !Er(l[C].coord, l[T].coord);) {
                        P.push(l[T].coord);
                        var A = void 0;
                        for (r = 0; r < x.length; r++) if (x[r].isect == T) {
                            A = r;
                            break
                        }
                        if (null != A && x.splice(A, 1), Er(R, l[T].ringAndEdge1)) {
                            if (R = l[T].ringAndEdge2, l[T].ringAndEdge2Walkable = !1, l[T].ringAndEdge1Walkable) {
                                var D = {isect: T};
                                vr([l[O].coord, l[T].coord, l[l[T].nxtIsectAlongRingAndEdge2].coord], 1 == M) ? (D.parent = S, D.winding = -M) : (D.parent = L, D.winding = M), x.push(D)
                            }
                            T = l[O = T].nxtIsectAlongRingAndEdge2
                        } else R = l[T].ringAndEdge1, l[T].ringAndEdge1Walkable = !1, l[T].ringAndEdge2Walkable && (D = {isect: T}, vr([l[O].coord, l[T].coord, l[l[T].nxtIsectAlongRingAndEdge1].coord], 1 == M) ? (D.parent = S, D.winding = -M) : (D.parent = L, D.winding = M), x.push(D)), T = l[O = T].nxtIsectAlongRingAndEdge1
                    }
                    P.push(l[T].coord), u.push(B([P], {index: L, parent: S, winding: M, netWinding: void 0}))
                }

                function F() {
                    for (var t = [], e = 0; e < c.features.length; e++) -1 == c.features[e].properties.parent && t.push(e);
                    if (1 < t.length) for (e = 0; e < t.length; e++) {
                        for (var n = -1, r = 0; r < c.features.length; r++) t[e] != r && re(c.features[t[e]].geometry.coordinates[0][0], c.features[r], {ignoreBoundary: !0}) && rr(c.features[r]) < 1 / 0 && (n = r);
                        c.features[t[e]].properties.parent = n
                    }
                }

                function q() {
                    for (var t = 0; t < c.features.length; t++) if (-1 == c.features[t].properties.parent) {
                        var e = c.features[t].properties.winding;
                        G(t, c.features[t].properties.netWinding = e)
                    }
                }

                function G(t, e) {
                    for (var n = 0; n < c.features.length; n++) if (c.features[n].properties.parent == t) {
                        var r = e + c.features[n].properties.winding;
                        G(n, c.features[n].properties.netWinding = r)
                    }
                }

                return c = Y(u), F(), q(), c
            }(e), function (t) {
                n.push(B(t.geometry.coordinates, e.properties))
            })
        }), Y(n)
    }, t.greatCircle = function (t, e, n) {
        if ("object" != typeof(n = n || {})) throw new Error("options is invalid");
        var r = n.properties, i = n.npoints, o = n.offset;
        return t = J(t), e = J(e), r = r || {}, i = i || 100, o = o || 10, new Sr({x: t[0], y: t[1]}, {
            x: e[0],
            y: e[1]
        }, r).Arc(i, {offset: o}).json()
    }, t.lineSegment = kn, t.lineSplit = function (t, e) {
        if (!t) throw new Error("line is required");
        if (!e) throw new Error("splitter is required");
        var n = rt(t), r = rt(e);
        if ("LineString" !== n) throw new Error("line must be LineString");
        if ("FeatureCollection" === r) throw new Error("splitter cannot be a FeatureCollection");
        if ("GeometryCollection" === r) throw new Error("splitter cannot be a GeometryCollection");
        var i = dr(e, {precision: 7});
        switch (r) {
            case"Point":
                return Lr(t, i);
            case"MultiPoint":
                return Mr(t, i);
            case"LineString":
            case"MultiLineString":
            case"Polygon":
            case"MultiPolygon":
                return Mr(t, zn(t, i))
        }
    }, t.lineArc = Rr, t.polygonToLine = Ar, t.lineToPolygon = Fr, t.bboxClip = function (t, e) {
        var n, r = (n = t).geometry ? n.geometry.type : n.type, i = Z(t), o = t.properties;
        switch (r) {
            case"LineString":
            case"MultiLineString":
                var s = [];
                return "LineString" === r && (i = [i]), i.forEach(function (t) {
                    Br(t, e, s)
                }), 1 === s.length ? U(s[0], o) : v(s, o);
            case"Polygon":
                return B(Xr(i, e), o);
            case"MultiPolygon":
                return x(i.map(function (t) {
                    return Xr(t, e)
                }), o);
            default:
                throw new Error("geometry " + r + " not supported")
        }
    }, t.lineOverlap = Jr, t.sector = function (t, e, n, r, i) {
        if (!H(i = i || {})) throw new Error("options is invalid");
        if (!t) throw new Error("center is required");
        if (null == n) throw new Error("bearing1 is required");
        if (null == r) throw new Error("bearing2 is required");
        if (!e) throw new Error("radius is required");
        if ("object" != typeof i) throw new Error("options must be an object");
        if (Kr(n) === Kr(r)) return Ue(t, e, i);
        var o = Z(t), s = Rr(t, e, n, r, i), a = [[o]];
        return N(s, function (t) {
            a[0].push(t)
        }), a[0].push(o), B(a)
    }, t.rhumbBearing = Un, t.rhumbDistance = Vn, t.rhumbDestination = Qr, t.polygonTangents = function (t, e) {
        var n, r, i, o = Z(t), s = Z(e);
        switch (rt(e)) {
            case"Polygon":
                n = s[0][0], r = s[0][0], i = ti(s[0][0], s[0][s[0].length - 1], o);
                var a = $r(s[0], o, i, void 0, n, r);
                n = a[0], r = a[1];
                break;
            case"MultiPolygon":
                n = s[0][0][0], r = s[0][0][0], i = ti(s[0][0][0], s[0][0][s[0][0].length - 1], o), s.forEach(function (t) {
                    var e = $r(t[0], o, i, void 0, n, r);
                    n = e[0], r = e[1]
                })
        }
        return Y([X(n), X(r)])
    }, t.rewind = function (t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.reverse || !1, r = e.mutate || !1;
        if (!t) throw new Error("<geojson> is required");
        if ("boolean" != typeof n) throw new Error("<reverse> must be a boolean");
        if ("boolean" != typeof r) throw new Error("<mutate> must be a boolean");
        !1 === r && (t = le(t));
        var i = [];
        switch (t.type) {
            case"GeometryCollection":
                return R(t, function (t) {
                    ni(t, n)
                }), t;
            case"FeatureCollection":
                return L(t, function (t) {
                    L(ni(t, n), function (t) {
                        i.push(t)
                    })
                }), Y(i)
        }
        return ni(t, n)
    }, t.isobands = function (t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.zProperty || "elevation", i = n.commonProperties || {}, o = n.breaksProperties || [];
        if (tt(t, "Point", "Input must contain Points"), !e) throw new Error("breaks is required");
        if (!Array.isArray(e)) throw new Error("breaks is not an Array");
        if (!H(i)) throw new Error("commonProperties is not an Object");
        if (!Array.isArray(o)) throw new Error("breaksProperties is not an Array");
        var s, a, u, c, h, l, p, f, g, d, y, _, m = function (t, e) {
            if (!H(e = e || {})) throw new Error("options is invalid");
            var n = e.zProperty || "elevation", r = e.flip, i = e.flags;
            tt(t, "Point", "input must contain Points");
            for (var o, s, a = (o = r, s = {}, L(t, function (t) {
                var e = Z(t)[1];
                s[e] || (s[e] = []), s[e].push(t)
            }), Object.keys(s).map(function (t) {
                return s[t].sort(function (t, e) {
                    return Z(t)[0] - Z(e)[0]
                })
            }).sort(function (t, e) {
                return o ? Z(t[0])[1] - Z(e[0])[1] : Z(e[0])[1] - Z(t[0])[1]
            })), u = [], c = 0; c < a.length; c++) {
                for (var h = a[c], l = [], p = 0; p < h.length; p++) {
                    var f = h[p];
                    f.properties[n] ? l.push(f.properties[n]) : l.push(0), !0 === i && (f.properties.matrixPosition = [c, p])
                }
                u.push(l)
            }
            return u
        }(t, {zProperty: r, flip: !0}), v = function (t, e, n) {
            for (var r = [], i = 1; i < e.length; i++) {
                var o = +e[i - 1], s = +e[i], a = oo(io(ai(t, o, s - o))), u = {};
                u.groupedRings = a, u[n] = o + "-" + s, r.push(u)
            }
            return r
        }(m, e, r);
        return s = v, a = m, c = (u = W(t))[2] - u[0], h = u[3] - u[1], l = u[0], p = u[1], f = a[0].length - 1, g = a.length - 1, d = c / f, y = h / g, _ = function (t) {
            t[0] = t[0] * d + l, t[1] = t[1] * y + p
        }, s.forEach(function (t) {
            t.groupedRings.forEach(function (t) {
                t.forEach(function (t) {
                    t.forEach(_)
                })
            })
        }), Y((v = s).map(function (t, e) {
            if (o[e] && !H(o[e])) throw new Error("Each mappedProperty is required to be an Object");
            var n = Object.assign({}, i, o[e]);
            return n[r] = t[r], x(t.groupedRings, n)
        }))
    }, t.transformRotate = uo, t.transformScale = co, t.transformTranslate = function (t, n, r, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var i = e.units, o = e.zTranslation, s = e.mutate;
        if (!t) throw new Error("geojson is required");
        if (null == n || isNaN(n)) throw new Error("distance is required");
        if (o && "number" != typeof o && isNaN(o)) throw new Error("zTranslation is not a number");
        if (o = void 0 !== o ? o : 0, 0 === n && 0 === o) return t;
        if (null == r || isNaN(r)) throw new Error("direction is required");
        return n < 0 && (n = -n, r = -r), !1 !== s && void 0 !== s || (t = le(t)), N(t, function (t) {
            var e = Z(Qr(t, n, r, {units: i}));
            t[0] = e[0], t[1] = e[1], o && 3 === t.length && (t[2] += o)
        }), t
    }, t.lineOffset = function (t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.units;
        if (!t) throw new Error("geojson is required");
        if (null == e || isNaN(e)) throw new Error("distance is required");
        var i = rt(t), o = t.properties;
        switch (i) {
            case"LineString":
                return fo(t, e, r);
            case"MultiLineString":
                var s = [];
                return A(t, function (t) {
                    s.push(fo(t, e, r).geometry.coordinates)
                }), v(s, o);
            default:
                throw new Error("geometry " + i + " is not supported")
        }
    }, t.polygonize = function (t) {
        var e = Eo.fromGeoJson(t);
        e.deleteDangles(), e.deleteCutEdges();
        var n = [], r = [];
        return e.getEdgeRings().filter(function (t) {
            return t.isValid()
        }).forEach(function (t) {
            t.isHole() ? n.push(t) : r.push(t)
        }), n.forEach(function (t) {
            vo.findEdgeRingContaining(t, r) && r.push(t)
        }), Y(r.map(function (t) {
            return t.toPolygon()
        }))
    }, t.booleanDisjoint = function (t, n) {
        var r;
        return A(t, function (e) {
            A(n, function (t) {
                if (!1 === r) return !1;
                r = function (t, e) {
                    switch (t.type) {
                        case"Point":
                            switch (e.type) {
                                case"Point":
                                    return n = t.coordinates, r = e.coordinates, !(n[0] === r[0] && n[1] === r[1]);
                                case"LineString":
                                    return !wo(e, t);
                                case"Polygon":
                                    return !re(t, e)
                            }
                            break;
                        case"LineString":
                            switch (e.type) {
                                case"Point":
                                    return !wo(t, e);
                                case"LineString":
                                    return !(0 < zn(t, e).features.length);
                                case"Polygon":
                                    return !bo(e, t)
                            }
                            break;
                        case"Polygon":
                            switch (e.type) {
                                case"Point":
                                    return !re(e, t);
                                case"LineString":
                                    return !bo(t, e);
                                case"Polygon":
                                    return !function (t, e) {
                                        for (var n = 0; n < t.coordinates[0].length; n++) if (re(t.coordinates[0][n], e)) return !0;
                                        for (var r = 0; r < e.coordinates[0].length; r++) if (re(e.coordinates[0][r], t)) return !0;
                                        return !1
                                    }(e, t)
                            }
                    }
                    var n, r
                }(e.geometry, t.geometry)
            })
        }), r
    }, t.booleanContains = function (t, e) {
        var n = rt(t), r = rt(e), i = et(t), o = et(e), s = Z(t), a = Z(e);
        switch (n) {
            case"Point":
                switch (r) {
                    case"Point":
                        return No(s, a);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"MultiPoint":
                switch (r) {
                    case"Point":
                        return function (t, e) {
                            var n, r = !1;
                            for (n = 0; n < t.coordinates.length; n++) if (No(t.coordinates[n], e.coordinates)) {
                                r = !0;
                                break
                            }
                            return r
                        }(i, o);
                    case"MultiPoint":
                        return function (t, e) {
                            for (var n = 0; n < e.coordinates.length; n++) {
                                for (var r = !1, i = 0; i < t.coordinates.length; i++) if (No(e.coordinates[n], t.coordinates[i])) {
                                    r = !0;
                                    break
                                }
                                if (!r) return !1
                            }
                            return !0
                        }(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"LineString":
                switch (r) {
                    case"Point":
                        return hr(o, i, {ignoreEndVertices: !0});
                    case"LineString":
                        return function (t, e) {
                            for (var n = !1, r = 0; r < e.coordinates.length; r++) if (hr({
                                type: "Point",
                                coordinates: e.coordinates[r]
                            }, t, {ignoreEndVertices: !0}) && (n = !0), !hr({
                                type: "Point",
                                coordinates: e.coordinates[r]
                            }, t, {ignoreEndVertices: !1})) return !1;
                            return n
                        }(i, o);
                    case"MultiPoint":
                        return function (t, e) {
                            for (var n = !1, r = 0; r < e.coordinates.length; r++) if (hr(e.coordinates[r], t, {ignoreEndVertices: !0}) && (n = !0), !hr(e.coordinates[r], t)) return !1;
                            return !!n
                        }(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"Polygon":
                switch (r) {
                    case"Point":
                        return re(o, i, {ignoreBoundary: !0});
                    case"LineString":
                        return function (t, e) {
                            var n, r, i = !1, o = 0;
                            if (!Io(W(t), W(e))) return !1;
                            for (; o < e.coordinates.length - 1; o++) {
                                if (re({
                                    type: "Point",
                                    coordinates: (n = e.coordinates[o], r = e.coordinates[o + 1], [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2])
                                }, t, {ignoreBoundary: !0})) {
                                    i = !0;
                                    break
                                }
                            }
                            return i
                        }(i, o);
                    case"Polygon":
                        return function (t, e) {
                            if (!Io(W(t), W(e))) return !1;
                            for (var n = 0; n < e.coordinates[0].length; n++) if (!re(e.coordinates[0][n], t)) return !1;
                            return !0
                        }(i, o);
                    case"MultiPoint":
                        return function (t, e) {
                            for (var n = 0; n < e.coordinates.length; n++) if (!re(e.coordinates[n], t, {ignoreBoundary: !0})) return !1;
                            return !0
                        }(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + n + " geometry not supported")
        }
    }, t.booleanCrosses = function (t, e) {
        var n = rt(t), r = rt(e), i = et(t), o = et(e);
        switch (n) {
            case"MultiPoint":
                switch (r) {
                    case"LineString":
                        return Co(i, o);
                    case"Polygon":
                        return Mo(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"LineString":
                switch (r) {
                    case"MultiPoint":
                        return Co(o, i);
                    case"LineString":
                        return function (t, e) {
                            if (0 < zn(t, e).features.length) for (var n = 0; n < t.coordinates.length - 1; n++) for (var r = 0; r < e.coordinates.length - 1; r++) {
                                var i = !0;
                                if (0 !== r && r !== e.coordinates.length - 2 || (i = !1), Lo(t.coordinates[n], t.coordinates[n + 1], e.coordinates[r], i)) return !0
                            }
                            return !1
                        }(i, o);
                    case"Polygon":
                        return So(i, o);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            case"Polygon":
                switch (r) {
                    case"MultiPoint":
                        return Mo(o, i);
                    case"LineString":
                        return So(o, i);
                    default:
                        throw new Error("feature2 " + r + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + n + " geometry not supported")
        }
    }, t.booleanClockwise = ei, t.booleanOverlap = Go, t.booleanPointOnLine = hr, t.booleanEqual = function (t, e) {
        if (!t) throw new Error("feature1 is required");
        if (!e) throw new Error("feature2 is required");
        return rt(t) === rt(e) && new qo({precision: 6}).compare(Re(t), Re(e))
    }, t.booleanWithin = lr, t.clone = le, t.cleanCoords = Re, t.clustersDbscan = function (n, t, e) {
        if ("object" != typeof(e = e || {})) throw new Error("options is invalid");
        var r = e.minPoints, i = e.units;
        if (tt(n, "Point", "Input must contain Points"), null == t) throw new Error("maxDistance is required");
        if (!(0 < Math.sign(t))) throw new Error("Invalid maxDistance");
        if (!(null == r || 0 < Math.sign(r))) throw new Error("Invalid minPoints");
        n = le(n), r = r || 3;
        var o = new Xo.DBSCAN, s = o.run(O(n), _(t, i), r, he), a = -1;
        return s.forEach(function (t) {
            a++, t.forEach(function (t) {
                var e = n.features[t];
                e.properties || (e.properties = {}), e.properties.cluster = a, e.properties.dbscan = "core"
            })
        }), o.noise.forEach(function (t) {
            var e = n.features[t];
            e.properties || (e.properties = {}), e.properties.cluster ? e.properties.dbscan = "edge" : e.properties.dbscan = "noise"
        }), n
    }, t.clustersKmeans = function (t, e) {
        if ("object" != typeof(e = e || {})) throw new Error("options is invalid");
        var n = e.numberOfClusters, r = e.mutate;
        tt(t, "Point", "Input must contain Points");
        var i = t.features.length;
        i < (n = n || Math.round(Math.sqrt(i / 2))) && (n = i), !1 !== r && void 0 !== r || (t = le(t));
        var o = O(t), s = o.slice(0, n), a = Jo(o, n, s), u = {};
        return a.centroids.forEach(function (t, e) {
            u[e] = t
        }), L(t, function (t, e) {
            var n = a.idxs[e];
            t.properties.cluster = n, t.properties.centroid = u[n]
        }), t
    }, t.pointToLineDistance = $n, t.booleanParallel = function (t, e) {
        if (!t) throw new Error("line1 is required");
        if (!e) throw new Error("line2 is required");
        if ("LineString" !== Zo(t, "line1")) throw new Error("line1 must be a LineString");
        if ("LineString" !== Zo(e, "line2")) throw new Error("line2 must be a LineString");
        for (var n, r, i = kn(Re(t)).features, o = kn(Re(e)).features, s = 0; s < i.length; s++) {
            var a = i[s].geometry.coordinates;
            if (!o[s]) break;
            if (r = o[s].geometry.coordinates, p(Un((n = a)[0], n[1])) !== p(Un(r[0], r[1]))) return !1
        }
        return !0
    }, t.shortestPath = function (t, e, n) {
        if (!H(n = n || {})) throw new Error("options is invalid");
        var r = n.resolution, i = n.minDistance, o = n.obstacles || Y([]);
        if (!t) throw new Error("start is required");
        if (!e) throw new Error("end is required");
        if (r && !V(r) || r <= 0) throw new Error("options.resolution must be a number, greater than 0");
        if (i) throw new Error("options.minDistance is not yet implemented");
        var s = J(t), a = J(e);
        switch (t = X(s), e = X(a), rt(o)) {
            case"FeatureCollection":
                if (0 === o.features.length) return U([s, a]);
                break;
            case"Polygon":
                o = Y([j(et(o))]);
                break;
            default:
                throw new Error("invalid obstacles")
        }
        var u = o;
        u.features.push(t), u.features.push(e);
        var c = W(co(ke(W(u)), 1.15));
        r || (r = he([c[0], c[1]], [c[2], c[1]], n) / 100), u.features.pop(), u.features.pop();
        for (var h = c[0], l = c[1], p = c[2], f = c[3], g = r / he([h, l], [p, l], n) * (p - h), d = r / he([h, l], [h, f], n) * (f - l), y = p - h, _ = f - l, m = Math.floor(y / g), v = Math.floor(_ / d), x = (y - m * g) / 2, E = [], w = [], b = [], I = [], N = 1 / 0, C = 1 / 0, S = f - (_ - v * d) / 2, M = 0; l <= S;) {
            for (var L = [], P = [], O = h + x, R = 0; O <= p;) {
                var T = X([O, S]), A = ns(T, o);
                L.push(A ? 0 : 1), P.push(O + "|" + S);
                var D = he(T, t);
                !A && D < N && (N = D, b = {x: R, y: M});
                var F = he(T, e);
                !A && F < C && (C = F, I = {x: R, y: M}), O += g, R++
            }
            w.push(L), E.push(P), S -= d, M++
        }
        var q = new $o(w, {diagonal: !0}), G = q.grid[b.y][b.x], B = q.grid[I.y][I.x], k = Qo.search(q, G, B), z = [s];
        return k.forEach(function (t) {
            var e = E[t.x][t.y].split("|");
            z.push([+e[0], +e[1]])
        }), z.push(a), Re(U(z))
    }, t.voronoi = function (t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.bbox || [-180, -85, 180, 85];
        if (!t) throw new Error("points is required");
        if (!Array.isArray(n)) throw new Error("bbox is invalid");
        return tt(t, "Point", "points"), Y(function () {
            var i = is, o = os, e = null;

            function n(r) {
                return new qs(r.map(function (t, e) {
                    var n = [Math.round(i(t, e, r) / As) * As, Math.round(o(t, e, r) / As) * As];
                    return n.index = e, n.data = t, n
                }), e)
            }

            return n.polygons = function (t) {
                return n(t).polygons()
            }, n.links = function (t) {
                return n(t).links()
            }, n.triangles = function (t) {
                return n(t).triangles()
            }, n.x = function (t) {
                return arguments.length ? (i = "function" == typeof t ? t : rs(+t), n) : i
            }, n.y = function (t) {
                return arguments.length ? (o = "function" == typeof t ? t : rs(+t), n) : o
            }, n.extent = function (t) {
                return arguments.length ? (e = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], n) : e && [[e[0][0], e[0][1]], [e[1][0], e[1][1]]]
            }, n.size = function (t) {
                return arguments.length ? (e = null == t ? null : [[0, 0], [+t[0], +t[1]]], n) : e && [e[1][0] - e[0][0], e[1][1] - e[0][1]]
            }, n
        }().x(function (t) {
            return t.geometry.coordinates[0]
        }).y(function (t) {
            return t.geometry.coordinates[1]
        }).extent([[n[0], n[1]], [n[2], n[3]]]).polygons(t.features).map(Gs))
    }, t.ellipse = Bs, t.centerMean = zs, t.centerMedian = function (t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.counter || 10;
        if (!V(n)) throw new Error("counter must be a number");
        var r = e.weight, i = zs(t, {weight: e.weight}), o = Y([]);
        return L(t, function (t) {
            o.features.push(He(t, {weight: t.properties[r]}))
        }), o.properties = {tolerance: e.tolerance, medianCandidates: []}, function t(o, e, n, r) {
            var i = n.properties.tolerance || .001, s = 0, a = 0, u = 0, c = 0;
            if (L(n, function (t) {
                var e = t.properties.weight, n = null == e ? 1 : e;
                if (!V(n = Number(n))) throw new Error("weight value must be a number");
                if (0 < n) {
                    c += 1;
                    var r = n * he(t, o);
                    0 === r && (r = 1);
                    var i = n / r;
                    s += t.geometry.coordinates[0] * i, a += t.geometry.coordinates[1] * i, u += i
                }
            }), c < 1) throw new Error("no features to measure");
            var h = s / u, l = a / u;
            return 1 === c || 0 === r || Math.abs(h - e[0]) < i && Math.abs(l - e[1]) < i ? X([h, l], {medianCandidates: n.properties.medianCandidates}) : (n.properties.medianCandidates.push([h, l]), t([h, l], o, n, r - 1))
        }(i.geometry.coordinates, [0, 0], o, n)
    }, t.standardDeviationalEllipse = function (t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var n = e.steps || 64, r = e.weight, i = e.properties || {};
        if (!V(n)) throw new Error("steps must be a number");
        if (!H(i)) throw new Error("properties must be a number");
        var o = O(t).length, s = zs(t, {weight: r}), a = 0, u = 0, c = 0;
        L(t, function (t) {
            var e = t.properties[r] || 1, n = js(Z(t), Z(s));
            a += Math.pow(n.x, 2) * e, u += Math.pow(n.y, 2) * e, c += n.x * n.y * e
        });
        var h = a - u, l = Math.sqrt(Math.pow(h, 2) + 4 * Math.pow(c, 2)), p = 2 * c, f = Math.atan((h + l) / p),
            g = 180 * f / Math.PI, d = 0, y = 0, _ = 0;
        L(t, function (t) {
            var e = t.properties[r] || 1, n = js(Z(t), Z(s));
            d += Math.pow(n.x * Math.cos(f) - n.y * Math.sin(f), 2) * e, y += Math.pow(n.x * Math.sin(f) + n.y * Math.cos(f), 2) * e, _ += e
        });
        var m = Math.sqrt(2 * d / _), v = Math.sqrt(2 * y / _),
            x = Bs(s, m, v, {units: "degrees", angle: g, steps: n, properties: i}), E = oe(t, Y([x])), w = {
                meanCenterCoordinates: Z(s),
                semiMajorAxis: m,
                semiMinorAxis: v,
                numberOfFeatures: o,
                angle: g,
                percentageWithinEllipse: 100 * O(E).length / o
            };
        return x.properties.standardDeviationalEllipse = w, x
    }, t.difference = function (t, e) {
        var n = et(t), r = et(e), i = t.properties || {};
        if (n = Xp(n), r = Xp(r), !n) return null;
        if (!r) return j(n, i);
        var o = new Lc, s = o.read(n), a = o.read(r), u = Tp.difference(s, a);
        return u.isEmpty() ? null : j((new Pc).write(u), i)
    }, t.buffer = function (t, n, e) {
        var r = (e = e || {}).units, i = e.steps || 64;
        if (!t) throw new Error("geojson is required");
        if ("object" != typeof e) throw new Error("options must be an object");
        if ("number" != typeof i) throw new Error("steps must be an number");
        if (void 0 === n) throw new Error("radius is required");
        if (i <= 0) throw new Error("steps must be greater than 0");
        i = i || 64, r = r || "kilometers";
        var o = [];
        switch (t.type) {
            case"GeometryCollection":
                return R(t, function (t) {
                    var e = fg(t, n, r, i);
                    e && o.push(e)
                }), Y(o);
            case"FeatureCollection":
                return L(t, function (t) {
                    var e = fg(t, n, r, i);
                    e && L(e, function (t) {
                        t && o.push(t)
                    })
                }), Y(o)
        }
        return fg(t, n, r, i)
    }, t.union = dg, t.intersect = yg, t.dissolve = function (t, e) {
        if (!H(e = e || {})) throw new Error("options is invalid");
        var o = e.propertyName;
        tt(t, "Polygon", "dissolve");
        var n = le(t), s = n.features, a = [];
        s.forEach(function (t, e) {
            t.properties.origIndexPosition = e
        });
        var u = qn();
        for (var c in u.load(n), s) {
            var h = s[c], l = !1;
            if (u.search(h).features.forEach(function (t) {
                h = s[c];
                var e = t.properties.origIndexPosition;
                if (0 < a.length && 0 !== e) if (e > a[a.length - 1]) e -= a.length; else {
                    var n = function (r, t, e) {
                        var i, o;
                        if (!Array.isArray(t)) throw new Error("Get closest expects an array as second argument");
                        return t.forEach(function (t, e) {
                            var n = t - r;
                            0 <= n && (void 0 === o || n < o) && (o = n, i = e)
                        }), i
                    }(e, a);
                    0 !== n && (e -= n)
                }
                if (e !== +c) {
                    var r, i = s[e];
                    i && h && (void 0 !== o && i.properties[o] !== h.properties[o] || Go(h, i) && (r = i, 0 < zn(U(O(h)), U(O(r))).features.length) && (s[c] = dg(h, i), a.push(t.properties.origIndexPosition), a.sort(function (t, e) {
                        return t - e
                    }), u.remove(t), s.splice(e, 1), h.properties.origIndexPosition = c, u.remove(h, function (t, e) {
                        return t.properties.origIndexPosition === e.properties.origIndexPosition
                    }), l = !0))
                }
            }), l) {
                if (!h) continue;
                h.properties.origIndexPosition = c, u.insert(h), c--
            }
        }
        return s.forEach(function (t) {
            delete t.properties.origIndexPosition, delete t.bbox
        }), n
    }, t.hexGrid = _g, t.mask = function (t, e) {
        var n, i, o, r, s, a,
            u = B((n = e) && n.geometry.coordinates || [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]]),
            c = (i = [], o = [], A(t, function (t) {
                var e = t.geometry.coordinates, n = e[0], r = e.slice(1);
                i.push(B([n])), r.forEach(function (t) {
                    o.push(B([t]))
                })
            }), [Y(i), Y(o)]), h = c[0], l = c[1];
        return r = h = xg(h), s = l = xg(l), (a = []).push(u.geometry.coordinates[0]), A(r, function (t) {
            a.push(t.geometry.coordinates[0])
        }), A(s, function (t) {
            a.push(t.geometry.coordinates[0])
        }), B(a)
    }, t.squareGrid = wg, t.triangleGrid = bg, t.interpolate = function (e, t, a) {
        if ("object" != typeof(a = a || {})) throw new Error("options is invalid");
        var u = a.gridType, c = a.property, h = a.weight;
        if (!e) throw new Error("points is required");
        if (tt(e, "Point", "input must contain Points"), !t) throw new Error("cellSize is required");
        if (void 0 !== h && "number" != typeof h) throw new Error("weight must be a number");
        c = c || "elevation", u = u || "square", h = h || 1;
        var n, r = W(e);
        switch (u) {
            case"point":
            case"points":
                n = gr(r, t, a);
                break;
            case"square":
            case"squares":
                n = wg(r, t, a);
                break;
            case"hex":
            case"hexes":
                n = _g(r, t, a);
                break;
            case"triangle":
            case"triangles":
                n = bg(r, t, a);
                break;
            default:
                throw new Error("invalid gridType")
        }
        var l = [];
        return L(n, function (i) {
            var o = 0, s = 0;
            L(e, function (t) {
                var e, n = he("point" === u ? i : He(i), t, a);
                if (void 0 !== c && (e = t.properties[c]), void 0 === e && (e = t.geometry.coordinates[2]), void 0 === e) throw new Error("zValue is missing");
                0 === n && (o = e);
                var r = 1 / Math.pow(n, h);
                s += r, o += r * e
            });
            var t = le(i);
            t.properties[c] = o / s, l.push(t)
        }), Y(l)
    }, t.pointOnSurface = er,t.polygonToLineString = Ar,t.lineStringToPolygon = Fr,t.inside = re,t.within = oe,t.bezier = Be,t.nearest = En,t.pointOnLine = Xn,t.lineDistance = ur,t.radians2degrees = y,t.degrees2radians = m,t.distanceToDegrees = l,t.distanceToRadians = d,t.radiansToDistance = g,t.bearingToAngle = p,t.convertDistance = _,t.toMercator = Hn,t.toWgs84 = Wn,t.randomPosition = Xs,t.randomPoint = Us,t.randomPolygon = Ys,t.randomLineString = Vs,t.getCluster = Zs,t.clusterEach = Ks,t.clusterReduce = Qs,t.createBins = $s,t.applyFilter = ta,t.propertiesContainsFilter = ea,t.filterProperties = na,t.earthRadius = f,t.factors = r,t.unitsFactors = e,t.areaFactors = o,t.feature = j,t.geometry = n,t.point = X,t.points = i,t.polygon = B,t.polygons = s,t.lineString = U,t.lineStrings = a,t.featureCollection = Y,t.multiLineString = v,t.multiPoint = u,t.multiPolygon = x,t.geometryCollection = c,t.round = h,t.radiansToLength = g,t.lengthToRadians = d,t.lengthToDegrees = l,t.bearingToAzimuth = p,t.radiansToDegrees = y,t.degreesToRadians = m,t.convertLength = _,t.convertArea = E,t.isNumber = V,t.isObject = H,t.validateBBox = w,t.validateId = b,t.getCoord = J,t.getCoords = Z,t.containsNumber = K,t.geojsonType = Q,t.featureOf = $,t.collectionOf = tt,t.getGeom = et,t.getGeomType = nt,t.getType = rt,t.coordEach = N,t.coordReduce = C,t.propEach = S,t.propReduce = M,t.featureEach = L,t.featureReduce = P,t.coordAll = O,t.geomEach = R,t.geomReduce = T,t.flattenEach = A,t.flattenReduce = D,t.segmentEach = F,t.segmentReduce = q,t.lineEach = G,t.lineReduce = k,Object.defineProperty(t, "__esModule", {value: !0})
});